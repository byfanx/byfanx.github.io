<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Docker初使用</title>
    <url>/2019/11/11/docker-initUse/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最近准备入坑docker，被各种安利说好用，我也准备亲自尝试一下了，但是网上那些零零散散的东西并不是一个完整的教程，官方文档看的也晕晕乎乎的，那就自以一点点踩坑，然后自己做个详细的入门笔记吧。</p>
<span id="more"></span>

<h1 id="Docker初使用"><a href="#Docker初使用" class="headerlink" title="Docker初使用"></a>Docker初使用</h1><h2 id="1-Dcoker"><a href="#1-Dcoker" class="headerlink" title="1. Dcoker"></a>1. Dcoker</h2><h3 id="1-1-什么是Docker"><a href="#1-1-什么是Docker" class="headerlink" title="1.1 什么是Docker"></a>1.1 什么是Docker</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>Docker</strong>是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。</p>
<h3 id="1-2-Docker的应用场景"><a href="#1-2-Docker的应用场景" class="headerlink" title="1.2 Docker的应用场景"></a>1.2 Docker的应用场景</h3><ul>
<li>Web 应用的自动化打包和发布。</li>
<li>自动化测试和持续集成、发布。</li>
<li>在服务型环境中部署和调整数据库或其他的后台应用。</li>
<li>从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS 环境。</li>
</ul>
<h3 id="1-3-Docker的优势"><a href="#1-3-Docker的优势" class="headerlink" title="1.3 Docker的优势"></a>1.3 Docker的优势</h3><ul>
<li>快速，一致地交付您的应用程序</li>
<li>响应式部署和扩展</li>
<li>在同一硬件上运行更多工作负载</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们可以从下面这张表格很清楚地看到容器相比于传统虚拟机的特性的优势所在：</p>
<table>
<thead>
<tr>
<th align="center">特性</th>
<th align="center">容器</th>
<th align="center">虚拟机</th>
</tr>
</thead>
<tbody><tr>
<td align="center">启动</td>
<td align="center">秒级</td>
<td align="center">分钟级</td>
</tr>
<tr>
<td align="center">硬盘使用</td>
<td align="center">一般为MB</td>
<td align="center">一般为GB</td>
</tr>
<tr>
<td align="center">性能</td>
<td align="center">接近原生</td>
<td align="center">弱于</td>
</tr>
<tr>
<td align="center">系统支持量</td>
<td align="center">单机支持上千个容器</td>
<td align="center">一般是几十个</td>
</tr>
</tbody></table>
<h3 id="1-4-Docker架构"><a href="#1-4-Docker架构" class="headerlink" title="1.4 Docker架构"></a>1.4 Docker架构</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Docker包括三个基本概念分别是<strong>Image</strong>(镜像)、<strong>Container</strong>(容器)和<strong>Repository</strong>(仓库)。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>Image(镜像)</strong> ：Docker镜像就相当于是一个root文件系统，就是一堆只读层(read-only layer)的统一视角。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。<br><img  src="Docker%E9%95%9C%E5%83%8F.png"  ><span class="image-caption">镜像</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>Container(容器)</strong> ：容器(container)的定义和镜像(image)几乎一模一样，也是一堆层的统一视角，唯一区别在于容器的最上面那一层是可读可写的。由于容器的定义并没有提及是否要运行容器，所以实际上，容器 = 镜像 + 读写层。<br>镜像(Image)和容器(Container)的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。<br><img  src="Docker%E5%AE%B9%E5%99%A8.png"  ><span class="image-caption">容器</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>Repository(仓库)</strong> ：仓库可看着一个代码控制中心，用来保存镜像。通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本 。我们可以通过&lt;仓库名&gt;:&lt;标签&gt;的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以latest作为默认标签。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Docker使用客户端-服务器(C/S)架构模式，使用远程API来管理和创建Docker容器。Docker容器通过Docker镜像来创建。容器与镜像的关系类似于面向对象编程中的对象与类。Docker 客户端与 Docker 服务器进行交互，Docker服务端负责构建、运行和分发Docker镜像。Docker客户端和服务端可以运行在一台机器上，也可以通过RESTful、stock或网络接口与远程Docker服务端进行通信。</p>
<table>
<thead>
<tr>
<th align="left">Docker</th>
<th>面向对象</th>
</tr>
</thead>
<tbody><tr>
<td align="left">容器</td>
<td>对象</td>
</tr>
<tr>
<td align="left">镜像</td>
<td>类</td>
</tr>
</tbody></table>
<p><img  src="Docker%E6%9E%B6%E6%9E%84.png"  ><span class="image-caption">架构</span></p>
<table>
<thead>
<tr>
<th align="left">概念</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Docker 镜像(Images)</td>
<td align="left">Docker 镜像是用于创建 Docker 容器的模板，比如 Ubuntu 系统。</td>
</tr>
<tr>
<td align="left">Docker 容器(Container)</td>
<td align="left">容器是独立运行的一个或一组应用，是镜像运行时的实体。</td>
</tr>
<tr>
<td align="left">Docker 客户端(Client)</td>
<td align="left">Docker 客户端通过命令行或者其他工具使用 <a href="https://docs.docker.com/develop/sdk/" title="Docker SDK">Docker SDK</a> 与 Docker 的守护进程通信。</td>
</tr>
<tr>
<td align="left">Docker 主机(Host)</td>
<td align="left">一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。</td>
</tr>
<tr>
<td align="left">Docker 仓库(Registry)</td>
<td align="left">Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。<a href="https://hub.docker.com/" title="Docker Hub">Docker Hub</a> 提供了庞大的镜像集合供使用。一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 &lt;仓库名&gt;:&lt;标签&gt; 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。</td>
</tr>
<tr>
<td align="left">Docker Machine</td>
<td align="left">Docker Machine是一个简化Docker安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装Docker，比如VirtualBox、 Digital Ocean、Microsoft Azure。</td>
</tr>
</tbody></table>
<h2 id="2-安装Docker"><a href="#2-安装Docker" class="headerlink" title="2. 安装Docker"></a>2. 安装Docker</h2><h3 id="2-1-开始安装"><a href="#2-1-开始安装" class="headerlink" title="2.1 开始安装"></a>2.1 开始安装</h3><p>由于apt官方库的docker版本可能比较旧，所以先卸载可能存在的旧版本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ sudo apt-get remove docker docker-engine docker-ce docker.io<br></code></pre></td></tr></table></figure>

<p>更新apt包索引：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ sudo apt-get update  <br></code></pre></td></tr></table></figure>

<p>安装以下包以使apt可以通过HTTPS使用存储库(repository):</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ sudo apt-get install -y apt-transport-https ca-certificates curl software-properties-common<br></code></pre></td></tr></table></figure>

<p>添加Docker软件源的官方GPG密钥:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -<br><br><span class="hljs-comment"># 国内源</span><br><span class="hljs-comment"># $ curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>如果执行上述命令出现下面提示，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">gpg: failed to start agent <span class="hljs-string">&#x27;/usr/bin/gpg-agent&#x27;</span>: No such file or directory<br>gpg: can<span class="hljs-string">&#x27;t connect to the agent: No such file or directory</span><br></code></pre></td></tr></table></figure>

<p>则很有可能是没有安装<strong>gpg-agent</strong>包，执行下面命令进行安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">apt-get install gpg-agent<br></code></pre></td></tr></table></figure>

<p>安装完成之后，再次去执行添加密钥的命令。</p>
</blockquote>
<p>使用下面命令来设置stable存储库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ sudo add-apt-repository <span class="hljs-string">&quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu <span class="hljs-subst">$(lsb_release -cs)</span> stable&quot;</span><br><br><span class="hljs-comment"># 国内源</span><br><span class="hljs-comment"># $ sudo add-apt-repository &quot;deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu $(lsb_release -cs) stable&quot; </span><br></code></pre></td></tr></table></figure>

<p>再更新一下apt包索引：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ sudo apt-get update<br></code></pre></td></tr></table></figure>

<p>安装最新版本的Docker CE：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ sudo apt-get install -y docker-ce<br></code></pre></td></tr></table></figure>
<blockquote>
<p>因为对docker操作需要的是管理员权限,所以普通用户操作时需要加上sudo命令,如果是管理员,,则正常输入命令,不用带sudo。</p>
</blockquote>
<h3 id="2-2-验证docker"><a href="#2-2-验证docker" class="headerlink" title="2.2 验证docker"></a>2.2 验证docker</h3><p>查看docker版本:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ sudo docker version<br></code></pre></td></tr></table></figure>

<p><img  src="docker%E7%89%88%E6%9C%AC.png"  ><span class="image-caption">版本</span></p>
<p>启动docker服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ sudo systemctl start docker<br></code></pre></td></tr></table></figure>

<p>查看docker服务是否启动:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ sudo systemctl status docker<br></code></pre></td></tr></table></figure>

<p><img  src="docker%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81.png"  ><span class="image-caption">运行状态</span></p>
<h2 id="3-使用Docker"><a href="#3-使用Docker" class="headerlink" title="3. 使用Docker"></a>3. 使用Docker</h2><h3 id="3-1-MySql镜像"><a href="#3-1-MySql镜像" class="headerlink" title="3.1 MySql镜像"></a>3.1 MySql镜像</h3><p>查看现有镜像：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">docker search mysql<br></code></pre></td></tr></table></figure>

<p><span id="search"></span></p>
<p><img  src="searchMysql.png"  ><span class="image-caption">serachMysql</span></p>
<blockquote>
<p><strong>name：</strong>表示名称</p>
<p><strong>Description：</strong>介绍说明</p>
<p><strong>Stars：</strong>关注度</p>
<p><strong>Official：</strong>是不是官方的</p>
<p><strong>Automated：</strong>是不是私有创建的</p>
</blockquote>
<p>拉取mysql 5.7版本的镜像：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">docker pull mysql:5.7<br></code></pre></td></tr></table></figure>

<blockquote>
<p>冒号后面跟的是要拉取的版本号，如果不标明版本号，则默认拉取最新版本的。</p>
</blockquote>
<p>运行镜像：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">docker run -d -p 3306:3306 --name mysql -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7 <br></code></pre></td></tr></table></figure>

<blockquote>
<p><strong>-d：</strong>标识是让docker容器在后台运行。</p>
<p><strong>-p：</strong>标识端口映射，前面是主机对外服务端口，后面是映射到docker容器的端口。</p>
<p><strong>–name：</strong>定义一个容器的名字，方便后面执行操作。如果没有指定name，那么deamon会自动生成一个随机数字符串当作UUID。</p>
<p><strong>-e：</strong>设置环境变量或者覆盖已存在的环境变量。在此设置的是mysql的密码。</p>
</blockquote>
<p>这样就已经在docker里运行了一个mysql，可以在主机上通过可视化工具进行远程连接了。</p>
<h3 id="3-2-Tomcat镜像"><a href="#3-2-Tomcat镜像" class="headerlink" title="3.2 Tomcat镜像"></a>3.2 Tomcat镜像</h3><p>查询现有镜像：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">docker search tomcat<br></code></pre></td></tr></table></figure>

<p><img  src="searchTomcat.png"  ><span class="image-caption">searchTomcat</span></p>
<p>拉取tomcat 8.5版本的镜像：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">docket pull tomcat:8.5<br></code></pre></td></tr></table></figure>

<p>查看拉取的镜像：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">docker images<br></code></pre></td></tr></table></figure>

<p><img  src="images.png"  ><span class="image-caption">images</span></p>
<p>运行tomcat镜像：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">docker run -d -p 8080:8080 --name mytomcat tomcat:8.5<br></code></pre></td></tr></table></figure>

<p>将目录下的war包部署到tomcat镜像：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">docker cp hello.war mytomcat:/usr/<span class="hljs-built_in">local</span>/tomcat/webapps/<br></code></pre></td></tr></table></figure>

<blockquote>
<p>将war包部署到tomcat镜像就是将war包放到镜像里的wabapps文件夹里。</p>
<p>docker cp [war包路径] [镜像名称或镜像ID]:/usr/local/tomcat/wabapps/</p>
</blockquote>
<p>重启镜像：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">docker restart mytomcat<br></code></pre></td></tr></table></figure>

<p>进入容器内部：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it mytomcat /bin/bash<br></code></pre></td></tr></table></figure>

<blockquote>
<p>通过以上命令就已经进入到容器内部，进行一个交互操作，退出时执行<strong>exit</strong>就行。</p>
</blockquote>
<h2 id="4-一些常用命令"><a href="#4-一些常用命令" class="headerlink" title="4. 一些常用命令"></a>4. 一些常用命令</h2><h3 id="创建容器并运行"><a href="#创建容器并运行" class="headerlink" title="创建容器并运行"></a>创建容器并运行</h3><p><strong>语法：</strong>docker run [OPTIONS] IMAGE [COMMAND] [ARG…]</p>
<p>OPTIONS说明：</p>
<ul>
<li><strong>-d：</strong>后台运行容器，并返回容器ID</li>
<li><strong>-i：</strong>以交互模式运行容器，通常与 -t 同时使用</li>
<li><strong>-P：</strong>随机端口映射，容器内部端口<strong>随机</strong>映射到主机的高端口</li>
<li><strong>-p：</strong>指定端口映射，格式为：<strong>主机(宿主)端口:容器端口</strong></li>
<li><strong>-t：</strong>为容器重新分配一个伪输入终端，通常与 -i 同时使用</li>
<li><strong>–name=“XXX”：</strong>为容器指定一个名称</li>
<li><strong>-h：</strong>指定容器的hostname</li>
<li><strong>-e：</strong>设置环境变量</li>
<li><strong>-m：</strong>设置容器使用内存的最大值</li>
<li><strong>–v：</strong>绑定一个卷</li>
</ul>
<p><strong>实例：</strong></p>
<p>使用docker镜像tomcat:latest以后台模式运行一个容器，将容器的8080端口映射到主机8081端口，主机目录/webapps映射到容器的/webapps目录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">docker -d -p 8081:8080/tcp --name mytomcat -v /webapps:/usr/<span class="hljs-built_in">local</span>/tomcat/webapps tomcat:latest<br></code></pre></td></tr></table></figure>

<h3 id="查看运行的容器："><a href="#查看运行的容器：" class="headerlink" title="查看运行的容器："></a>查看运行的容器：</h3><p><strong>语法：</strong>docker ps [OPTIONS]</p>
<p>OPTIONS说明：</p>
<ul>
<li><p><strong>-a：</strong>显示所有的容器，包括未运行的。</p>
</li>
<li><p><strong>-l：</strong>显示最近创建的容器</p>
</li>
<li><p><strong>-n：</strong>列出最近创建的n个容器。例：<code>docker ps -n 5</code></p>
</li>
</ul>
<p><strong>实例：</strong></p>
<p>列出所有容器信息。</p>
<p><img  src="ps-a.png"  ><span class="image-caption">ps-a</span></p>
<p>输出详情介绍：</p>
<p><strong>CONTAINER ID：</strong>容器ID</p>
<p><strong>IMAGE：</strong>使用的镜像</p>
<p><strong>COMMAND：</strong>启动镜像时运行的命令</p>
<p><strong>CREATED：</strong>容器的创建时间</p>
<p><strong>STATUS：</strong>容器状态</p>
<p>状态一共有7种：</p>
<ul>
<li>created (已创建)</li>
<li>restarting (运行中)</li>
<li>running (迁移中)</li>
<li>paused (暂停)</li>
<li>exited (停止)</li>
<li>dead (死亡)</li>
</ul>
<p><strong>PORTS：</strong>容器的端口信息和使用的连接类型(tcp\udp)</p>
<p><strong>NAMES：</strong>容器的名称</p>
<h3 id="查询现有镜像"><a href="#查询现有镜像" class="headerlink" title="查询现有镜像"></a>查询现有镜像</h3><p><strong>语法：</strong>docker search [OPTIONS] TERM</p>
<p>OPTIONS说明：</p>
<ul>
<li><p><strong>–automated：</strong>只列出automated build类型的镜像。</p>
</li>
<li><p><strong>–no-trunc：</strong>显示完整的镜像描述。</p>
</li>
<li><p><strong>-s：</strong>列出收藏数不小于指定值的镜像。</p>
</li>
</ul>
<p><strong>实例：</strong></p>
<p>从Docker Hub查找所有镜像名包含mysql，并且收藏数大于10的镜像。(docker search -s 10 mysql)</p>
<p><img  src="search-s.png"  ><span class="image-caption">search-s</span></p>
<p>具体各个<a href="#search">参数含义</a>，参看上面写的内容。</p>
<h3 id="启动-关闭-重启容器"><a href="#启动-关闭-重启容器" class="headerlink" title="启动/关闭/重启容器"></a>启动/关闭/重启容器</h3><p><strong>语法：</strong></p>
<ul>
<li><p><strong>启动：</strong>docker start [容器名称/容器ID]</p>
</li>
<li><p><strong>关闭：</strong>docker stop [容器名称/容器ID]</p>
</li>
<li><p><strong>重启：</strong>docker restart [容器名称/容器ID]</p>
</li>
</ul>
<blockquote>
<p>容器ID可以只写前四位，docker会自动去寻找，因为ID是随机的，所以前四位重复的就几乎没有。</p>
</blockquote>
<h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><p><strong>语法：</strong>docker rm [OPTIONS] CONTAINER [CONTAINER…]</p>
<p>OPTIONS说明：</p>
<ul>
<li><strong>-f：</strong>通过 SIGKILL 信号强制删除一个运行中的容器。</li>
<li><strong>-l：</strong>移除容器间的网络连接，而非容器本身。</li>
<li><strong>-v：</strong>删除与容器关联的卷。</li>
</ul>
<p><strong>实例：</strong></p>
<p>强制删除容器db01、db02</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">docker rm -f db01 db02<br></code></pre></td></tr></table></figure>

<p>删除所有已经停止的容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">docker rm $(docker ps -a -q)<br></code></pre></td></tr></table></figure>

<h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><p><strong>语法：</strong>docker rmi [OPTIONS] IMAGE [IMAGE…]</p>
<p>OPTIONS说明：</p>
<ul>
<li><strong>-f：</strong>强制删除</li>
<li><strong>-no-prune：</strong>不移除该镜像的过程镜像，默认移除</li>
</ul>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>​        本篇主要讲的就是Docker的初步使用，具体的部署项目阶段和将自己的项目打包成Docker镜像进行运行将在以后进行具体说明。以上的给出的只是部分常用的命令和常用参数，具体更多命令和用法请参考<a href="https://www.runoob.com/docker/docker-command-manual.html">菜鸟教程</a>。(ps：不是打广告，只是觉得整理的比较全)</p>
]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis小知识点</title>
    <url>/2019/09/03/mybatis-knowPoints/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这简单介绍了一下mybatis里的几个小知识点，分别是<code>parameterMap</code>与<code>parameterTyppe</code>、<code>resultMap</code>与<code>resultType</code>的区别，以及在xml文件中获取传递过来的值。同时讲解了一下怎么自定义多参数进行传值等。</p>
<span id="more"></span>
<h1 id="Mybatis小知识点"><a href="#Mybatis小知识点" class="headerlink" title="Mybatis小知识点"></a>Mybatis小知识点</h1><h2 id="1-parameterMap与parameterTyppe详解"><a href="#1-parameterMap与parameterTyppe详解" class="headerlink" title="1. parameterMap与parameterTyppe详解"></a>1. parameterMap与parameterTyppe详解</h2><h3 id="1-1-parameterMap类型"><a href="#1-1-parameterMap类型" class="headerlink" title="1.1 parameterMap类型"></a>1.1 parameterMap类型</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>parameterMap</code>和<code>resuletMap</code>类似，表示将查询结果集中列值的类型一一映射到Java对象属性的类型，在开发过程中不推荐这种方式。</p>
<h3 id="1-2-parameterType类型"><a href="#1-2-parameterType类型" class="headerlink" title="1.2 parameterType类型"></a>1.2 parameterType类型</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>parameterType</code>声明输入参数的类型，将会传入这条语句中的参数类的完全限定名或别名，这个属性是可选的，因为Mybatis可以通过类型处理器<code>(TypeHandler)</code>推断出具体传入语句的参数，默认值为未设置<code>(unset)</code>。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果SQL语句接收的参数是一个JavaBean对象，要在里面写该JavaBean对象的类的全名，即<code>包名.类名</code>，如果再开头mapper中已经配置了<code>namespace</code>别名，那么只要接收参数是这个mapper包下的，就可以直接写文件名。如果接受的是基本类型，那么久可以直接写基本类型，因为基本类型在这里已经自动被扫描了，所以不需要再写包名。如果传参的参数是集合，那么只需要写集合中的对象的类型即可,而不是集合本身。</p>
<h2 id="2-resultMap与resultType详解"><a href="#2-resultMap与resultType详解" class="headerlink" title="2. resultMap与resultType详解"></a>2. resultMap与resultType详解</h2><h3 id="2-1-resultMap类型"><a href="#2-1-resultMap类型" class="headerlink" title="2.1 resultMap类型"></a>2.1 resultMap类型</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;外部<code>resultMap</code>的命名引用。表示将查询结果集中的列一一映射到bean对象的各个属性。映射的查询结果集中的列标签可以根据需要灵活变化，并且，在映射关系中，还可以通过typeHandler设置实现查询结果值的类型转换，比如布尔型与0/1的类型转换。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在外部可以自定义一个<code>resultMap</code>。注入返回值类型 ,自定义结果集映射规则，自定义某个JavaBean的封装规则.如以下代码：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- id：唯一id，方便引用。</span><br><span class="hljs-comment">    type：自定义规则的Java类。 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Orders&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;orders&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- result：定义普通列封装规则 </span><br><span class="hljs-comment">            column：指定数据库中的哪一列列名</span><br><span class="hljs-comment">            property：指定对应的javaBean中的属性名</span><br><span class="hljs-comment">            jdbcType：指定对应数据库中属性的类型</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;User_id&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;userId&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;INTEGER&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;User_name&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;userName&quot;</span>  <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;VARCHAR&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--其他不指定的列会自动封装：我们只要写resultMap，就尽量把所有的列都写上 --&gt;</span><br>    <span class="hljs-comment">&lt;!-- 在写SQL的返回值时在resultMap=&quot;orders&quot;,你想返回哪个自定义的mapper，你就把自定义哪个的id写上。--&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="2-2-resultType类型"><a href="#2-2-resultType类型" class="headerlink" title="2.2 resultType类型"></a>2.2 resultType类型</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用resultType时我们应该注意:sql查询的列名要和resultType指定pojo的属性名相同，指定相同属性方可映射成功，如果sql查询的列名要和resultType指定pojo的属性名全部不相同(或是部分不相同)，则映射到pojo对象中的对应属性为null。例如有时候我们不需要查询<code>select * from user where id = ?</code>而是<code>select username,address _address where id = ?</code> 此时我们给查询的<code>address</code>列名给了一个别名<code>_address</code>，这样我们通过查询表中<code>address</code>的数据然后在将它映射到User对象时，该对象的<code>address</code>属性就为<code>null</code>，即没将从表中查询到的<code>address</code>数据映射到user对象的<code>address</code>属性中。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从这条语句中返回的期望类型的类的完全限定名或别名。 注意如果返回的是集合，那应该设置为集合包含的类型，而不是集合本身。可以使用 <code>resultType</code> 或 <code>resultMap</code>，但不能同时使用。</p>
<h2 id="3-与-详解"><a href="#3-与-详解" class="headerlink" title="3. #{}与${}详解"></a>3. #{}与${}详解</h2><h3 id="3-1-取值"><a href="#3-1-取值" class="headerlink" title="3.1 #{}取值"></a>3.1 #{}取值</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>#&#123;&#125;</code>输入参数的占位符，#将传入的数据都当成一个字符串，会对传入的数据自动加上引号。在取值的时候mybatis会进行预编译。如果入参只有一个值，那么大括号中写什么多无所谓，如果传参有多个，还是写入参属性名写。最好规范一点都按入参属性名写，这样能一眼看出入参是什么。示例(ID=6)如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span>#&#123;ID&#125;<br></code></pre></td></tr></table></figure>
<p>会被先编译成</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span>?<br></code></pre></td></tr></table></figure>
<p>然后再用ID的值(6)去替代<code>?</code>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>\#&#123;&#125;</code>因为有预编译，显得更安全。如果传入参数值中有<code>#</code>使用<code>#&#123;&#125;</code>,*(<code>#</code>在sql中表示注释)*，不会使<code>#</code>后面的sql失效。当入参的name=’hh#’，示例如下：<br>用<code>\#&#123;&#125;</code>:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> name<span class="hljs-operator">=</span>#&#123;name&#125; <span class="hljs-keyword">and</span> id<span class="hljs-operator">=</span>#&#123;ID&#125;<br></code></pre></td></tr></table></figure>
<p>执行的sql为</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;hh#&#x27;</span> <span class="hljs-keyword">and</span> id<span class="hljs-operator">=</span><span class="hljs-number">6</span><br></code></pre></td></tr></table></figure>
<p>用<code>\$&#123;&#125;</code>:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> name<span class="hljs-operator">=</span>$&#123;name&#125; <span class="hljs-keyword">and</span> id<span class="hljs-operator">=</span>$&#123;ID&#125;<br></code></pre></td></tr></table></figure>
<p>执行的sql为</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;hh&#x27;</span> # <span class="hljs-keyword">and</span> id<span class="hljs-operator">=</span><span class="hljs-number">6</span><br></code></pre></td></tr></table></figure>
<p>因为<code>#</code>表示注释，所以执行效果相当于</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;hh&#x27;</span><br></code></pre></td></tr></table></figure>

<p><strong><code>#&#123;&#125;</code>可以指定其他属性</strong><br>        如果name传入参数的值为null，mybatis会默认name值为other类型，但是oracle数据库不能处理other类型，因为会报不能识别的错误。此使就可以用jdbcType属性指定类型。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> name<span class="hljs-operator">=</span>#&#123;name,jdbcType<span class="hljs-operator">=</span><span class="hljs-keyword">null</span>&#125; <span class="hljs-keyword">and</span> id<span class="hljs-operator">=</span>$&#123;ID&#125;<br></code></pre></td></tr></table></figure>
<p>当然也可以在mybatis配置文件中进行配置。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jdbcTypeForNull&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;NULL&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="3-2-取值"><a href="#3-2-取值" class="headerlink" title="3.2 ${}取值"></a>3.2 ${}取值</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>$&#123;&#125;</code>使直接进行编译，将传入的数据直接显示生成在SQL中，使用它可能会导致SQL注入攻击，能用<code>#&#123;&#125;</code>的地方就不用<code>$&#123;&#125;</code>，但是写<code>order by</code>句子的时候一定用<code>$&#123;&#125;</code>。如果入参只有一个值，那么大括号中要写<code>value</code>，如果传参有多个，还是写入参属性名写。示例如下(ID=6)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> id<span class="hljs-operator">=</span>$&#123;ID&#125;<br></code></pre></td></tr></table></figure>
<p>执行的sql为</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> id<span class="hljs-operator">=</span><span class="hljs-number">6</span><br></code></pre></td></tr></table></figure>
<p>用<code>$&#123;&#125;</code>模糊查询时(name=张)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> username <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%$&#123;value&#125;%&#x27;</span> <br></code></pre></td></tr></table></figure>
<p>字符串拼接之后编译成</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> username <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%张%&#x27;</span><br></code></pre></td></tr></table></figure>

<p>jdbc不支持占位符的地方可以用<code>$&#123;&#125;</code>进行取值，比如表名和排序字段：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> $&#123;<span class="hljs-keyword">user</span>&#125; <span class="hljs-keyword">where</span> name<span class="hljs-operator">=</span>#&#123;name&#125; <span class="hljs-keyword">and</span> id<span class="hljs-operator">=</span>#&#123;ID&#125; <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> $&#123;name&#125;<br></code></pre></td></tr></table></figure>

<h2 id="4-sql语句接收多个参数"><a href="#4-sql语句接收多个参数" class="headerlink" title="4. sql语句接收多个参数"></a>4. sql语句接收多个参数</h2><h3 id="4-1-JavaBean方法传值"><a href="#4-1-JavaBean方法传值" class="headerlink" title="4.1 JavaBean方法传值"></a>4.1 JavaBean方法传值</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当要向后台sql语句传入的参数个数是多个时，可以将要传入的参数封装成一个JavaBean，然后将这个JavaBean对象传入到mapper接口，在xml文件的sql语句通过属性名来进行取值。</p>
<h3 id="4-2-Map方法传值"><a href="#4-2-Map方法传值" class="headerlink" title="4.2 Map方法传值"></a>4.2 Map方法传值</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;向后台sql语句传递参数多于一个，又不方便封装成JavaBean是，可以将参数封装成Map集合，以键值对<code>(key-value)</code>的形式存储，然后将该Map集合传入后台xml文件。在xml文件中，执行该语句的接收参数属性设置为<code>parameterType=&quot;Map&quot;</code>，然后在sql中取值的属性名要和map中的键值对的键<code>(key)</code>一致。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Mapper mapper；<br>Map map = <span class="hljs-keyword">new</span> HashMap();<br>map.put(<span class="hljs-string">&quot;id&quot;</span>,<span class="hljs-number">1</span>);<br>map.put(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;张三&quot;</span>);<br><span class="hljs-comment">//调用mapper接口</span><br>mapper.insert(map);<br></code></pre></td></tr></table></figure>
<p>下面是mapper中的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">insert</span><span class="hljs-params">(Map map)</span></span>;<br></code></pre></td></tr></table></figure>
<p>下面是xml中的方法</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insert&quot;</span><span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;Map&quot;</span>&gt;</span><br>    insert into user (id,name) values(#&#123;id&#125;,#&#123;name&#125;)  <br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="4-3-Param方法传值"><a href="#4-3-Param方法传值" class="headerlink" title="4.3 @Param方法传值"></a>4.3 @Param方法传值</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当参数较少时，也可以通过在接口的方法里注解<code>@Prama</code>，可以同时注解多个参数。<br><strong>创建接口方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 根据姓名和性别模糊查询</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Param</span> username 用户姓名</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Param</span> sex 用户性别</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> User对象集合</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">List&lt;User&gt; <span class="hljs-title">select</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;name&quot;)</span>String username,<span class="hljs-meta">@Param(&quot;sex&quot;)</span>String sex)</span></span>;<br></code></pre></td></tr></table></figure>
<p>@Param(“name”)就是告诉mybatis，参数username在SQL语句中用name作为key，也就是说，mybatis帮我们完成了调用时，类似param.put(“name”,username);</p>
<p><strong>配置SQl语句</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;select&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;BaseResultMap&quot;</span>&gt;</span><br>    select * from user where name like &#x27;%$&#123;name&#125;%&#x27; and sex=#&#123;sex&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>此处的<code>#&#123;name&#125;</code>对应的是@Param(“name”)中的name，需要完全一致。</p>
<p><strong>调用</strong><br>最后在调用时只需要按参数提示直接传入对应的实际参数即可。</p>
<h2 id="5-打印SQL语句"><a href="#5-打印SQL语句" class="headerlink" title="5. 打印SQL语句"></a>5. 打印SQL语句</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在项目测试阶段，有时候我们需要查看调用的SQL语句是那一句，可以通过log4j进行输出SQL语句，mybatis只需要配置一下配置文件就行了，在mybatis.xml文件中添加以下两行代码就可以，这样在调用到那句SQL语句的时候就可以对该语句进行输出在控制台，以方便查看。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;logImpl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;STDOUT_LOGGING&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Python程序打包成exe文件</title>
    <url>/2020/02/03/python-packexe/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Python作为现在一门很火的编程语言，无论是不是计算机专业的都有爱好者在学习。我们一般写的Python程序，都是只能在我们自己电脑上进行运行，有时候想分享给小伙伴用一下，但是不是每个小伙伴电脑上都安装有运行Pythonde环境。这个时候我们可以将我们的写好的Python程序打包成exe文件发送给小伙伴，无论对方电脑是有没有Python环境，都可以直接双击运行。下面以Windows环境记录一下打包过程。</p>
<span id="more"></span>

<h1 id="Python程序打包成exe文件"><a href="#Python程序打包成exe文件" class="headerlink" title="Python程序打包成exe文件"></a>Python程序打包成exe文件</h1><h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>PyInstaller</strong> 是一个十分有用的第三方库，可以用来打包 python 应用程序，打包完的程序就可以在没有安装 Python 解释器的机器上运行了。它能够在 Windows、Linux、 Mac OS X 等操作系统下将 Python 源文件打包，通过对源文件打包， Python 程序可以在没有安装 Python 的环境中运行，也可以作为一个 独立文件方便传递和管理。PyInstaller 支持 Python 2.7 / 3.4-3.7。可以在 Windows、Mac OS X 和 Linux 上使用，但是并不是跨平台的，而是说你要是希望打包成 .exe 文件，需要在 Windows 系统上运行 PyInstaller 进行打包工作。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;安装PyInstaller</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">pip install pyintaller<br><span class="hljs-comment"># 或者</span><br>python -m pip install pyinstaller <br></code></pre></td></tr></table></figure>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;安装成功如下。</p>
<p><img  src="%E5%AE%89%E8%A3%85pyinstaller.png"  ><span class="image-caption">安装成功</span></p>
<h2 id="2-打包EXE"><a href="#2-打包EXE" class="headerlink" title="2. 打包EXE"></a>2. 打包EXE</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先进入cmd，进入到你的python文件的目录下,执行命令如下。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">pyinstaller [参数] xxx.py<br></code></pre></td></tr></table></figure>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参数说明</p>
<ul>
<li><strong>-i：</strong>添加一个应用图标，ico文件。(只对Windows系统有效)。</li>
<li><strong>-F：</strong>打包成单独的<code>.exe</code>文件。</li>
<li><strong>-W：</strong>无控制台运行界面。</li>
<li><strong>-D：</strong>创建一个目录，里面包含exe以及其他一下依赖性文件</li>
<li>注：<strong>pyinstaller -h</strong>：查看参数。</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我的是hello.py程序，执行下面操作。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">pyinstaller -F hello.py<br></code></pre></td></tr></table></figure>

<p><img  src="%E6%89%93%E5%8C%85exe.png"  ><span class="image-caption">打包exe</span></p>
<p><strong>PyInstaller</strong>会对脚本进行解析，解析过程如下：</p>
<p>1、在脚本目录生成hello.spec文件；</p>
<p>2、创建一个build目录；</p>
<p>3、写入一个日志文件和中间流程文件到build目录；</p>
<p>4、创建dist目录；</p>
<p>5、生成可执行文件到dist目录。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;执行完成之后就可以在dist目录下找到我们打包好的<code>exe</code>文件，双击就可以直接运行了。</p>
<p><img  src="%E8%BF%90%E8%A1%8C.png"  ><span class="image-caption">运行</span></p>
<h2 id="3-引入外部文件"><a href="#3-引入外部文件" class="headerlink" title="3. 引入外部文件"></a>3. 引入外部文件</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;按照以上步骤打包exe的话，当你的代码中需要调用一些图片和资源文件的，这是不会自动导入的，需要你自己手动复制进去才行。不然 exe 文件运行时命令窗口会报错找不到这个文件。</p>
<p>导入方法：假设<code>hello.py</code>程序中需要引入一个<code>test.txt</code>文件，<code>test.txt</code>文件和<code>hello.py</code>文件位于同一路径下。首先我们运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">pyi-makespec -F hello.py<br></code></pre></td></tr></table></figure>

<p>此时会生成一个<code>.spec</code>，这个文件会告诉pyinstaller如何处理你的脚本，pyinstaller创建一个exe的文件就是依靠它里面的内容进行执行的。正常情况下是不需要修改这个<code>.spec</code>文件的，除非你需要打包一个 dll 或者 so 文件或者其他数据文件。</p>
<p>接下来我们就修改这个<code>.spec</code>文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs spec">a = Analysis([&#x27;hello.py&#x27;],<br>             pathex=[&#x27;G:\\CodeSpace&#x27;],<br>             binaries=[],<br>             datas=[],   ### &lt;------ 修改<br></code></pre></td></tr></table></figure>

<p>修改为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs spec">a = Analysis([&#x27;hello.py&#x27;],<br>             pathex=[&#x27;G:\\CodeSpace&#x27;],<br>             binaries=[],<br>             datas=[(&#x27;test.txt&#x27;,&#x27;.&#x27;),],  ### &lt;-----修改此处添加外部文件<br></code></pre></td></tr></table></figure>

<p>然后再生成<code>exe</code>文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">pyinstaller hello.spec<br></code></pre></td></tr></table></figure>

<p>这样生成的<code>exe</code>文件就可以正常引入外部文件了。</p>
<h2 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4. 注意事项"></a>4. 注意事项</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、直接运行最终的 .exe 程序，可能会出现<strong>一闪而过</strong>的情况，这种情况下要么是程序运行结束（比如直接打印的 helloWorld），要么程序出现错误退出了。这种情况下，建议在命令行 cmd 下运行 .exe 文件，这时就会有文本输出到窗口。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、<code>-i</code> 是改变图标的，图标在不同情况下(比如资源管理器文件列表前面的图标、桌面、开始菜单等)需要不一样尺寸的图标。如果尺寸不合适的话，可能出现有的地方显示正确有的显示不正确的情况。Windows的图标大小尺寸有128*128、64*64、48*48、32*32、16*16，请正确选用。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3、写代码的时候应当有个良好的习惯，用什么函数导什么函数，不要上来 import 整个库，不然最后你会发现你一个 100KB 的代码打包出来有 500MB；</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4、在引入外部文件时，如果需要引入多个文件，<code>.spec</code>文件修改如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs spec">a = Analysis([&#x27;hello.py&#x27;],<br>             pathex=[&#x27;G:\\CodeSpace&#x27;],<br>             binaries=[],<br>             datas=[(&#x27;test_1.txt&#x27;,&#x27;.&#x27;),(&#x27;test_2.txt&#x27;,&#x27;.&#x27;),(&#x27;XXX/test_3.txt,&#x27;.&#x27;),],<br></code></pre></td></tr></table></figure>

<h2 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以上就是使用PyInstaller打包流程进行简单的介绍和使用，更多内容可以参见官方文档：<a href="https://pyinstaller.readthedocs.io/">https://pyinstaller.readthedocs.io</a>。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-@RequestMapping注解</title>
    <url>/2019/09/01/spring-RequestMapping/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@RequestMapping 是 Spring Web 应用程序中最常被用到的注解之一。这个注解会将 HTTP 请求映射到 MVC 和 REST 控制器的处理方法上。</p>
<span id="more"></span>
<h1 id="RequestMapping注解"><a href="#RequestMapping注解" class="headerlink" title="@RequestMapping注解"></a>@RequestMapping注解</h1><h2 id="1-基础用法"><a href="#1-基础用法" class="headerlink" title="1. 基础用法"></a>1. 基础用法</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@RequestMapping是配置web请求的映射，该注解可以在控制器类的级别和/或其中的方法的级别上使用。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在类的级别上的注解会将一个特定请求或者请求模式映射到一个控制器之上。之后还可以另外添加方法级别的注解来进一步值定到处理方法的映射关系。<br>下面是一个同时在类和方法上应用了@RequestMapping注解示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span>  <br><span class="hljs-meta">@RequestMapping(&quot;/home&quot;)</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IndexController</span> </span>&#123;  <br>    <span class="hljs-meta">@RequestMapping(&quot;/&quot;)</span>  <br>    <span class="hljs-function">String <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;  <br>        <span class="hljs-comment">//mapped to hostname:port/home/  </span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello from get&quot;</span>;  <br>    &#125;  <br>    <span class="hljs-meta">@RequestMapping(&quot;/index&quot;)</span>  <br>    <span class="hljs-function">String <span class="hljs-title">index</span><span class="hljs-params">()</span> </span>&#123;  <br>        <span class="hljs-comment">//mapped to hostname:port/home/index/  </span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello from index&quot;</span>;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如上述代码所示，到/home的请求会由get()方法来处理，而到/home/index的请求会有index()方法处理。</p>
<h2 id="2-处理多个URL"><a href="#2-处理多个URL" class="headerlink" title="2. 处理多个URL"></a>2. 处理多个URL</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以将多个请求映射到一个方法上面，只需要添加一个带有请求路径值列表的@RequestMapping注解就行了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span>  <br><span class="hljs-meta">@RequestMapping(&quot;/home&quot;)</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IndexController</span> </span>&#123;  <br>  <br>    <span class="hljs-meta">@RequestMapping(value = &#123;  </span><br><span class="hljs-meta">        &quot;&quot;,  </span><br><span class="hljs-meta">        &quot;/page&quot;,  </span><br><span class="hljs-meta">        &quot;page*&quot;,  </span><br><span class="hljs-meta">        &quot;view/*,**/msg&quot;  </span><br><span class="hljs-meta">    &#125;)</span>  <br>    <span class="hljs-function">String <span class="hljs-title">indexMultipleMapping</span><span class="hljs-params">()</span> </span>&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello from index multiple mapping.&quot;</span>;  <br>    &#125;  <br>&#125;  <br></code></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@RequestMapping支持通配符以及ANT风格的路径。上述示例代码中，以下的的URL都会由indexMultipleMapping()来处理:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">localhost:<span class="hljs-number">8080</span>/home<br><span class="hljs-attr">localhost</span>:<span class="hljs-number">8080</span>/home/<br>localhost:<span class="hljs-number">8080</span>/home/page<br><span class="hljs-attr">localhost</span>:<span class="hljs-number">8080</span>/home/pageabc<br><span class="hljs-attr">localhost</span>:<span class="hljs-number">8080</span>/home/view/<br>localhost:<span class="hljs-number">8080</span>/home/view/view<br></code></pre></td></tr></table></figure>

<h2 id="3-处理动态URI"><a href="#3-处理动态URI" class="headerlink" title="3. 处理动态URI"></a>3. 处理动态URI</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@RequestMapping 注解可以同 @PathVaraible 注解一起使用，用来处理动态的 URI，URI 的值可以作为控制器中处理方法的参数。你也可以使用正则表达式来只处理可以匹配到正则表达式的动态 URI。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span>  <br><span class="hljs-meta">@RequestMapping(&quot;/home&quot;)</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IndexController</span> </span>&#123;  <br>    <span class="hljs-meta">@RequestMapping(value = &quot;/fetch/&#123;id&#125;&quot;, method = RequestMethod.GET)</span>  <br>    <span class="hljs-function">String <span class="hljs-title">getDynamicUriValue</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> String id)</span> </span>&#123;  <br>        System.out.println(<span class="hljs-string">&quot;ID is &quot;</span> + id);  <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Dynamic URI parameter fetched&quot;</span>;  <br>    &#125;  <br>    <span class="hljs-meta">@RequestMapping(value = &quot;/fetch/&#123;id:[a-z]+&#125;/&#123;name&#125;&quot;, method = RequestMethod.GET)</span>  <br>    <span class="hljs-function">String <span class="hljs-title">getDynamicUriValueRegex</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;name&quot;)</span> String name)</span> </span>&#123;  <br>        System.out.println(<span class="hljs-string">&quot;Name is &quot;</span> + name);  <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Dynamic URI parameter fetched using regex&quot;</span>;  <br>    &#125;  <br>&#125; <br></code></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这段代码中，方法 getDynamicUriValue() 会在发起到localhost:8080/home/fetch/10 的请求时执行。这里 getDynamicUriValue() 方法 id 参数也会动态地被填充为 10 这个值。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;方法 getDynamicUriValueRegex() 会在发起到localhost:8080/home/fetch/category/shirt 的请求时执行。不过，如果发起的请求是 /home/fetch/10/shirt 的话，会抛出异常，因为这个URI并不能匹配正则表达式。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@PathVariable 同 @RequestParam的运行方式不同。你使用 @PathVariable 是为了从 URI 里取到查询参数值。换言之，你使用 @RequestParam 是为了从 URI 模板中获取参数值。 </p>
<h2 id="4-带有-RequestParam参数"><a href="#4-带有-RequestParam参数" class="headerlink" title="4. 带有@RequestParam参数"></a>4. 带有@RequestParam参数</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@RequestParam 注解配合 @RequestMapping 一起使用，可以将请求的参数同处理方法的参数绑定在一起。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@RequestParam 注解使用的时候可以有一个值，也可以没有值。这个值指定了需要被映射到处理方法参数的请求参数, 代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span> <br><span class="hljs-meta">@RequestMapping(&quot;/home&quot;)</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IndexController</span> </span>&#123;   <br>    <span class="hljs-meta">@RequestMapping(value = &quot;/id&quot;)</span>  <br>    <span class="hljs-function">String <span class="hljs-title">getIdByValue</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;id&quot;)</span> String personId)</span> </span>&#123;  <br>        System.out.println(<span class="hljs-string">&quot;ID is &quot;</span> + personId);  <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Get ID from query string of URL with value element&quot;</span>;  <br>    &#125;  <br>    <span class="hljs-meta">@RequestMapping(value = &quot;/personId&quot;)</span>  <br>    <span class="hljs-function">String <span class="hljs-title">getId</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> String personId)</span> </span>&#123;  <br>        System.out.println(<span class="hljs-string">&quot;ID is &quot;</span> + personId);  <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Get ID from query string of URL without value element&quot;</span>;  <br>    &#125;  <br>&#125;  <br></code></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在代码的第5行，id这个请求参数被映射到了getIdByValue() 这个处理方法的参数 personId 上。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果请求参数和处理方法参数的名称一样的话，@RequestParam注解的value这个参数就可以省略掉了，如代码的第10行所示。</p>
<p>@RequestParam注解的<strong>required</strong>这个参数定义了参数值是否是必须要传的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span>  <br><span class="hljs-meta">@RequestMapping(&quot;/home&quot;)</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IndexController</span> </span>&#123;  <br>    <span class="hljs-meta">@RequestMapping(value = &quot;/name&quot;)</span>  <br>    <span class="hljs-function">String <span class="hljs-title">getName</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(value = &quot;person&quot;, required = false)</span> String personName)</span> </span>&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Required element of request param&quot;</span>;  <br>    &#125;  <br>&#125;  <br></code></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这段代码中，因为 required 被指定为 false，所以 getName() 处理方法对于如下两个 URL 都会进行处理：</p>
<blockquote>
<p>/home/name/person=xyz<br>/home/name</p>
</blockquote>
<p>@RequestParam的<strong>defaultValue</strong>取值就是用来给取值为空的请求参数提供一个默认值的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span>  <br><span class="hljs-meta">@RequestMapping(&quot;/home&quot;)</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IndexController</span> </span>&#123;  <br>    <span class="hljs-meta">@RequestMapping(value = &quot;/name&quot;)</span>  <br>    <span class="hljs-function">String <span class="hljs-title">getName</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(value = &quot;person&quot;, defaultValue = &quot;John&quot;)</span> String personName)</span> </span>&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Required element of request param&quot;</span>;  <br>    &#125;  <br>&#125;  <br></code></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这段代码中，如果person这个请求参数为空，那么getName()处理方法就会接收”John”这个默认值作为其参数；如果person请求参数不为空，那么方法接收的personName参数就是person。</p>
<h2 id="5-处理请求参数"><a href="#5-处理请求参数" class="headerlink" title="5. 处理请求参数"></a>5. 处理请求参数</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@RequestMapping直径二的params元素可以进一步缩小请求映射的定位范围。使用params元素，可以让多个处理方法处理到同一个URL的请求，而这些请求是不一样的。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以用<code>myParams=myValue</code>这种格式来定义参数，也可以使用通配符来指定特定的参数值在请求中是不是受支持的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span>  <br><span class="hljs-meta">@RequestMapping(&quot;/home&quot;)</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IndexController</span> </span>&#123;  <br>    <span class="hljs-meta">@RequestMapping(value = &quot;/fetch&quot;, params = &#123;  </span><br><span class="hljs-meta">        &quot;personId=10&quot;  </span><br><span class="hljs-meta">    &#125;)</span>  <br>    <span class="hljs-function">String <span class="hljs-title">getParams</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;personId&quot;)</span> String id)</span> </span>&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Fetched parameter using params attribute = &quot;</span> + id;  <br>    &#125;  <br>    <span class="hljs-meta">@RequestMapping(value = &quot;/fetch&quot;, params = &#123;  </span><br><span class="hljs-meta">        &quot;personId=20&quot;  </span><br><span class="hljs-meta">    &#125;)</span>  <br>    <span class="hljs-function">String <span class="hljs-title">getParamsDifferent</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;personId&quot;)</span> String id)</span> </span>&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Fetched parameter using params attribute = &quot;</span> + id;  <br>    &#125;  <br>&#125;  <br></code></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这段代码中，getParams() 和 getParamsDifferent() 两个方法都能处理相同的一个 URL (/home/fetch) ，但是会根据 params 元素的配置不同而决定具体来执行哪一个方法。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，当 URL 是 /home/fetch?id=10 的时候, getParams() 会执行，因为 id 的值是10,。对于 localhost:8080/home/fetch?personId=20 这个URL, getParamsDifferent() 处理方法会得到执行，因为 id 值是 20。 </p>
<h2 id="6-处理HTTP得各种方法"><a href="#6-处理HTTP得各种方法" class="headerlink" title="6. 处理HTTP得各种方法"></a>6. 处理HTTP得各种方法</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spring MVC的@RequestMapping注解能够处理 HTTP 请求的方法, 比如 GET, PUT, POST, DELETE 以及 PATCH。所有的请求默认都会是 HTTP\GET 类型的。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了能将一个请求映射到一个特定的 HTTP 方法，你需要在 @RequestMapping 中使用<strong>method</strong>来声明 HTTP 请求所使用的方法类型，如下所示： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span>  <br><span class="hljs-meta">@RequestMapping(&quot;/home&quot;)</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IndexController</span> </span>&#123;  <br>    <span class="hljs-meta">@RequestMapping(method = RequestMethod.GET)</span>  <br>    <span class="hljs-function">String <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello from get&quot;</span>;  <br>    &#125;  <br>    <span class="hljs-meta">@RequestMapping(method = RequestMethod.DELETE)</span>  <br>    <span class="hljs-function">String <span class="hljs-title">delete</span><span class="hljs-params">()</span> </span>&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello from delete&quot;</span>;  <br>    &#125;  <br>    <span class="hljs-meta">@RequestMapping(method = RequestMethod.POST)</span>  <br>    <span class="hljs-function">String <span class="hljs-title">post</span><span class="hljs-params">()</span> </span>&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello from post&quot;</span>;  <br>    &#125;  <br>    <span class="hljs-meta">@RequestMapping(method = RequestMethod.PUT)</span>  <br>    <span class="hljs-function">String <span class="hljs-title">put</span><span class="hljs-params">()</span> </span>&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello from put&quot;</span>;  <br>    &#125;  <br>    <span class="hljs-meta">@RequestMapping(method = RequestMethod.PATCH)</span>  <br>    <span class="hljs-function">String <span class="hljs-title">patch</span><span class="hljs-params">()</span> </span>&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello from patch&quot;</span>;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面得代码中，@RequestMapping注解中的method元素声明了HTTP请求方法的HTTP请求类型。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所有的请求处理方法都会处理从”/home”这个同一URL进来的请求，但是要看指定的HTTP方法是什么来决定用哪个方法来处理。例如一个POST类型的请求/home会交给post()方法来处理。</p>
<h2 id="7-默认的处理方法"><a href="#7-默认的处理方法" class="headerlink" title="7. 默认的处理方法"></a>7. 默认的处理方法</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在控制器中，你可以有一个默认的处理方法，它可以在有一个向默认URL发起请求时被执行。下面时默认处理方法的示例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span>  <br><span class="hljs-meta">@RequestMapping(&quot;/home&quot;)</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IndexController</span> </span>&#123;  <br>    <span class="hljs-meta">@RequestMapping()</span>  <br>    <span class="hljs-function">String  </span><br><span class="hljs-function">    <span class="hljs-title">default</span> <span class="hljs-params">()</span> </span>&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;This is a default method for the class&quot;</span>;  <br>    &#125;  <br>&#125;  <br></code></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这段代码中，向/home发起的一个请求将会有default()来处理，因为注解没有指向任何值。</p>
<h2 id="8-快捷方式"><a href="#8-快捷方式" class="headerlink" title="8. 快捷方式"></a>8. 快捷方式</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spring 4.3 引入了方法级注解的变体，也被叫做 @RequestMapping 的组合注解。组合注解可以更好的表达被注解方法的语义。它们所扮演的角色就是针对 @RequestMapping 的封装，而且成了定义端点的标准方法。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，@GetMapping 是一个组合注解，它所扮演的是 @RequestMapping(method =RequestMethod.GET) 的一个快捷方式。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;方法级别的注解变体有如下几个：</p>
<ul>
<li>@GetMapping</li>
<li>@PostMapping</li>
<li>@PutMapping</li>
<li>@DeleteMapping</li>
<li>@PatchMapping<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如下代码展示了如何使用组合注解。<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span>  <br><span class="hljs-meta">@RequestMapping(&quot;/home&quot;)</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IndexController</span> </span>&#123;  <br>    <span class="hljs-meta">@GetMapping(&quot;/person&quot;)</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-meta">@ResponseBody</span> ResponseEntity &lt; String &gt; getPerson() &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseEntity &lt; String &gt; (<span class="hljs-string">&quot;Response from GET&quot;</span>, HttpStatus.OK);  <br>    &#125;  <br>    <span class="hljs-meta">@GetMapping(&quot;/person/&#123;id&#125;&quot;)</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-meta">@ResponseBody</span> ResponseEntity &lt; String &gt; getPersonById(<span class="hljs-meta">@PathVariable</span> String id) &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseEntity &lt; String &gt; (<span class="hljs-string">&quot;Response from GET with id &quot;</span> + id, HttpStatus.OK);  <br>    &#125;  <br>    <span class="hljs-meta">@PostMapping(&quot;/person&quot;)</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-meta">@ResponseBody</span> ResponseEntity &lt; String &gt; postPerson() &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseEntity &lt; String &gt; (<span class="hljs-string">&quot;Response from POST method&quot;</span>, HttpStatus.OK);  <br>    &#125;  <br>    <span class="hljs-meta">@PutMapping(&quot;/person&quot;)</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-meta">@ResponseBody</span> ResponseEntity &lt; String &gt; putPerson() &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseEntity &lt; String &gt; (<span class="hljs-string">&quot;Response from PUT method&quot;</span>, HttpStatus.OK);  <br>    &#125;  <br>    <span class="hljs-meta">@DeleteMapping(&quot;/person&quot;)</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-meta">@ResponseBody</span> ResponseEntity &lt; String &gt; deletePerson() &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseEntity &lt; String &gt; (<span class="hljs-string">&quot;Response from DELETE method&quot;</span>, HttpStatus.OK);  <br>    &#125;  <br>    <span class="hljs-meta">@PatchMapping(&quot;/person&quot;)</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-meta">@ResponseBody</span> ResponseEntity &lt; String &gt; patchPerson() &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseEntity &lt; String &gt; (<span class="hljs-string">&quot;Response from PATCH method&quot;</span>, HttpStatus.OK);  <br>    &#125;  <br>&#125;  <br></code></pre></td></tr></table></figure>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这段代码中，每一个处理方法都使用 @RequestMapping 的组合变体进行了注解。尽管每个变体都可以使用带有方法属性的 @RequestMapping 注解来互换实现, 但组合变体仍然是一种最佳的实践 — 这主要是因为组合注解减少了在应用程序上要配置的元数据，并且代码也更易读。 </li>
</ul>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot整合JavaMail发送邮件</title>
    <url>/2022/01/27/SpringBoot-JavaMail/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在SpringBoot项目的开发中，遇到过发送邮件的功能，如果用原始写法的话需要配置大量的东西，现在可以可以直接用SpringBoot整合的JavaMail来做这件事。</p>
<span id="more"></span>

<h1 id="SpringBoot整合JavaMail发送邮件"><a href="#SpringBoot整合JavaMail发送邮件" class="headerlink" title="SpringBoot整合JavaMail发送邮件"></a>SpringBoot整合JavaMail发送邮件</h1><h2 id="1-前提了解"><a href="#1-前提了解" class="headerlink" title="1. 前提了解"></a>1. 前提了解</h2><p>在整合之前呢，需要先简单了解一下相关协议，这里有三个：</p>
<ul>
<li><p>SMTP（Simple Mail Transfer Protocol）：简单邮件传输协议，用于<strong>发送</strong>电子邮件的传输协议。</p>
</li>
<li><p>POP3（Post Office Protocol 3）：用于<strong>接收</strong>电子邮件的标准协议。</p>
</li>
<li><p>IMAP（Internet Mail Access Protocol）：互联网消息协议，是POP3的替代协议。</p>
</li>
</ul>
<p>对于我们开发而言，一般用的最多的就是发送邮件。</p>
<h2 id="2-导入相关坐标"><a href="#2-导入相关坐标" class="headerlink" title="2. 导入相关坐标"></a>2. 导入相关坐标</h2><p>因为SpringBoot已经整合了JavaMail，所以这里版本号可以省略不写，使用SpringBoot默认的就行。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-mail<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h2 id="3-配置文件"><a href="#3-配置文件" class="headerlink" title="3. 配置文件"></a>3. 配置文件</h2><p>在<code>application.properties</code>或者<code>application.yml</code>中配置相关信息，这里用的是<code>application.yml</code>文件格式。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">mail:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-string">smtp.163.com</span>			<span class="hljs-comment"># 邮箱服务器</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">test@163.com</span>		<span class="hljs-comment"># 用户名					</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">s4ty34fg75nu985</span>	<span class="hljs-comment"># 邮箱的授权码，而不是邮箱密码</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>邮箱的授权码获取方式见文章末尾的<a href="#fulu">附录</a>。</p>
</blockquote>
<h2 id="4-编写代码"><a href="#4-编写代码" class="headerlink" title="4. 编写代码"></a>4. 编写代码</h2><h3 id="4-1-发送简单邮件"><a href="#4-1-发送简单邮件" class="headerlink" title="4.1 发送简单邮件"></a>4.1 发送简单邮件</h3><p>编写测试方法，首先通过注解注入<code>JavaMailSender</code>对象，然后就可以通过该类进行邮件发送的操作。代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 注入实体类</span><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> JavaMailSender mailSender;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 发送简单邮件</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> from 发送者  xxx@163.com</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> to 接收者    xxx@163.com</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> subject 邮件标题</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> context 邮件正文</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendSimpleMail</span><span class="hljs-params">(String from, String to, String subject, String context)</span></span>&#123;<br>    SimpleMailMessage message = <span class="hljs-keyword">new</span> SimpleMailMessage();<br>    <span class="hljs-comment">// 设置发送者</span><br>    message.setFrom(from);<br>    <span class="hljs-comment">// 下面这种发送方式，就是在邮箱后面通过括号加一个昵称，在邮件列表中可以显示收件人为昵称，而不是直接显示邮箱</span><br>    <span class="hljs-comment">// message.setFrom(from + &quot;(byfan)&quot;);</span><br><br>    <span class="hljs-comment">// 设置接收者</span><br>    message.setTo(to);<br>    <span class="hljs-comment">// 设置标题</span><br>    message.setSubject(subject);<br>    <span class="hljs-comment">// 设置正文</span><br>    message.setText(context);<br>    <span class="hljs-comment">// 设置发送时间，可用于定时发送</span><br>    <span class="hljs-comment">// message.setSentDate(new Date());</span><br><br>    <span class="hljs-comment">// 发送邮件</span><br>    mailSender.send(message);<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="4-2-发送多部件邮件"><a href="#4-2-发送多部件邮件" class="headerlink" title="4.2 发送多部件邮件"></a>4.2 发送多部件邮件</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 注入实体类</span><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> JavaMailSender mailSender;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 发送简单邮件</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> from 发送者  xxx@163.com</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> to 接收者    xxx@163.com</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> subject 邮件标题</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> context 邮件正文 eg:&lt;a href=&#x27;https://byfan.xyz&#x27;&gt;点击进入byFan驿站&lt;/a&gt;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> isHtml 是否解析正文为html</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> files 附件列表</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMimeMail</span><span class="hljs-params">(String from, String to, String subject, String context, <span class="hljs-keyword">boolean</span> isHtml, File[] files)</span></span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 定义是否有附件的标识</span><br>        <span class="hljs-keyword">boolean</span> isFile = <span class="hljs-keyword">false</span>;<br>        MimeMessage message = mailSender.createMimeMessage();<br>        <span class="hljs-keyword">if</span> (files.length &gt; <span class="hljs-number">0</span>)&#123;<br>            isFile = <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-comment">// 第二个参数可不传，默认是false不带附件</span><br>        MimeMessageHelper helper = <span class="hljs-keyword">new</span> MimeMessageHelper(message,isFile);<br>        <span class="hljs-comment">// 设置发送者</span><br>        helper.setFrom(from);<br>        <span class="hljs-comment">// 下面这种发送方式，就是在邮箱后面通过括号加一个昵称，在邮件列表中可以显示收件人为昵称，而不是直接显示邮箱</span><br>        <span class="hljs-comment">// message.setFrom(from + &quot;(byfan)&quot;);</span><br><br>        <span class="hljs-comment">// 设置接收者</span><br>        helper.setTo(to);<br>        <span class="hljs-comment">// 设置标题</span><br>        helper.setSubject(subject);<br>        <span class="hljs-comment">// 设置正文,第二个参数可不传，默认是false不解析html</span><br>        helper.setText(context,isHtml);<br><br>        <span class="hljs-comment">// 添加附件</span><br>        <span class="hljs-keyword">if</span> (isFile)&#123;<br>            <span class="hljs-keyword">for</span> (File file : files)&#123;<br>                <span class="hljs-comment">// 第一个参数：附件文件名，可自定义；第二个参数：附件文件</span><br>                helper.addAttachment(file.getName(), file);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 设置发送时间，可用于定时发送</span><br>        <span class="hljs-comment">// message.setSentDate(new Date());</span><br><br>        <span class="hljs-comment">// 发送邮件</span><br>        mailSender.send(message);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><span id="fulu"></span></p>
<h2 id="附录：获取邮箱授权码"><a href="#附录：获取邮箱授权码" class="headerlink" title="附录：获取邮箱授权码"></a>附录：获取邮箱授权码</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;获取邮箱授权码这里也以163邮箱为例，其他邮箱获取授权码的步骤也都差不都，可做参考。首先登录到163邮箱网页版。在上面导航栏中找到设置，点击<strong>设置</strong>，然后点击<strong>POP3/SMTP/IMAP</strong>。进入到操作页面之后，在<strong>开启服务</strong>项里面，点击<strong>IMAP/SMTP</strong>后面的<strong>开启</strong>，弹窗提示需要发送短信进行验证，按照提示发送完成之后，点击<strong>我已发送</strong>，则会弹窗显示当前授权码，<strong>该授权码只显示一次，记得保存备份。</strong></p>
<p><img src="image-20220127173751861.png"></p>
<p><img src="image-20220127174246154.png"></p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot项目部署到服务器</title>
    <url>/2019/12/23/springboot-deploy-server/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在之前的博客当中，写了一些关于SpringBoot的使用，今天主要写的就是怎么样将自己写的SpringBoot项目部署到云服务器上。只有将项目部署到了服务器上，项目才能一直运行，并且只要在有互联网就能随时随地的的访问项目。</p>
<h1 id="SpringBoot项目部署到服务器"><a href="#SpringBoot项目部署到服务器" class="headerlink" title="SpringBoot项目部署到服务器"></a>SpringBoot项目部署到服务器</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在部署之前呢，先要再简单了解一下SpringBoot项目的运行。因为SpringBoot框架默认自带了一个嵌入式的Tomcat服务器，所以可以通过自带的服务器以jar包的方法运行，也可以将SpringBoot项目打包成一个war包，部署到服务器的Tomcat上运行。以下是对两种运行方式部署到服务器上进行详解，需要注意的时，这个项目时一个maven项目。</p>
<h2 id="1-使用War包部署"><a href="#1-使用War包部署" class="headerlink" title="1 使用War包部署"></a>1 使用War包部署</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 使用war包部署，就只需要将项目打包，部署到服务器Tomcat下即可运行，不过在打包之前，需要对项目做一些简单的修改，步骤如下。</p>
<h3 id="1-1-修改pom-xml文件"><a href="#1-1-修改pom-xml文件" class="headerlink" title="1.1 修改pom.xml文件"></a>1.1 修改pom.xml文件</h3><p>打开项目的pom.xml配置文件，SpringBoot默认的打包方式是jar包，将打包方式设置为war。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>war<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="1-2-修改启动类"><a href="#1-2-修改启动类" class="headerlink" title="1.2 修改启动类"></a>1.2 修改启动类</h3><p>对于启动类，需要重写初始化方法：继承SpringBootServletInitializer，重写configure函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FilmManageApplication</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SpringBootServletInitializer</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> SpringApplicationBuilder <span class="hljs-title">configure</span><span class="hljs-params">(SpringApplicationBuilder builder)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.configure(builder);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(FilmManageApplication.class, args);<br>    &#125;<br>&#125;  <br></code></pre></td></tr></table></figure>

<h3 id="1-3-去除自带的Tomcat"><a href="#1-3-去除自带的Tomcat" class="headerlink" title="1.3 去除自带的Tomcat"></a>1.3 去除自带的Tomcat</h3><p>方法：需要将嵌入的Tomcat依赖方式改成provide(编译、测试时将依赖的包加入本工程的classpath，运行时不加入。可以理解成运行时不适使用SpringBoot自带的Tomcat)。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="1-4-加入servlet-api依赖"><a href="#1-4-加入servlet-api依赖" class="headerlink" title="1.4 加入servlet-api依赖"></a>1.4 加入servlet-api依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="1-5-打包"><a href="#1-5-打包" class="headerlink" title="1.5 打包"></a>1.5 打包</h3><p>点击IDEA右侧的Maven，双击package打包，注意打包时跳过测试，再target目录下生成war包文件。</p>
<p><img  src="%E6%89%93%E5%8C%85war.png"  ><span class="image-caption">打包war</span></p>
<h3 id="1-6-部署"><a href="#1-6-部署" class="headerlink" title="1.6 部署"></a>1.6 部署</h3><p>将打包好的war包文件放到云服务器<strong>Tomcat的webapps目录</strong>下，启动Tomcat(在bin目录下执行./startup.sh)，即可自动解压部署。</p>
<h3 id="1-7-测试"><a href="#1-7-测试" class="headerlink" title="1.7 测试"></a>1.7 测试</h3><p>项目部署好之后，打开浏览器输入服务器地址:端口号/项目jar包名/主页。</p>
<p><img  src="%E6%B5%8B%E8%AF%95war.png"  ><span class="image-caption">测试</span></p>
<h3 id="1-8-说明"><a href="#1-8-说明" class="headerlink" title="1.8 说明"></a>1.8 说明</h3><ol>
<li><p>由于war包部署不使用SpringBoot自带的Tomcat，所以application.yml文件下的server配置将不会再起作用，故服务器默认Tomcat端口号时<strong>8080</strong>。想要修改端口号可以到Tomcat下的<strong>server.xml</strong>文件进行修改。路径输入的是项目war包的名称。</p>
</li>
<li><p>默认情况下，项目路径是war包或jar包的名称，如果想要修改的话，可以再Tomcat里的<strong>server.xml</strong>文件中加上</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Context</span> <span class="hljs-attr">docBase</span>=<span class="hljs-string">&quot;MyProject.war&quot;</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/demo&quot;</span> <span class="hljs-attr">reloadable</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">debug</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">privileged</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>输入地址时就可以直接用demo代替MyProject。</p>
</li>
<li><p>注意：如果在server.xml中加了以上语句的话，那么需要特别注意的就是，该项目的war包不能被删除，否则Tomcat将无法启动。</p>
</li>
</ol>
<h2 id="2-使用Jar包部署"><a href="#2-使用Jar包部署" class="headerlink" title="2 使用Jar包部署"></a>2 使用Jar包部署</h2><h3 id="2-1-打包"><a href="#2-1-打包" class="headerlink" title="2.1 打包"></a>2.1 打包</h3><p>​        首先，如果没有在pom.xml文件中修改默认的package的话，默认的就是以jar方式打包。然后点击IDEA右侧的Maven，跳过测试，package打包。</p>
<p><img  src="%E6%89%93%E5%8C%85jar.png"  ><span class="image-caption">打包jar</span></p>
<h3 id="2-2-部署"><a href="#2-2-部署" class="headerlink" title="2.2 部署"></a>2.2 部署</h3><p>​        之后在target目录下找到打包之后的jar文件，然后通过工具上传至云服务器。</p>
<h3 id="2-3-运行"><a href="#2-3-运行" class="headerlink" title="2.3 运行"></a>2.3 运行</h3><p>​        如果服务器是windows server桌面版的，将jar包上传之后，可以直接双击jar包运行，不过关闭时需要到任务管理器关闭改任务。</p>
<p>​         如果是Linux版本的服务器，那么上传之后，在jar包所在的目录下，输入命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">java -jar XXX.jar<br></code></pre></td></tr></table></figure>

<p>​        如果想指定运行端口也可以，输入以下命令。不过个人觉得没有必要，因为已经在配置文件里指定项目端口了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">java -jar XXX.jar --server.port=8088<br></code></pre></td></tr></table></figure>

<p>​        输入命令回车，就会出现如图所示，程序已经启动。</p>
<p><img  src="%E8%BF%90%E8%A1%8Cjar.png"  ><span class="image-caption">运行jar</span></p>
<h3 id="2-4-测试"><a href="#2-4-测试" class="headerlink" title="2.4 测试"></a>2.4 测试</h3><p>​        之后在浏览器中输入服务器地址:在application.yml中设置的端口号/jar包名称/主页。</p>
<p><img  src="%E6%B5%8B%E8%AF%95jar.png"  ><span class="image-caption">测试jar</span></p>
<h3 id="2-5-说明"><a href="#2-5-说明" class="headerlink" title="2.5 说明"></a>2.5 说明</h3><p>​        利用上面所说的方式，关闭远程端口程序就会自动退出，如果需要后台运行，可以使用下列命令进行部署。</p>
<p><strong>&lt;1&gt;首次部署</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">nohup java -jar XXX.jar &gt;temp.text &amp;<br>//退出 ctrl+c<br></code></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li>nohup：当账户退出或者终端关闭时，程序仍然运行。</li>
<li>&amp;：客户端关闭，后台停止运行。</li>
<li>temp.text 是存控制台文件。缺省情况下该作业的所有的输出内容被重定向到nohup.out的文件中。</li>
<li>使用tail -f temp.text实时查看控制台文件。ctrl+z返回命令行。</li>
</ul>
<p>可通过<code>jobs</code>命令列出所有后台运行任务，并且每个作业前面都有编号，如果想将某个作业调回前台控制，只需要<code>fg + 编号</code>即可。</p>
<p><strong>&lt;2&gt;非首次部署</strong></p>
<p>非首次部署当前程序需要在对应的文件夹中执行以下命令：</p>
<p>a.捕获上一个版本程序的进程 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ps -ef|grep XXX.jar<br></code></pre></td></tr></table></figure>

<p>b.杀死对应的进程</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">kill 进程号<br></code></pre></td></tr></table></figure>

<p>c.启动程序</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">nohup java -jar XXX.jar &gt;temp.text &amp;<br></code></pre></td></tr></table></figure>

<p>d.退出</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ctrl + c<br></code></pre></td></tr></table></figure>

<p>e.查看日志</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">tail -500f temp.text<br></code></pre></td></tr></table></figure>

<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以上就是将SpringBoot项目部署到云服务器的全部过程，简单总结就是jar包部署方式使用SpringBoot自带的Tomcta，所以可以直接在服务器运行jar文件。war包部署方式则使用云服务器里的Tomcat，此时需要将SpringBoot自带的Tomcat移除，并在打包时对项目进行一点小的修改。同时要注意的就是两种部署方式的访问路径的差异，就是端口的不同，一个使用application.yml里配置的端口，一个使用Tomcat默认的端口号。</p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring定时任务-@Scheduled注解</title>
    <url>/2019/09/02/spring-Scheduled/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有时候项目中需要用到定时任务，在某个时间点执行特定的任务，这时我们就可以使用spring中的定时任务——**@Scheduled注解**。下面就简单介绍一下<code>@Scheduledd</code>注解的使用。在springMVC项目中使用spring的定时任务步骤如下。</p>
<span id="more"></span>
<h1 id="Scheduled注解详解"><a href="#Scheduled注解详解" class="headerlink" title="@Scheduled注解详解"></a>@Scheduled注解详解</h1><h2 id="1-配置springMVC-xml文件"><a href="#1-配置springMVC-xml文件" class="headerlink" title="1. 配置springMVC.xml文件"></a>1. 配置springMVC.xml文件</h2><p>加入tesk的命名空间:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs xmls">xmlns:task = &quot;http://www.springframework.org/schema/task&quot;<br></code></pre></td></tr></table></figure>

<p>在xsi:schemaLocation中添加以下依赖:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">http:<span class="hljs-comment">//www.springframework.org/schema/task</span><br>http:<span class="hljs-comment">//www.springframework.org/schema/task/spring-task-4.0.xsd&quot;</span><br></code></pre></td></tr></table></figure>

<h2 id="2-配置定时任务的线程池"><a href="#2-配置定时任务的线程池" class="headerlink" title="2. 配置定时任务的线程池"></a>2. 配置定时任务的线程池</h2><p>推荐配置线程池，若不配置，多任务下会有问题。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">task:scheduler</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myScheduler&quot;</span> <span class="hljs-attr">pool-size</span>=<span class="hljs-string">&quot;5&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>id是该线程池的唯一标识，用于启动该线程池的注解驱动。poo-size是线程池的容量。</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;spring的定时任务默认是单线程，多个任务执行起来时间会有问题。在下面定时任务的示例代码中，A任务中设置的有<code>TimeUnit.SECONDS.sleep(20);</code>那么如存在B任务，B任务会因为A任务执行起来需要20s二被延后20s执行。当我们配置了线程池之后，多线程下B任务就不会因为A任务执行起来要20s而别延后执行了。</p>
<h2 id="3-启动注解驱动的定时任务"><a href="#3-启动注解驱动的定时任务" class="headerlink" title="3. 启动注解驱动的定时任务"></a>3. 启动注解驱动的定时任务</h2><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">task:annotation-driven</span> <span class="hljs-attr">scheduler</span>=<span class="hljs-string">&quot;myScheduler&quot;</span>/&gt;</span> <br></code></pre></td></tr></table></figure>
<blockquote>
<p>scheduler指的是我们配置线程池的id名称，如果没有配置线程池，那么该元素可以不写。</p>
</blockquote>
<h2 id="4-配置扫描包"><a href="#4-配置扫描包" class="headerlink" title="4. 配置扫描包"></a>4. 配置扫描包</h2><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;test&quot;</span>/&gt;</span>--&gt;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>base-package元素是配置定时任务所在的包名。</p>
</blockquote>
<h2 id="5-编写定时任务"><a href="#5-编写定时任务" class="headerlink" title="5. 编写定时任务"></a>5. 编写定时任务</h2><p><code>@Scheduled</code>注解为定时任务，<code>cron</code>表达式里写执行的时机。以下代码是示例代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> test;<br><span class="hljs-keyword">import</span> java.text.DateFormat;<br><span class="hljs-keyword">import</span> java.text.SimpleDateFormat;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><span class="hljs-keyword">import</span> org.joda.time.DateTime;<br><span class="hljs-keyword">import</span> org.springframework.scheduling.annotation.Scheduled;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ATask</span></span>&#123;<br>       <span class="hljs-meta">@Scheduled(cron=&quot;0/10 * *  * * ? &quot;)</span>   <span class="hljs-comment">//每10秒执行一次  </span><br>       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">aTask</span><span class="hljs-params">()</span></span>&#123; <br>            <span class="hljs-keyword">try</span> &#123;<br>                    TimeUnit.SECONDS.sleep(<span class="hljs-number">20</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            DateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);  <br>            System.out.println(sdf.format(DateTime.now().toDate())+<span class="hljs-string">&quot;*********A任务每10秒执行一次进入测试&quot;</span>);    <br>       &#125;    <br>&#125;  <br></code></pre></td></tr></table></figure>
<blockquote>
<p>@Component泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。    </p>
</blockquote>
<blockquote>
<p>有时候启动web项目发现随着服务器启动的定时任务没有执行，这是因为xml的头文件<code>&lt;beans&gt;</code>里面的一个配置default-lazy-init=”true”。此处配置为懒加载，所以所有的bean都是懒加载，导致定时任务所在的bean根本没有实例化，里面的定时任务也没有执行，修改为default-lazy-init=”false”即可。 </p>
</blockquote>
<h2 id="6-Scheduled注解各参数详解"><a href="#6-Scheduled注解各参数详解" class="headerlink" title="6. @Scheduled注解各参数详解"></a>6. @Scheduled注解各参数详解</h2><h3 id="6-1-cron表达式详解"><a href="#6-1-cron表达式详解" class="headerlink" title="6.1 cron表达式详解"></a>6.1 cron表达式详解</h3><p>该参数接收一个<code>cron表达式</code>，<code>cron表达式</code>是一个字符串，字符串以5个或6个空格隔开，分开共6个或7个域，每个域代表一个含义</p>
<h4 id="6-1-1-cron表达式语法"><a href="#6-1-1-cron表达式语法" class="headerlink" title="6.1.1 cron表达式语法"></a>6.1.1 cron表达式语法</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">[秒] [分] [时] [日] [月] [周] [年]<br></code></pre></td></tr></table></figure>
<blockquote>
<p>注：[年]不是必须的域，可以省略年，则一共6个域。</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">序号</th>
<th align="center">说明</th>
<th align="center">必填</th>
<th align="center">允许填写的值</th>
<th align="center">允许的通配符</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">秒</td>
<td align="center">是</td>
<td align="center">0-59</td>
<td align="center">, - * /</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">分</td>
<td align="center">是</td>
<td align="center">0-59</td>
<td align="center">, - * /</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">时</td>
<td align="center">是</td>
<td align="center">0-23</td>
<td align="center">, - * /</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">日</td>
<td align="center">是</td>
<td align="center">1-31</td>
<td align="center">, - * / L W</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">月</td>
<td align="center">是</td>
<td align="center">1-12/JAN-DEC</td>
<td align="center">, - * /</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">周</td>
<td align="center">是</td>
<td align="center">1-7/SUN-SAT</td>
<td align="center">, - * / L #</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">年</td>
<td align="center">否</td>
<td align="center">1970-2099</td>
<td align="center">, - * /</td>
</tr>
</tbody></table>
<h4 id="6-1-2-通配符说明"><a href="#6-1-2-通配符说明" class="headerlink" title="6.1.2 通配符说明"></a>6.1.2 通配符说明</h4><ul>
<li><code>*</code> 表示所有值。 例如:在分的字段上设置 *,表示每一分钟都会触发。</li>
<li><code>?</code> 表示不指定值。使用的场景为不需要关心当前设置这个字段的值。例如:要在每月的10号触发一个操作，但不关心是周几，所以需要周位置的那个字段设置为”?” 具体设置为 0 0 0 10 * ?</li>
<li><code>-</code> 表示区间。例如 在小时上设置 “10-12”,表示 10,11,12点都会触发。</li>
<li><code>,</code> 表示指定多个值，例如在周字段上设置 “MON,WED,FRI” 表示周一，周三和周五触发</li>
<li><code>/</code> 用于递增触发。如在秒上面设置”5/15” 表示从5秒开始，每增15秒触发(5,20,35,50)。 在月字段上设置’1/3’所示每月1号开始，每隔三天触发一次。</li>
<li><code>L</code> 表示最后的意思。在日字段设置上，表示当月的最后一天(依据当前月份，如果是二月还会依据是否是润年[leap]), 在周字段上表示星期六，相当于“7”或“SAT”。如果在“L”前加上数字，则表示该数据的最后一个。例如在周字段上设置“6L”这样的格式,则表示“本月最后一个星期五”</li>
<li><code>W</code> 表示离指定日期的最近那个工作日(周一至周五). 例如在日字段上置“15W”，表示离每月15号最近的那个工作日触发。如果15号正好是周六，则找最近的周五(14号)触发, 如果15号是周未，则找最近的下周一(16号)触发.如果15号正好在工作日(周一至周五)，则就在该天触发。如果指定格式为 “1W”,它则表示每月1号往后最近的工作日触发。如果1号正是周六，则将在3号下周一触发。(注，“W”前只能设置具体的数字,不允许区间“-”)。</li>
<li><code>#</code> 序号(表示每月的第几个周几)，例如在周字段上设置“6#3”表示在每月的第三个周六.注意如果指定“#5”,正好第五周没有周六，则不会触发该配置(用在母亲节和父亲节再合适不过了) ；小提示：‘L’和 ‘W’可以一组合使用。如果在日字段上设置“LW”,则表示在本月的最后一个工作日触发；周字段的设置，若使用英文字母是不区分大小写的，即MON与mon相同。</li>
</ul>
<p><strong>示例:</strong></p>
<ul>
<li><p>每隔5秒执行一次：*/5 * * * * ?</p>
</li>
<li><p>每隔1分钟执行一次：0 */1 * * * ?</p>
</li>
<li><p>每天23点执行一次：0 0 23 * * ?</p>
</li>
<li><p>每天凌晨1点执行一次：0 0 1 * * ?</p>
</li>
<li><p>每月1号凌晨1点执行一次：0 0 1 1 * ?</p>
</li>
<li><p>每月最后一天23点执行一次：0 0 23 L * ?</p>
</li>
<li><p>每周星期天凌晨1点实行一次：0 0 1 ? * L</p>
</li>
<li><p>在26分、29分、33分执行一次：0 26,29,33 * * * ?</p>
</li>
<li><p>每天的0点、13点、18点、21点都执行一次：0 0 0,13,18,21 * * ?</p>
</li>
</ul>
<h3 id="6-2-zone"><a href="#6-2-zone" class="headerlink" title="6.2 zone"></a>6.2 zone</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;时区。接收一个<code>java.util.TimeZone#ID</code>。<code>cron表达式</code>会基于该时区解析。默认是一个空字符串，即取服务器所在地的时区。比如我们一般使用的时区<code>Asia/Shanghai</code>。该字段我们一般留空。</p>
<h3 id="6-3-fixedDelay"><a href="#6-3-fixedDelay" class="headerlink" title="6.3 fixedDelay"></a>6.3 fixedDelay</h3><p>上一次执行完毕时间点之后多长时间再执行。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Scheduled(fixedDelay = 5000)</span> <span class="hljs-comment">//上一次执行完毕时间点之后5秒再执行</span><br></code></pre></td></tr></table></figure>

<h3 id="6-4-fixedDelayString"><a href="#6-4-fixedDelayString" class="headerlink" title="6.4 fixedDelayString"></a>6.4 fixedDelayString</h3><p>与<code>fixedDelay</code>意思相同，只是使用字符串的形式。唯一不同的是支持占位符。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Scheduled(fixedDelayString = &quot;5000&quot;)</span> <span class="hljs-comment">//上一次执行完毕时间点之后5秒再执行</span><br></code></pre></td></tr></table></figure>
<p>占位符的使用(配置文件中有配置：time.fixedDelay=5000)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Scheduled(fixedDelayString = &quot;$&#123;time.fixedDelay&#125;&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testFixedDelayString</span><span class="hljs-params">()</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;Execute at &quot;</span> + System.currentTimeMillis());<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="6-5-fixedRate"><a href="#6-5-fixedRate" class="headerlink" title="6.5 fixedRate"></a>6.5 fixedRate</h3><p>上一次开始执行时间点之后多长时间再执行。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Scheduled(fixedRate = 5000)</span> <span class="hljs-comment">//上一次开始执行时间点之后5秒再执行</span><br></code></pre></td></tr></table></figure>

<h3 id="6-6-fixedRateString"><a href="#6-6-fixedRateString" class="headerlink" title="6.6 fixedRateString"></a>6.6 fixedRateString</h3><p>与<code>fixedRate</code>意思相同，只是使用字符串的形式。唯一不同的是支持占位符。</p>
<h3 id="6-7-initialDelay"><a href="#6-7-initialDelay" class="headerlink" title="6.7 initialDelay"></a>6.7 initialDelay</h3><p>第一次延迟多长时间后再执行。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Scheduled(initialDelay=1000, fixedRate=5000)</span> <span class="hljs-comment">//第一次延迟1秒后执行，之后按fixedRate的规则每5秒执行一次</span><br></code></pre></td></tr></table></figure>

<h3 id="6-8-initialDelayString"><a href="#6-8-initialDelayString" class="headerlink" title="6.8 initialDelayString"></a>6.8 initialDelayString</h3><p>与<code>initialDelay</code>意思相同，只是使用字符串的形式。唯一不同的是支持占位符。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Syncthing-P2P文件同步工具的使用</title>
    <url>/2022/01/28/Syncthing-P2P/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;随着数据的增长，我们对于文件的同步和备份需求也日趋强烈。各种网盘为我们在文件同步备份提供便利的同时，也在速度、安全和隐私等方面带来不小的限制和风险。今天给大家介绍一款新的文件同步工具—Synchting。</p>
<span id="more"></span>

<h1 id="Syncthing-P2P文件同步工具的使用"><a href="#Syncthing-P2P文件同步工具的使用" class="headerlink" title="Syncthing-P2P文件同步工具的使用"></a>Syncthing-P2P文件同步工具的使用</h1><h2 id="1-Syncthing简介"><a href="#1-Syncthing简介" class="headerlink" title="1. Syncthing简介"></a>1. Syncthing简介</h2><p><a href="https://syncthing.net/">Syncthing</a>是一款开源免费跨平台的文件同步工具，是基于<strong>P2P技术</strong>实现设备间的文件同步，所以它的同步是<strong>去中心化</strong>的，即你并不需要一个服务器，故不需要担心这个中心的服务器给你带来的种种限制，而且类似于torrent协议，参与同步的设备越多，同步的速度越快。针对<strong>隐私</strong>问题，Syncthing软件只会将数据存储于个人信任的设备上，不会存储到服务器上。设备之间的通信均通过TLS进行，Syncthing还使用了完全正向保密技术来进一步保障你的数据安全。对于处于<strong>不同局域网之中</strong>的设备之间的文件同步，Syncthing也提供了支持。</p>
<p>Syncthing支持非常多的平台，包括<strong>Windwos、macOS、Android、Linux、FreeBSD、Solaris、群晖和威联通NAS</strong>等，但遗憾的是，在iOS上只有一个第三方客户端fsync。</p>
<h2 id="2-基本使用"><a href="#2-基本使用" class="headerlink" title="2. 基本使用"></a>2. 基本使用</h2><h3 id="2-1-安装Syncthing"><a href="#2-1-安装Syncthing" class="headerlink" title="2.1 安装Syncthing"></a>2.1 安装Syncthing</h3><h4 id="2-1-1-Windows安装"><a href="#2-1-1-Windows安装" class="headerlink" title="2.1.1 Windows安装"></a>2.1.1 Windows安装</h4><ol>
<li><strong>有界面安装</strong></li>
</ol>
<p>进入<a href="https://syncthing.net/downloads/">官网下载地址</a>找到Windows版本的，这个是带图像用户界面的并且可以最小化到托盘后台运行。点击进去，下载<code>.exe</code>文件，下载完成之后双击运行即可。</p>
<img  src="Syncthing-P2P文件同步工具的使用/image-20220128174851498.png"   style="zoom:50%;" /><span class="image-caption">image-20220128174851498</span>

<ol start="2">
<li><strong>无界面安装</strong></li>
</ol>
<p>在下载页下拉，找到下面这个Windows版本，这个是没有图形用户界面的。下载下来是一个压缩包，解压出来之后，打开这个文件夹，双击文件夹里<code>syncthing.exe</code>就能启动，启动时会打开一个终端，这个终端不能关闭，关闭之后服务器就关闭了。启动成功之后会自动打开浏览器到用户界面。</p>
<p><img  src="Syncthing-P2P%E6%96%87%E4%BB%B6%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/image-20220128175322867.png"  ><span class="image-caption">image-20220128175322867</span></p>
<h4 id="2-1-2-Mac安装"><a href="#2-1-2-Mac安装" class="headerlink" title="2.1.2 Mac安装"></a>2.1.2 Mac安装</h4><p>进入<a href="https://syncthing.net/downloads/">官网下载地址</a>找到MacOS版本的，点击进去，下载<code>.dmg</code>格式。</p>
<p><img  src="Syncthing-P2P%E6%96%87%E4%BB%B6%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/image-20220128174246325.png"  ><span class="image-caption">image-20220128174246325</span></p>
<p>下载完成之后，双击下载下来的文件，将syncthing拖入到Application文件夹即可。</p>
<p><img  src="Syncthing-P2P%E6%96%87%E4%BB%B6%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/image-20220128174458194.png"  ><span class="image-caption">image-20220128174458194</span></p>
<p>启动之后可以在桌面顶部菜单栏查看到，点击<code>Open</code>就能打开浏览器访问页面。</p>
<p><img  src="Syncthing-P2P%E6%96%87%E4%BB%B6%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/image-20220128174620326.png"  ><span class="image-caption">image-20220128174620326</span></p>
<h4 id="2-1-3-Linux安装"><a href="#2-1-3-Linux安装" class="headerlink" title="2.1.3 Linux安装"></a>2.1.3 Linux安装</h4><p>我这里使用的是<strong>Ubuntu 18.04</strong>系统，安装方式使用的是<code>apt-get</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 更新软件源</span><br>apt-get update<br><span class="hljs-meta">#</span><span class="bash"> 安装Syncthing</span><br>sudo apt-get install syncthing<br><span class="hljs-meta">#</span><span class="bash"> 安装完成后检查版本</span><br>syncthing -version<br></code></pre></td></tr></table></figure>

<p>现在已经安装了Syncthing，由于Ubuntu 18.04是systemd兼容的，我们可以创建systemd单元文件来管理syncthing服务，systemd的服务文件由Syncthing提供。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 创建文件</span><br>sudo vim /etc/systemd/system/syncthing@root.service<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 写入下面内容，将下面127.0.0.1地址替换成你自己服务器的IP地址，如果还是无法方法，就把下面ip改成0.0.0.0</span><br>[Unit]<br>Description=Syncthing - Open Source Continuous File Synchronization for %I<br>Documentation=man:syncthing(1)<br>After=network.target<br>[Service]<br>User=%i<br>ExecStart=/usr/bin/syncthing -no-browser -gui-address=&quot;127.0.0.1:8384&quot; -no-restart -logflags=0<br>Restart=on-failure<br>SuccessExitStatus=3 4<br>RestartForceExitStatus=3 4<br>[Install]<br>WantedBy=multi-user.target<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 更新systemctl服务列表</span><br>sudo systemctl daemon-reload<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 重新启动syncthing服务</span><br>sudo systemctl start syncthing@root<br></code></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串-左旋转字符串</title>
    <url>/2021/12/24/reverseLeftString/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每日一题，提升自己。今天分享一道关于左旋转字符串的题目，且听我细细道来。</p>
<span id="more"></span>

<h1 id="字符串-左旋转字符串"><a href="#字符串-左旋转字符串" class="headerlink" title="字符串 - 左旋转字符串"></a>字符串 - 左旋转字符串</h1><h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。</p>
<p><strong>示例：</strong></p>
<blockquote>
<p>示例1:</p>
<p>输入：s = “abcdefg”, k = 2</p>
<p>输出：”cdefgab”</p>
<p>示例2:</p>
<p>输入：s = “lrloseumgh”, k = 6</p>
<p>输出：”umghlrlose”</p>
</blockquote>
<p><strong>提示：</strong></p>
<blockquote>
<p>1 &lt;= k &lt; s.length &lt;= 10000</p>
</blockquote>
<h2 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2. 解题思路"></a>2. 解题思路</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于这种字符串旋转，最主要的还是遍历字符串再次拼接，本题是旋转指定长度的字符串，可以在原字符串从需要旋转的位置n开始向后遍历，并且保存到结果字符串中，然后再从原字符串的初始位置遍历到位置n，继续添加到结果字符串中。</p>
<p><strong>复杂度：</strong></p>
<ul>
<li>时间复杂度：O(n)。</li>
<li>空间复杂度：O(n)。</li>
</ul>
<h2 id="3-算法流程"><a href="#3-算法流程" class="headerlink" title="3. 算法流程"></a>3. 算法流程</h2><ol>
<li>初始化结果字符串sb，获取字符串长度len。</li>
<li>从下标n开始遍历，遍历到字符串s结尾，将区间<code>[n,len]</code>的字符添加到sb中。</li>
<li>从下标0开始遍历，遍历到下标n的位置，将区间<code>[0,n]</code>的字符添加到sb中。</li>
</ol>
<h2 id="4-代码实现"><a href="#4-代码实现" class="headerlink" title="4. 代码实现"></a>4. 代码实现</h2><p><strong>Java</strong>代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">reverseLeftString</span><span class="hljs-params">(String str,<span class="hljs-keyword">int</span> k)</span></span>&#123;<br>    StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=k;i&lt;str.length();i++)&#123;<br>        <span class="hljs-keyword">char</span> c = str.charAt(i);<br>        sb.append(c);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;k; i++)&#123;<br>        <span class="hljs-keyword">char</span> c = str.charAt(i);<br>        sb.append(c);<br>    &#125;<br>    <span class="hljs-keyword">return</span> sb.toString();<br>&#125;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串-替换字符串中空格</title>
    <url>/2021/12/23/replaceSpace/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每日一题，提升自己。今天分享一道关于替换字符串中空格的题目，且听我细细道来。</p>
<span id="more"></span>

<h1 id="字符串-替换字符串中空格"><a href="#字符串-替换字符串中空格" class="headerlink" title="字符串 - 替换字符串中空格"></a>字符串 - 替换字符串中空格</h1><h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p>
<p><strong>示例：</strong></p>
<blockquote>
<p>输入：”We are happy.”</p>
<p>输出：”We%20are%20happy.”</p>
</blockquote>
<p><strong>提示：</strong></p>
<blockquote>
<p>0 &lt;= s 的长度 &lt;= 10000</p>
</blockquote>
<h2 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2. 解题思路"></a>2. 解题思路</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看到这个题目是不是觉得，这么简单也算是题？直接调用一首库函数，简单粗暴。当然了，题目肯定是不希望我们这么做的，所以我们还是自己动手换个方法实现一下比较好。最简单的思路就是增加的新的字符串，遍历原来的字符串，如果是非空格则将原来的字符直接拼接到新字符串后面，如果是空格则将<code>%20</code>拼接到新字符串后面。</p>
<p><strong>复杂度：</strong></p>
<ul>
<li>时间复杂度：O(n)。</li>
<li>空间复杂度：O(n)。</li>
</ul>
<h2 id="3-算法流程"><a href="#3-算法流程" class="headerlink" title="3. 算法流程"></a>3. 算法流程</h2><ol>
<li>创建新的字符串。</li>
<li>遍历原字符串，判断当前字符是否是空格，是空格则将<code>%20</code>拼接到新字符串后面。</li>
<li>不是空格则直接拼接到新字符串后面。</li>
<li>直到遍历完整个字符串，返回新字符串。</li>
</ol>
<h2 id="4-代码实现"><a href="#4-代码实现" class="headerlink" title="4. 代码实现"></a>4. 代码实现</h2><p><strong>Java</strong>代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">replaceSpace</span><span class="hljs-params">(String str)</span></span>&#123;<br>    StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;str.length();i++)&#123;<br>        <span class="hljs-keyword">char</span> c = str.charAt(i);<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>            sb.append(<span class="hljs-string">&quot;%20&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            sb.append(c);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sb.toString();<br>&#125;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串-翻转单词顺序</title>
    <url>/2021/12/25/reverseWords/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每日一题，提升自己。今天分享一道关于翻转单词顺序的题目，且听我细细道来。</p>
<span id="more"></span>

<h1 id="字符串-翻转单词顺序"><a href="#字符串-翻转单词顺序" class="headerlink" title="字符串 - 翻转单词顺序"></a>字符串 - 翻转单词顺序</h1><h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串 “I am a student. “，则输出 “student. a am I”。</p>
<p><strong>示例：</strong></p>
<blockquote>
<p>示例1:</p>
<p>输入：”the sky is blue”</p>
<p>输出：”blue is sky the”</p>
<p>示例2:</p>
<p>输入：”  hello world!  “</p>
<p>输出：”world! hello”</p>
<p>解释：输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</p>
<p>示例3:</p>
<p>输入：”a  good    example”</p>
<p>输出：”example good a”</p>
<p>解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</p>
</blockquote>
<p><strong>提示：</strong></p>
<blockquote>
<ol>
<li>无空格字符构成一个单词。</li>
<li>输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</li>
<li>如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</li>
</ol>
</blockquote>
<h2 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2. 解题思路"></a>2. 解题思路</h2><h3 id="2-1-思路一"><a href="#2-1-思路一" class="headerlink" title="2.1 思路一"></a>2.1 思路一</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还是老套路，遍历字符串。题目说无空格字符构成一个单词，所以在遍历字符串的时候只需要遇到空格则代表一个单词的结束，字符串的前后也会有空格，为了减少无用遍历，在真正遍历之前先去除两端空格。每遍历一个单词就把它加入到返回结果的前面。在返回前去除返回结果两端空格。</p>
<h3 id="2-2-思路二"><a href="#2-2-思路二" class="headerlink" title="2.2 思路二"></a>2.2 思路二</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本质还是遍历字符串，只不过这个使用的是双指针去进行遍历。还是先将开头和结尾处多余的空格去掉，从后向前遍历，通过前后指针锁定单词，跳过中间空格，最终将整个句子中的单词反转。</p>
<p><strong>复杂度：</strong></p>
<ul>
<li>时间复杂度：O(n)。</li>
<li>空间复杂度：O(n)。</li>
</ul>
<h2 id="3-算法流程"><a href="#3-算法流程" class="headerlink" title="3. 算法流程"></a>3. 算法流程</h2><h3 id="3-1-思路一流程"><a href="#3-1-思路一流程" class="headerlink" title="3.1 思路一流程"></a>3.1 思路一流程</h3><ol>
<li>初始化返回结果<code>res=&quot;&quot;</code>和临时单词变量<code>word=&quot;&quot;</code>，先去除两端空格，然后依次遍历字符串中的字符。</li>
<li>如果该字符不是空格，就添加到word里面。</li>
<li>如果该字符是空格，证明至少扫描完一个单词，此时判断档次是否为空，因为存在多个空格的情况。如果不为空则加在返回结果前，中间用空格连接，之后继续遍历。</li>
<li>遍历完字符之后，再次判断单词word是否为空，不为空则加在返回结果前，中间用空格连接。</li>
<li>最后将拼接好的字符串res去除两端空格返回即可。</li>
</ol>
<h3 id="3-2-思路二流程"><a href="#3-2-思路二流程" class="headerlink" title="3.2 思路二流程"></a>3.2 思路二流程</h3><ol>
<li>首先将原始字符串去掉开头和结尾的空格得到<code>tmp</code>字符串，便于之后直接从单词处理开始。</li>
<li>初始化单词起始位置<code>start=tmp.length-1</code>和单词结尾指针<code>end=tmp.length-1</code>，位置在字符串结尾处。</li>
<li>初始化结果字符串res为空字符串。</li>
<li>当<code>start&gt;=0</code>时说明字符串未遍历结束，作为循环条件。</li>
<li>在<code>tmp[start]</code>位置，如果不为空格，说明还没有获取到完成的单词，<code>start--</code>。</li>
<li>在获取到完成单词之后，截取<code>[start+1,end+1]</code>这一段字符串加入结果字符串中，因为是从后向前扫描单词的，所以可以之际加到res后面，通过空格连接。</li>
<li>在<code>tmp[start]</code>位置，如果为空格，说明还没有到下一个单词结尾，则<code>start--</code>。</li>
<li>到单词结尾位置之后，<code>end=start</code>，往复进行上述流程，将单词全部反转。</li>
<li>最后将结果字符串res去掉两端多余空格返回即可。</li>
</ol>
<h2 id="4-代码实现"><a href="#4-代码实现" class="headerlink" title="4. 代码实现"></a>4. 代码实现</h2><h3 id="4-1-思路一代码"><a href="#4-1-思路一代码" class="headerlink" title="4.1 思路一代码"></a>4.1 思路一代码</h3><p><strong>Java</strong>代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">reverseWords</span><span class="hljs-params">(String str)</span></span>&#123;<br>    str = str.trim();<br>    String res = <span class="hljs-string">&quot;&quot;</span>;<br>    String word = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;str.length();i++)&#123;<br>        <span class="hljs-keyword">char</span> c = str.charAt(i);<br>        <span class="hljs-keyword">if</span> (c!=<span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>            word += c;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!word.equals(<span class="hljs-string">&quot;&quot;</span>))&#123;<br>            res = word + <span class="hljs-string">&quot; &quot;</span> + res;<br>            word = <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!word.equals(<span class="hljs-string">&quot;&quot;</span>))&#123;<br>        res = word + <span class="hljs-string">&quot; &quot;</span> + res;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res.trim();<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="4-2-思路二代码"><a href="#4-2-思路二代码" class="headerlink" title="4.2 思路二代码"></a>4.2 思路二代码</h3><p><strong>Java</strong>代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">reverseWords</span><span class="hljs-params">(String str)</span></span>&#123;<br>    String tmp = str.trim();<br>    <span class="hljs-keyword">int</span> start = tmp.length()-<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> end = tmp.length()-<span class="hljs-number">1</span>;<br>    String res = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">while</span> (start &gt;= <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">while</span> (start&gt;=<span class="hljs-number">0</span> &amp;&amp; tmp.charAt(start)!=<span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>            start--;<br>        &#125;<br>        res += tmp.substring(start+<span class="hljs-number">1</span>,end+<span class="hljs-number">1</span>) + <span class="hljs-string">&quot; &quot;</span>;<br>        <span class="hljs-keyword">while</span> (start&gt;=<span class="hljs-number">0</span> &amp;&amp; tmp.charAt(start)==<span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>            start--;<br>        &#125;<br>        end = start;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res.trim();<br>&#125;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序-数据操作</title>
    <url>/2020/02/06/wechatApp-dataOpe/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;微信小程序的前端的开发和我们开发网页一样，也是想通过自定的<code>js</code>方法请后台请求到数据，然后渲染到页面上进行显示，不过微信小程序对于数据的操作和网页前端不一样，像数据的赋值、页面之间数据的传递等具体的数据操作是怎么样实现的呢？这篇文章就来简单的介绍一下。</p>
<h1 id="小程序-数据操作"><a href="#小程序-数据操作" class="headerlink" title="小程序-数据操作"></a>小程序-数据操作</h1><h2 id="1-变量的取值与赋值"><a href="#1-变量的取值与赋值" class="headerlink" title="1. 变量的取值与赋值"></a>1. 变量的取值与赋值</h2><h3 id="1-1-单一变量"><a href="#1-1-单一变量" class="headerlink" title="1.1 单一变量"></a>1.1 单一变量</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先简单说一下什么是单一变量，就是一个变量只保存一个值，比如字符串、整型这种变量。对于小程序来说，页面显示的所有数据都是来自页面<code>js</code>文件进行提供的。首先看一下怎么在页面的<code>js</code>文件里为小程序变量赋值呢。示例代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//test.js</span><br>Page(&#123;<br>    <span class="hljs-comment">//data存放全局变量数据的地方，是一个json字符串，存放变量的初始值</span><br>    <span class="hljs-attr">data</span>: &#123;<br>        <span class="hljs-comment">//变量a是一个字符串</span><br>        <span class="hljs-attr">a</span>: <span class="hljs-string">&#x27;hello word&#x27;</span>,<br>        <span class="hljs-comment">//变量b是一个整型</span><br>        <span class="hljs-attr">b</span>: <span class="hljs-number">2</span><br>    &#125;,<br>    <span class="hljs-comment">//自定义方法，为变量进行赋值</span><br>    <span class="hljs-attr">toSetDatas</span>:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>&#123;<br>        <span class="hljs-comment">//方法一：直接赋值，对原数值本身进行操作</span><br>        <span class="hljs-comment">//但是要注意一点，这种方法虽然能给变量重新赋值，但是不会同步更新到页面，</span><br>        <span class="hljs-built_in">this</span>.data.a = <span class="hljs-string">&#x27;Hello word!&#x27;</span>,<br>        <span class="hljs-built_in">this</span>.data.b = <span class="hljs-number">3</span><br>        <br>        <span class="hljs-comment">//方法二：使用setData方法进行变量赋值</span><br>        <span class="hljs-built_in">this</span>.setData(&#123;<br>            <span class="hljs-attr">a</span>: <span class="hljs-string">&#x27;Hello Word!&#x27;</span>,<br>            <span class="hljs-attr">b</span>:<span class="hljs-number">3</span><br>        &#125;)<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上述代码中提供了两种赋值方法，但是常用的还是第二种通过<code>setData</code>方法进行赋值，因为第一种方法只能在后台将数据进行修改，不会实时更新页面的数据，所以不实用，第二种方法可以既可以修改变量数据，也可以进行页面数据的实时同步。在页面获取数据的方法其实也很简单，只需要用两个大括号**&#123;&#123;&#125;&#125;**括住变量即可将数据显示在页面上，示例如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--test.wxml--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">view</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">text</span>&gt;</span>变量a的值为：&#123;&#123;a&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">text</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 变量a的值为：Hello Word! --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">view</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">text</span>&gt;</span>变量b的值为：&#123;&#123;b&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">text</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--  变量b的值为：3 --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>以上只是页面获取数据一个简单的数据绑定，其他渲染数据的方法对于数据获取的方法是一样，更多渲染数据请参考<a href="https://developers.weixin.qq.com/miniprogram/dev/reference/wxml/">WXML语法</a>。</p>
<h3 id="1-2-复合变量"><a href="#1-2-复合变量" class="headerlink" title="1.2 复合变量"></a>1.2 复合变量</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;微信小程序中的复合变量主要有数组和<code>json</code>格式的数据。对这种数据的赋值使用的还是<code>setData</code>方法，但是和单一变量的赋值略有不同，这次在赋值的之后不能直接写变量名了，编译会包错。示例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//test.js</span><br>Page(&#123;<br>    <span class="hljs-attr">data</span>: &#123;<br>        <span class="hljs-attr">list</span>: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>],<br>    	<span class="hljs-attr">person</span>: &#123;<br>            <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;张三&#x27;</span>,<br>            <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br>            <span class="hljs-attr">sex</span>: <span class="hljs-string">&#x27;男&#x27;</span><br>        &#125; <br>    &#125;,<br>    <span class="hljs-comment">//错误的赋值方法，</span><br>    <span class="hljs-comment">//下面对数据的赋值，编译时就是错的，会报错unknown: Unexpected token, expected</span><br>    <span class="hljs-attr">Error</span>:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>&#123;<br>        <span class="hljs-built_in">this</span>.setData(&#123;<br>            list[<span class="hljs-number">0</span>]: <span class="hljs-number">4</span>,<br>            person.name: <span class="hljs-string">&#x27;李四&#x27;</span><br>        &#125;)<br>    &#125;,<br>     <br>    <span class="hljs-comment">//正确的赋值方法一：直接赋值，用引号包括变量</span><br>     <span class="hljs-attr">Right_1</span>:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>&#123;<br>    	<span class="hljs-built_in">this</span>.setData(&#123;<br>            <span class="hljs-string">&#x27;list[0]&#x27;</span>: <span class="hljs-number">4</span>,<br>            <span class="hljs-string">&#x27;person.name&#x27;</span>: <span class="hljs-string">&#x27;李四&#x27;</span><br>        &#125;)<br>	&#125;,<br>        <br>    <span class="hljs-comment">//正确的赋值方法二：拼接赋值</span><br>    <span class="hljs-comment">//首先获取数据变量的字符串格式，然后通过中括号[]包括变量，进行赋值</span><br>    <span class="hljs-comment">//因为先获取的变量的字符串形式，所以可以动态赋值</span><br>    <span class="hljs-attr">Right_2</span>:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>&#123;<br>        <span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">var</span> list_1 = <span class="hljs-string">&#x27;list[&#x27;</span> + i + <span class="hljs-string">&#x27;]&#x27;</span><br>        <span class="hljs-keyword">var</span> personName = <span class="hljs-string">&#x27;person.name&#x27;</span><br>        <span class="hljs-built_in">this</span>.setData(&#123;<br>            [list_1]: <span class="hljs-number">4</span>,<br>            [personName]: <span class="hljs-string">&#x27;李四&#x27;</span><br>        &#125;)<br>    &#125;    <br>&#125;)<br></code></pre></td></tr></table></figure>

<p>页面取值和单一变量一下，也是用两个大括号**&#123;&#123;&#125;&#125;**包括起来，示例如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--test.wxml--&gt;</span><br><span class="hljs-comment">&lt;!-- wx:for:绑定要遍历的列表；wx:for-index:指定数组当前下标的变量名，默认是index；wx:for-item:指定数组当前元素的变量名，默认是item。 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">wx:for</span>=<span class="hljs-string">&quot;&#123;&#123;list&#125;&#125;&quot;</span> <span class="hljs-attr">wx:for-index</span>=<span class="hljs-string">&quot;index&quot;</span> <span class="hljs-attr">wx:for-item</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">text</span>&gt;</span>数组第&#123;&#123;index&#125;&#125;的值为：&#123;&#123;item&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">text</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--  数组第0的值为：1 --&gt;</span><br>    <span class="hljs-comment">&lt;!--  数组第1的值为：4 --&gt;</span><br>    <span class="hljs-comment">&lt;!--  数组第2的值为：a --&gt;</span><br>    <span class="hljs-comment">&lt;!--  数组第3的值为：b --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">view</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">text</span>&gt;</span>person的姓名为：&#123;&#123;person.name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">text</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--  person的姓名为：李四 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">text</span>&gt;</span>person的年龄为：&#123;&#123;person.age&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">text</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--  person的年龄为：18 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">text</span>&gt;</span>person的性别为：&#123;&#123;person.sex&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">text</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--  person的性别为：男 --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h2 id="2-页面之间数据的传递"><a href="#2-页面之间数据的传递" class="headerlink" title="2. 页面之间数据的传递"></a>2. 页面之间数据的传递</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一般在页面跳转的时候，需要从当前页面给下一级页面进行数据的传递，传递的数据格式有单一变量、对象、对象数组三种。</p>
<h3 id="2-1-单一变量"><a href="#2-1-单一变量" class="headerlink" title="2.1 单一变量"></a>2.1 单一变量</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;单一变量不是就只是一个变量，也有可能是多个，只是单个传递过去的，没有封装在在一起，传递方式就是<code>URL</code>后面加参数的方式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//indes.js</span><br><span class="hljs-comment">//向下一级页面传递单一变量</span><br><span class="hljs-attr">testFunction</span>:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>):</span>&#123; <br>    wx.navigateTo(&#123;<br>        <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;../tets/test?name=&#x27;</span> + name +<span class="hljs-string">&#x27;&amp;age=&#x27;</span> + age,<br>    &#125;)<br>&#125;<br><br><span class="hljs-comment">//test.js</span><br><span class="hljs-comment">//在下一级页面的onload方法中获取</span><br><span class="hljs-attr">onLoad</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">options</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> name = options.name<br>    <span class="hljs-keyword">var</span> age = options.age<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;name=&#x27;</span>+name)<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;age=&#x27;</span>+age)<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="2-2-传递对象"><a href="#2-2-传递对象" class="headerlink" title="2.2 传递对象"></a>2.2 传递对象</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;传递对象也是将数据附加在<code>URL</code>后面进行传递，只不过传递之前要先改变一下格式，将<code>JSON</code>格式的数据转换成<code>string</code>类型，这样才能进行传递。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//index.js</span><br><span class="hljs-comment">//向下一级页面传递对象参数</span><br><span class="hljs-comment">// 通过JSON.stringify(obj) 方法将对象转化为字符串进行传递</span><br><span class="hljs-attr">testFunction</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;<br>    person = &#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;张三&#x27;</span>,<br>        <span class="hljs-attr">sex</span>: <span class="hljs-string">&#x27;男&#x27;</span>,<br>        <span class="hljs-attr">age</span>: <span class="hljs-number">18</span><br>    &#125;<br>    <span class="hljs-keyword">var</span> data = <span class="hljs-built_in">JSON</span>.stringify(person);<br>    wx.navigateTo(&#123;<br>        <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;../test/test?data=&#x27;</span> + data,<br>    &#125;)<br>&#125;<br><br><span class="hljs-comment">//test.js</span><br><span class="hljs-comment">//在下一级页面的onload中获取,</span><br><span class="hljs-attr">onLoad</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">options</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> person = options.data;<br>    <span class="hljs-built_in">console</span>.log(person)<br>    <span class="hljs-comment">//&#123;&quot;name&quot;:&quot;张三&quot;,&quot;sex&quot;:&quot;男&quot;,&quot;age&quot;:18&#125;           json格式的json字符串</span><br>&#125;,<br></code></pre></td></tr></table></figure>

<h3 id="2-3-传递数组对象"><a href="#2-3-传递数组对象" class="headerlink" title="2.3 传递数组对象"></a>2.3 传递数组对象</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;传递对象也是将数据附加在<code>URL</code>后面进行传递，只不过传递之前要先改变一下格式，将<code>list</code>格式的数据转换成<code>string</code>类型，这样才能进行传递，然后在下一级页面再把接收到的数据转换成<code>list</code>格式就行了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//index.js</span><br><span class="hljs-comment">//向下一级页面传递数组对象参数</span><br><span class="hljs-comment">// 通过JSON.stringify(obj) 方法将对象转化为字符串进行传递</span><br><span class="hljs-attr">testFunction</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;<br>    lsit = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>    <span class="hljs-keyword">var</span> data = <span class="hljs-built_in">JSON</span>.stringify(list);<br>    wx.navigateTo(&#123;<br>        <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;../test/test?data=&#x27;</span> + data,<br>    &#125;)<br>&#125;<br><br><span class="hljs-comment">//test.js</span><br><span class="hljs-comment">//在下一级页面的onload中获取,</span><br><span class="hljs-attr">onLoad</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">options</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(options.data)<br>    <span class="hljs-comment">//[1,2,3,4]    字符串格式</span><br>    <span class="hljs-comment">//将接收到的字符串数据转换成数组格式</span><br>    <span class="hljs-keyword">var</span> list = <span class="hljs-built_in">JSON</span>.parse(options.data);<br>    <span class="hljs-built_in">console</span>.log(list)<br>    <span class="hljs-comment">// 1,2,3,4     object格式</span><br>&#125;,<br></code></pre></td></tr></table></figure>

<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本篇主要就是讲述了一下在小程序中对于数据的操作，也是我一步一步踩过的坑。说多了都是泪啊~最主要的就是复合变量的赋值以及后面的对象参数进行传递数据，牵涉到格式转换的问题。不多说了，在这算是把这些坑填上了，下次就不用再踩了。</p>
]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>数组-二维数组中查询</title>
    <url>/2021/12/17/findNumberIn2DArra/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每日一题，提升自己。今天分享一道关于二维数组中查询的题目，且听我细细道来。</p>
<span id="more"></span>

<h1 id="数组-二维数组中查询"><a href="#数组-二维数组中查询" class="headerlink" title="数组 - 二维数组中查询"></a>数组 - 二维数组中查询</h1><h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在一个 n * m 的二维数组中，每一行都按照<strong>从左到右递增</strong>的顺序排序，每一列都按照<strong>从上到下递增</strong>的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p><strong>示例：</strong></p>
<blockquote>
<p>现有矩阵 matrix 如下：<br> [<br>       [1,   4,  7, 11, 15],<br>       [2,   5,  8, 12, 19],<br>       [3,   6,  9, 16, 22],<br>       [10, 13, 14, 17, 24],<br>       [18, 21, 23, 26, 30]<br> ]</p>
<p>给定target=5，返回true</p>
<p>给定target=6，返回false</p>
</blockquote>
<p><strong>提示：</strong></p>
<blockquote>
<p>限制：</p>
<p>0 &lt;= n &lt;= 1000</p>
<p>0 &lt;= m &lt;= 1000</p>
</blockquote>
<h2 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2. 解题思路"></a>2. 解题思路</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本题可以通过遍历数组来进行查找，不过显然这是最笨的方法，时间复杂度很高，但是我们可以换一种方法去遍历。首先结合题目观察矩阵发现，左下角的数字，上方的数组都小于它，右方的数字都大于它。该规律可应用于矩阵中的每一个数，所以可以根据该规律去进行判断。</p>
<p><strong>复杂度：</strong></p>
<ul>
<li>时间复杂度：O(m+n)。</li>
</ul>
<h2 id="3-算法流程"><a href="#3-算法流程" class="headerlink" title="3. 算法流程"></a>3. 算法流程</h2><ol>
<li>设当前数字为最左下角的数字cur，目标数为target。</li>
<li>初始化当前数字角标，<code>x=matrix.length-1,y=0</code>。</li>
<li>如果target &gt; cur：则向右查找，即y++。</li>
<li>如果target &lt; cur：则向上查找，即x–。</li>
<li>如果target == cul：则返回true。</li>
<li>否则直到数组边界，返回false。</li>
</ol>
<h2 id="4-代码实现"><a href="#4-代码实现" class="headerlink" title="4. 代码实现"></a>4. 代码实现</h2><p><strong>Java</strong>代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">findNumberIn2DArra</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix, <span class="hljs-keyword">int</span> target)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(matrix.length == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    <br>    <span class="hljs-keyword">int</span> x = matrix.length-<span class="hljs-number">1</span>,y = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (x &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; matrix[<span class="hljs-number">0</span>].length)&#123;<br>        <span class="hljs-keyword">if</span> (target &gt; matrix[x][y])&#123;<br>            y++;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target &lt; matrix[x][y])&#123;<br>            x--;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>数组-判断扑克牌顺子</title>
    <url>/2021/12/18/isStraight/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每日一题，提升自己。今天分享一道关于判断扑克牌顺子的题目，且听我细细道来。</p>
<span id="more"></span>

<h1 id="数组-判断扑克牌顺子"><a href="#数组-判断扑克牌顺子" class="headerlink" title="数组 - 判断扑克牌顺子"></a>数组 - 判断扑克牌顺子</h1><h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从扑克牌中随机抽 5 张牌，判断是不是一个顺子，即这 5 张牌是不是连续的。2 ～ 10 为数字本身，1 为 A，11 为 J，12 为 Q，13 为 K，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。</p>
<p><strong>示例：</strong></p>
<blockquote>
<p>示例1:</p>
<p>输入：[1,2,3,4,5]</p>
<p>输出：true</p>
<p>示例2:</p>
<p>输入：[0,0,1,2,5]</p>
<p>输出：true</p>
</blockquote>
<p><strong>提示：</strong></p>
<blockquote>
<p>1，数组长度为5。</p>
<p>2，数组的数取值为 [0, 13]。</p>
</blockquote>
<h2 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2. 解题思路"></a>2. 解题思路</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先我们先来了解一下关于顺子牌的定义。</p>
<ol>
<li>牌的数量是5张。</li>
<li>牌间的顺序是递增，且差值为1。</li>
<li>牌间不可以有重复数据（大小王除外）。（扑克牌术语：如果一副牌里含有对子，则不可能是顺子）。</li>
<li>大小王可以作为任意牌，即可以作为牌间空隙插入，且数量不限。</li>
</ol>
<h3 id="2-1-思路一"><a href="#2-1-思路一" class="headerlink" title="2.1 思路一"></a>2.1 思路一</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先是对数组进行升序排序。然后遍历数组，统计出0的个数。如果有重复数据就返回false，否则就计算当前数和前一个数的差值减去一，然后用0来抵消两张牌的间隙。当0的个数小于0时，证明大小王的个数不足与补齐牌的间隙，那么就不是顺子。</p>
<h3 id="2-2-思路二"><a href="#2-2-思路二" class="headerlink" title="2.2 思路二"></a>2.2 思路二</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;按照上面的描述，首先我们需要对数组进行升序排序。如果数组中有重复数据，那么就返回false。然后令minVal为不包含大小王的最小值，maxVal为不包含大小王的最大值，由于牌数量为 5，如果是顺子，就一定有<code>maxVal-minVal &lt; 5</code>。否则就不是顺子。</p>
<p><strong>复杂度：</strong></p>
<ul>
<li>时间复杂度：O(NlogN)。</li>
<li>空间复杂度：O(1)。</li>
</ul>
<h2 id="3-算法流程"><a href="#3-算法流程" class="headerlink" title="3. 算法流程"></a>3. 算法流程</h2><h3 id="3-1-思路一流程"><a href="#3-1-思路一流程" class="headerlink" title="3.1 思路一流程"></a>3.1 思路一流程</h3><ol>
<li>对数组进行从小到大排序。</li>
<li>遍历数组，统计0的个数。当前数大于0时，则0的个数统计完毕，保留当前第一个不为0的数字的角标。</li>
<li>从不为0的部分继续遍历数组，判断当前数与前一个数是否相等。</li>
<li>如果当前数与前一个数相等，返回false；否则0的个数变成当前0的个数减去当前数与前一个数的差再减一。就是看两个数之间需要几个0去补充。</li>
<li>之后判断当0的个数小于0个之后，则返回false。</li>
</ol>
<h3 id="3-2-思路二流程"><a href="#3-2-思路二流程" class="headerlink" title="3.2 思路二流程"></a>3.2 思路二流程</h3><ol>
<li>对数组进行从小到大排序。</li>
<li>遍历数组，统计0的个数。如果当前不是数组最后一位数，则判断当前数和下一位是否相等，如果相等则直接返回false。</li>
<li>minVal是数组中角标为0的个数的数字，maxVal是数组的最后一位数，返回<code>maxVal-minVal &lt; 5</code>的结果。</li>
</ol>
<h2 id="4-代码实现"><a href="#4-代码实现" class="headerlink" title="4. 代码实现"></a>4. 代码实现</h2><h3 id="4-1-思路一代码"><a href="#4-1-思路一代码" class="headerlink" title="4.1 思路一代码"></a>4.1 思路一代码</h3><p><strong>Java</strong>代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isStraight</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span></span>&#123;<br>    Arrays.sort(nums);<br>    <span class="hljs-keyword">int</span> zero_count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (;i&lt;nums.length;i++)&#123;<br>        <span class="hljs-keyword">if</span> (nums[i] &gt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] == <span class="hljs-number">0</span>)&#123;<br>            zero_count++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (++i;i&lt;nums.length;i++)&#123;<br>        <span class="hljs-keyword">if</span> (nums[i] == nums[i-<span class="hljs-number">1</span>])&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        zero_count -= (nums[i] - nums[i-<span class="hljs-number">1</span>] - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (zero_count &lt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="4-2-思路二代码"><a href="#4-2-思路二代码" class="headerlink" title="4.2 思路二代码"></a>4.2 思路二代码</h3><p><strong>Java</strong>代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isStraight</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span></span>&#123;<br>    Arrays.sort(nums);<br>    <span class="hljs-keyword">int</span> zero_count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;<br>        <span class="hljs-keyword">if</span> (nums[i] == <span class="hljs-number">0</span>)&#123;<br>            zero_count++;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (i != nums.length-<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">if</span> (nums[i] == nums[i+<span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> nums[nums.length-<span class="hljs-number">1</span>] - nums[zero_count] &lt; <span class="hljs-number">5</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>数组-数组奇偶排序</title>
    <url>/2021/12/15/exchange/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每日一题，提升自己。今天分享一道关于数组奇偶排序的题目，且听我细细道来。</p>
<span id="more"></span>

<h1 id="数组-奇偶排序"><a href="#数组-奇偶排序" class="headerlink" title="数组 - 奇偶排序"></a>数组 - 奇偶排序</h1><h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。</p>
<p><strong>示例：</strong></p>
<blockquote>
<p>输入：nums =[1,2,3,4]</p>
<p>输出：[1,3,2,4]</p>
<p>注：[3,1,2,4] 也是正确的答案之一。</p>
</blockquote>
<p><strong>提示：</strong></p>
<blockquote>
<p>1 &lt;= nums.length &lt;= 50000</p>
<p>1 &lt;= nums[i] &lt;= 10000</p>
</blockquote>
<h2 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2. 解题思路"></a>2. 解题思路</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这道题只是对数组内元素的一个奇偶排序，首先可以想到的就是双指针，从前后来分别扫描元素。首先指定前指针 <code>left</code> 和后指针 <code>right</code>，然后前指针定位偶数，后指针定位奇数，定位到之后将两个值互换，直到数组遍历完成。</p>
<p><strong>复杂度：</strong></p>
<ul>
<li>时间复杂度：O(n)。</li>
<li>空间复杂度：O(1)。</li>
</ul>
<h2 id="3-算法流程"><a href="#3-算法流程" class="headerlink" title="3. 算法流程"></a>3. 算法流程</h2><ol>
<li>初始化前指针 left = 0，后指针 right = nums.length - 1。</li>
<li>当 left &lt; right 时表示该数组还未遍历完成，则继续进行奇数和偶数的交换。</li>
<li>当 nums[left] 为奇数时，则 left++，直到找到不为奇数的下标为止。</li>
<li>当 nums[right] 为偶数时，则 right–，直到找到不为偶数的下标为止。</li>
<li>交换 nums[left] 和 nums[right]，继续下一轮交换。</li>
<li>数组遍历完成之后，返回 nums，即为交换后的结果</li>
</ol>
<h2 id="4-代码实现"><a href="#4-代码实现" class="headerlink" title="4. 代码实现"></a>4. 代码实现</h2><p><strong>Java</strong>代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] exchange(<span class="hljs-keyword">int</span>[] nums) &#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> right = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt; right)&#123;<br>        <span class="hljs-comment">// 前指针一直寻找偶数</span><br>        <span class="hljs-keyword">while</span> (left&lt;right &amp;&amp; (nums[left]%<span class="hljs-number">2</span>!=<span class="hljs-number">0</span>))&#123;<br>            left++;<br>        &#125;<br>        <span class="hljs-comment">// 后指针一直寻找奇数</span><br>        <span class="hljs-keyword">while</span> (left&lt;right &amp;&amp; (nums[right]%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>))&#123;<br>            right--;<br>        &#125;<br>        <span class="hljs-keyword">int</span> tmp = nums[left];<br>        nums[left] = nums[right];<br>        nums[right] = tmp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> nums;<br>&#125;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>数组-寻找数组中缺少的数字</title>
    <url>/2021/12/21/missingNumber/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每日一题，提升自己。今天分享一道关于寻找数组中缺少的数字的题目，且听我细细道来。</p>
<span id="more"></span>

<h1 id="数组-寻找数组中缺少的数字"><a href="#数组-寻找数组中缺少的数字" class="headerlink" title="数组 - 寻找数组中缺少的数字"></a>数组 - 寻找数组中缺少的数字</h1><h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个长度为 n-1 的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围 0～n-1 之内。在范围 0～n-1 内的 n 个数字中有且只有一个数字不在该数组中，请找出这个数字。</p>
<p><strong>示例：</strong></p>
<blockquote>
<p>示例1：</p>
<p>输入：[0,1,3]</p>
<p>输出：2</p>
<p>示例2：</p>
<p>输入：[0,1,2,3,4,5,6,7,9]</p>
<p>输出：8</p>
</blockquote>
<p><strong>提示：</strong></p>
<blockquote>
<p>1 &lt;= 数组长度 &lt;= 10000</p>
</blockquote>
<h2 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2. 解题思路"></a>2. 解题思路</h2><h3 id="2-1-思路一"><a href="#2-1-思路一" class="headerlink" title="2.1 思路一"></a>2.1 思路一</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本题给的数组数字范围都是在<code>0~n-1</code>之间的，那么很容易想到的就是比较当前数字和当前在数组内的角标是否相同，因为如果不缺数字的话数组的内容是和角标一一对应的。所以在遍历数组时，如果当前数字和角标不同，那么则证明当前角标对应的数字缺失，返回即可。</p>
<h3 id="2-2-思路二"><a href="#2-2-思路二" class="headerlink" title="2.2 思路二"></a>2.2 思路二</h3><p>本题数组内的数数字如果不缺少的话，是一个连续的数组，那么可以通过前后两个数之差来判断是否缺少。顺序情况下差值应该是1，所以当差值大于1，则表示缺少数字，缺少的是前一个数加一。</p>
<h3 id="2-3-思路三"><a href="#2-3-思路三" class="headerlink" title="2.3 思路三"></a>2.3 思路三</h3><p>本题给的数组既然是一个顺序递增的，同样也是查找数字，那么就可以用二分法来处理。因为数组从0增序存储，所以如果不确实则数组数字与数组索引相对应。缺失的部分等于“右子数组的首位元素”。</p>
<ul>
<li>左子数组：<code>nums[i] == i</code>，数字与数组索引相等，则前半部分没有缺失，在右半部分查找。</li>
<li>右子数字：<code>nums[i] != i</code>，数字与数组索引不相等，则缺失数字在左半部分。</li>
</ul>
<p><strong>复杂度：</strong></p>
<ul>
<li>时间复杂度：O(logn)。</li>
<li>空间复杂度：O(1)。</li>
</ul>
<h2 id="3-算法流程"><a href="#3-算法流程" class="headerlink" title="3. 算法流程"></a>3. 算法流程</h2><h3 id="3-1-思路一流程"><a href="#3-1-思路一流程" class="headerlink" title="3.1 思路一流程"></a>3.1 思路一流程</h3><ol>
<li>遍历数组，比较当前数字和当前索引。</li>
<li>如果当前数字和索引不相等，则返回当前索引。</li>
</ol>
<h3 id="3-2-思路二流程"><a href="#3-2-思路二流程" class="headerlink" title="3.2 思路二流程"></a>3.2 思路二流程</h3><ol>
<li>如果第一个数不等于0，则代表缺少0，返回0。</li>
<li>否则初始化当前数字<code>pre=nums[0]</code>。</li>
<li>从第二位开始遍历数组，遍历的当前数与pre差值大于1，则代表缺失数为pre+1。</li>
<li>如果当前数与pre差值不大于1，pre等于当前数，继续遍历。</li>
</ol>
<h3 id="3-3-思路三流程"><a href="#3-3-思路三流程" class="headerlink" title="3.3 思路三流程"></a>3.3 思路三流程</h3><ol>
<li>首先初始化二分查找的左边界<code>left = 0</code>和右边界<code>right = nums.length-1</code>。</li>
<li>当左边界不大于右边界时进行查找。</li>
<li>计算中间位置<code>mid = (left + right) / 2</code>。</li>
<li>如果 <code>nums[mid] == mid</code> ，则缺失的元素，即右子数组的首位元素在 <code>[mid + 1, right]</code> 中间，令<code> left = mid + 1</code>。</li>
<li>如果 <code>nums[mid] != mid</code> ，则缺失的元素，即右子数组的首位元素在<code> [left, mid - 1]</code> 中间，令 <code>right = mid - 1</code>。</li>
</ol>
<h2 id="4-代码实现"><a href="#4-代码实现" class="headerlink" title="4. 代码实现"></a>4. 代码实现</h2><h3 id="4-1-思路一代码"><a href="#4-1-思路一代码" class="headerlink" title="4.1 思路一代码"></a>4.1 思路一代码</h3><p><strong>Java</strong>代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">missingNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;<br>        <span class="hljs-keyword">if</span> (nums[i] != i)&#123;<br>            <span class="hljs-keyword">return</span> i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> nums.length;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="4-2-思路二代码"><a href="#4-2-思路二代码" class="headerlink" title="4.2 思路二代码"></a>4.2 思路二代码</h3><p><strong>Java</strong>代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">missingNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (nums[<span class="hljs-number">0</span>] != <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> pre = nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;nums.length;i++)&#123;<br>        <span class="hljs-keyword">if</span> (nums[i] - pre &gt; <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> pre+<span class="hljs-number">1</span>;<br>        &#125;<br>        pre = nums[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> nums.length;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="4-3-思路三代码"><a href="#4-3-思路三代码" class="headerlink" title="4.3 思路三代码"></a>4.3 思路三代码</h3><p><strong>Java</strong>代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">missingNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> left=<span class="hljs-number">0</span>,right=nums.length-<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt; right)&#123;<br>        <span class="hljs-keyword">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] == mid)&#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>数组-寻找过半数字</title>
    <url>/2021/12/19/majorityElement/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每日一题，提升自己。今天分享一道关于寻找过半数字的题目，且听我细细道来。</p>
<span id="more"></span>

<h1 id="数组-寻找过半数字"><a href="#数组-寻找过半数字" class="headerlink" title="数组 - 寻找过半数字"></a>数组 - 寻找过半数字</h1><h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数组中一定有一个数字出现的次数超过数组长度的一半，请找出这个数字。你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<p><strong>示例：</strong></p>
<blockquote>
<p>输入：[1, 2, 3, 2, 2, 2, 5, 4, 2]</p>
<p>输出：2</p>
</blockquote>
<p><strong>提示：</strong></p>
<blockquote>
<p>1 &lt;= 数组长度 &lt;= 50000</p>
</blockquote>
<h2 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2. 解题思路"></a>2. 解题思路</h2><h3 id="2-1-思路一"><a href="#2-1-思路一" class="headerlink" title="2.1 思路一"></a>2.1 思路一</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本题可以用排序法来解决，因为数组中一定有一个数字超过数组长度一半，那么排序之后的数组，中间元素就是要寻找的数字。</p>
<p><strong>复杂度：</strong></p>
<ul>
<li>时间复杂度：O(nlogn)。</li>
</ul>
<h3 id="2-2-思路二"><a href="#2-2-思路二" class="headerlink" title="2.2 思路二"></a>2.2 思路二</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本题可以用哈希计数法来解决，在遍历数组的同时，使用当前数字作为key，当前数字出现的次数存为value，存放在一个HashMap中，统计每个数字出现的次数。统计完成之后再遍历一下HashMap，找到value最大的那个值，此时对应的key就是超过数组长度一半的数字。</p>
<p><strong>复杂度：</strong></p>
<ul>
<li>时间复杂度：O(n)。</li>
</ul>
<h3 id="2-3-思路三"><a href="#2-3-思路三" class="headerlink" title="2.3 思路三"></a>2.3 思路三</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还有一种方式可以解决本题，那就是<strong>摩尔投票</strong>，遍历数组，使用count进行计数，记录当前出现的数字为cur，如果遍历到数字与cur相等，则count加一，否则就减一。当count减到0点时候，将cur修改为当前正在遍历的数字，通过增减抵消的方式，最终剩下的数字就是要寻找的过半数字。这种方法相对于前两种来说是<strong>最优的</strong>。</p>
<blockquote>
<p>摩尔投票算法是基于这个事实：每次从序列里选择两个不相同的数字删除掉（或称为“抵消”），最后剩下一个数字或几个相同的数字，就是出现次数大于总数一半的那个。</p>
</blockquote>
<p><strong>复杂度：</strong></p>
<ul>
<li>时间复杂度：O(n)。</li>
<li>空间复杂度：O(1)。</li>
</ul>
<h2 id="3-算法流程"><a href="#3-算法流程" class="headerlink" title="3. 算法流程"></a>3. 算法流程</h2><h3 id="3-1-思路一流程"><a href="#3-1-思路一流程" class="headerlink" title="3.1 思路一流程"></a>3.1 思路一流程</h3><p><strong>排序法：</strong></p>
<ol>
<li>首先对数组进行排序。</li>
<li>返回排序过后的数组的中间数字。</li>
</ol>
<h3 id="3-2-思路二流程"><a href="#3-2-思路二流程" class="headerlink" title="3.2 思路二流程"></a>3.2 思路二流程</h3><p><strong>哈希计数法：</strong></p>
<ol>
<li>创建一个HashMap用于存放数据。</li>
<li>遍历数组，判断HashMap中是否存在等于该数字的key。</li>
<li>如果不存在，则将当前数字作为key存入，value等于1。</li>
<li>如果存在，将当前数字对应的value加一。</li>
<li>遍历HashMap，找出最大的value值。</li>
<li>返回value对应的key。</li>
</ol>
<h3 id="3-3-思路三流程"><a href="#3-3-思路三流程" class="headerlink" title="3.3 思路三流程"></a>3.3 思路三流程</h3><p><strong>摩尔投票法：</strong></p>
<ol>
<li>初始化当前数cur=0，当前计数器count=0。</li>
<li>遍历数组，如果count==0，那么将遍历的当前数赋值给cur，count++。</li>
<li>如果cur等于遍历的当前数，count++。</li>
<li>否则count–。</li>
<li>返回cur。</li>
</ol>
<h2 id="4-代码实现"><a href="#4-代码实现" class="headerlink" title="4. 代码实现"></a>4. 代码实现</h2><h3 id="4-1-思路一代码"><a href="#4-1-思路一代码" class="headerlink" title="4.1 思路一代码"></a>4.1 思路一代码</h3><p><strong>Java</strong>代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">majorityElement_1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span></span>&#123;<br>    Arrays.sort(nums);<br>    <span class="hljs-keyword">return</span> nums[nums.length / <span class="hljs-number">2</span>];<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="4-2-思路二代码"><a href="#4-2-思路二代码" class="headerlink" title="4.2 思路二代码"></a>4.2 思路二代码</h3><p><strong>Java</strong>代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">majorityElement_2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span></span>&#123;<br>    Map&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums)&#123;<br>        <span class="hljs-keyword">if</span> (map.containsKey(num))&#123;<br>            map.put(num, map.get(num)+<span class="hljs-number">1</span>);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            map.put(num, <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    Set&lt;Integer&gt; keys = map.keySet();<br>    <span class="hljs-keyword">int</span> resKey = keys.iterator().next();<br>    <span class="hljs-keyword">for</span> (Integer key : keys)&#123;<br>        <span class="hljs-keyword">if</span> (map.get(key) &gt; map.get(resKey))&#123;<br>            resKey = key;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> resKey;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="4-3-思路三代码"><a href="#4-3-思路三代码" class="headerlink" title="4.3 思路三代码"></a>4.3 思路三代码</h3><p><strong>Java</strong>代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">majorityElement_3</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> cur=<span class="hljs-number">0</span>,count=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) &#123;<br>            cur = nums[i];<br>            count++;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur == nums[i])<br>            count++;<br>        <span class="hljs-keyword">else</span> count--;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cur;<br>&#125;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>数组-寻找连续序列</title>
    <url>/2021/12/16/findContinuousSequence/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每日一题，提升自己。今天分享一道关于寻找连续序列的题目，且听我细细道来。</p>
<span id="more"></span>

<h1 id="数组-寻找连续序列"><a href="#数组-寻找连续序列" class="headerlink" title="数组 - 寻找连续序列"></a>数组 - 寻找连续序列</h1><h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。序列内的数字由小到大排列，不同序列按照首个数字从小到大排列，方法返回一个二维数组。</p>
<p><strong>示例1:</strong></p>
<blockquote>
<p>输入：target = 9</p>
<p>输出：[[2,3,4],[4,5]]</p>
</blockquote>
<p>示例2:</p>
<blockquote>
<p>输入：target = 15</p>
<p>输出：[[1,2,3,4,5],[4,5,6],[7,8]]</p>
</blockquote>
<p>提示:</p>
<blockquote>
<p>1 &lt;= target &lt;= 10^5</p>
</blockquote>
<h2 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2. 解题思路"></a>2. 解题思路</h2><h3 id="2-1-思路一"><a href="#2-1-思路一" class="headerlink" title="2.1 思路一"></a>2.1 思路一</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要求一个数的连续序列和，首先可以得知一个数的连续序列和，其中序列中最小的数绝对不超过该数的的一半，这样遍历时就可以把起始数减少一半。从<code>target/2</code>开始进行遍历，作为起始数，然后开始下一个数字的累加。判断累加结果是否等于target，如果是则存入结果，起始数加一重新遍历。如果大于target则起始数加一重新遍历。如果小于target，末位数加一继续遍历。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为要求返回二维数组，而二维数组的长度是不确定的，内部的每一个一维数组的长度也是不确定的，所以每次初始化是一个List，然后每次得到满足条件的序列需要创建新得数组，将数组放进List中，最后返回时将List转换成二维数组即可。</p>
<h3 id="2-2-思路二"><a href="#2-2-思路二" class="headerlink" title="2.2 思路二"></a>2.2 思路二</h3><p>此题最容易想到的思路就是暴力枚举，因为题目条件要求至少含有两个数，所以枚举到<code>target/2</code>即可停止，但是这种方法时间复杂度较高，虽然能通过，但是不是最优的。更好的方式是使用滑动窗口加指针来实现，设立左右指针，从开始维护一个子数组作为窗口，判断该窗口求和是否为target，如果是则将结果存入，因为此时的连续序列是一个公差为1的等差数列，所以窗口的求和可以使用等差数列求和来计算。，如果小于target则窗口右移，大于target则窗口左移。</p>
<p><strong>复杂度：</strong></p>
<ul>
<li>时间复杂度：O(target)。滑动窗口最多位移<code>target/2</code>次。</li>
<li>空间复杂度：O(1)。排除必要的存储结果数组之外，只需要保存左右两个指针即可。</li>
</ul>
<h2 id="3-算法流程"><a href="#3-算法流程" class="headerlink" title="3. 算法流程"></a>3. 算法流程</h2><h3 id="3-1-思路一流程"><a href="#3-1-思路一流程" class="headerlink" title="3.1 思路一流程"></a>3.1 思路一流程</h3><ol>
<li>首先初始起始数和末位数，start = 1,end = 2。</li>
<li>当start&lt;=target/2时，继续遍历。累积求和当前值，sum +=  start。</li>
<li>枚举末位数，end=start+1开始，end&lt;=taregt。求和sum += end。</li>
<li>当sum == target，创建一个数组，长度为当前末位数减去起始数加一，然后把从起始数到末位数包括末位数遍历存入数组，再把该结果存入返回结果中。起始位加一重新遍历下一轮。</li>
<li>当sum &gt; target，起始数加一重新遍历。</li>
<li>当sum &lt; target，末位数加一继续遍历。</li>
</ol>
<h3 id="3-2-思路二流程"><a href="#3-2-思路二流程" class="headerlink" title="3.2 思路二流程"></a>3.2 思路二流程</h3><ol>
<li>首先初始化窗口，left=1 和 right=2。</li>
<li>当 left &lt; right 时始终维护该窗口，只有当到达边界位置时，窗口和 sum &gt; target，left 始终右移，才会结束窗口维护。</li>
<li>根据等差求和公式：<strong>和=(首项+尾)*项数 / 2</strong>，可得 <code>sum = (left + right) * (right - left + 1) / 2sum=(left+right)∗(right−left+1)/2 </code>可以直接算出滑动窗口和。</li>
<li>当 sum == target 时，将窗口放入结果数组中。</li>
<li>当 sum &lt; target 时，说明窗口结果需要变大，right++。</li>
<li>当 sum &gt; target 时，说明窗口结果需要变小，left++。</li>
</ol>
<h2 id="4-代码实现"><a href="#4-代码实现" class="headerlink" title="4. 代码实现"></a>4. 代码实现</h2><h3 id="4-1-思路一代码"><a href="#4-1-思路一代码" class="headerlink" title="4.1 思路一代码"></a>4.1 思路一代码</h3><p><strong>Java</strong>代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[][] findContinuousSequence(<span class="hljs-keyword">int</span> target) &#123;<br>    List&lt;<span class="hljs-keyword">int</span>[]&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">int</span> start = <span class="hljs-number">1</span>,end = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">while</span> (start &lt;= target/<span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-keyword">int</span> n = start;<br>        <span class="hljs-keyword">for</span> (end = start+<span class="hljs-number">1</span>;end&lt;=target;end++)&#123;<br>            n += end;<br>            <span class="hljs-keyword">if</span> (n == target)&#123;<br>                <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[end-start+<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,j=start; j&lt;=end; i++,j++)&#123;<br>                    arr[i] = j;<br>                &#125;<br>                res.add(arr);<br>                start++;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (n &gt; target)&#123;<br>                start++;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res.toArray(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[res.size()][]);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="4-2-思路二代码"><a href="#4-2-思路二代码" class="headerlink" title="4.2 思路二代码"></a>4.2 思路二代码</h3><p><strong>Java</strong>代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[][] findContinuousSequence(<span class="hljs-keyword">int</span> target)&#123;<br>    List&lt;<span class="hljs-keyword">int</span>[]&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">1</span>,right=<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">while</span> (left&lt;right)&#123;<br>        <span class="hljs-keyword">int</span> sum = (left + right) * (right - left + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (sum == target)&#123;<br>            <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[right-left+<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,j=left;j&lt;=right;i++,j++)&#123;<br>                arr[i] = j;<br>            &#125;<br>            res.add(arr);<br>            left++;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum &gt; target)&#123;<br>            left++;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            right++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res.toArray(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[res.size()][]);<br>&#125;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>数组-旋转数组中查找最小值</title>
    <url>/2021/12/20/minRotateArray/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每日一题，提升自己。今天分享一道关于旋转数组中查找最小值的题目，且听我细细道来。</p>
<span id="more"></span>

<h1 id="数组-旋转数组中查找最小值"><a href="#数组-旋转数组中查找最小值" class="headerlink" title="数组 - 旋转数组中查找最小值"></a>数组 - 旋转数组中查找最小值</h1><h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。</p>
<p><strong>示例：</strong></p>
<blockquote>
<p>示例1：</p>
<p>输入：[3,4,5,1,2]</p>
<p>输出：1</p>
<p>示例2：</p>
<p>输入：[2,2,2,0,1]</p>
<p>输出：0</p>
</blockquote>
<h2 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2. 解题思路"></a>2. 解题思路</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，数组是一个有序数组的旋转数组，从这个条件可以看出，输入的数组是有大小规律的，只是分成了两部分相同规律的。既然是有序数组，那么就可以使用二分查找利用存在的规律来查找结果。</p>
<p><strong>复杂度：</strong></p>
<ul>
<li>时间复杂度：O(logn)。</li>
<li>空间复杂度：O(1)。</li>
</ul>
<h2 id="3-算法流程"><a href="#3-算法流程" class="headerlink" title="3. 算法流程"></a>3. 算法流程</h2><ol>
<li>初始化下标 <code>left=0</code> 和 <code>right=nums.length-1</code>。当<code>left&lt;right</code>时，证明查找还没有结束。</li>
<li>每次计算中见下标 <code>mid = (right + left) / 2</code>，这里的除法时取整运算，不能出现小数。</li>
<li>当<code>nums[mid] &lt; nums[right]</code>时，说明最小值在<code>[left, mid]</code>区间中，则令<code>right = mid</code>，用于下一轮计算。</li>
<li>当 <code>nums[mid] &gt; nums[right]</code> 时，说明最小值在 <code>[mid, right] </code>区间中，则令 <code>left = mid + 1</code>，用于下一轮计算。</li>
<li>当 <code>nums[mid] == nums[right]</code> 时，无法判断最小值在哪个区间之中，此时让 <code>right--</code>，缩小区间范围，在下一轮进行判断。</li>
<li>最后返回<code>nums[left]</code>的值。</li>
</ol>
<blockquote>
<p>问：为什么是 <code>right--</code>缩小范围而不是<code>left++</code>？</p>
<p>答：因为数组是升序的额，所以最小值一定靠近左侧，而不是右侧。</p>
<p>比如，当存在 [1,2,2,2,2] 这种情况时，left = 0，right = 4，mid = 2，数值满足 numbers[mid] == numbers[right] 这个条件，如果 left++，则找不到最小值</p>
</blockquote>
<h2 id="4-代码实现"><a href="#4-代码实现" class="headerlink" title="4. 代码实现"></a>4. 代码实现</h2><p><strong>Java</strong>代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minRotateArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> left=<span class="hljs-number">0</span>,right= nums.length-<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt; right)&#123;<br>        <span class="hljs-keyword">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &lt; nums[right])&#123;<br>            right = mid;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; nums[right])&#123;<br>            left = mid;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            right--;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> nums[left];<br>&#125;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>数组-构建并打印数组</title>
    <url>/2021/12/22/printNumbers/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每日一题，提升自己。今天分享一道关于构建并打印数组的题目，且听我细细道来。</p>
<span id="more"></span>

<h1 id="数组-构建并打印数组"><a href="#数组-构建并打印数组" class="headerlink" title="数组 - 构建并打印数组"></a>数组 - 构建并打印数组</h1><h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p>
<p><strong>示例：</strong></p>
<blockquote>
<p>输入：n=1</p>
<p>输出：[1,2,3,4,5,6,7,8,9]</p>
</blockquote>
<p><strong>提示：</strong></p>
<blockquote>
<ol>
<li>用返回一个整数列表来代替打印。</li>
<li>n 为正整数。</li>
</ol>
</blockquote>
<h2 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2. 解题思路"></a>2. 解题思路</h2><h3 id="2-1-思路一"><a href="#2-1-思路一" class="headerlink" title="2.1 思路一"></a>2.1 思路一</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先根据输入的数字求出要打印的范围，然后再从1开始打印到最大的数字。</p>
<p><strong>复杂度：</strong></p>
<ul>
<li>时间复杂度：O(10^n)。</li>
<li>空间复杂度：O(10^n)。</li>
</ul>
<h3 id="2-2-思路二"><a href="#2-2-思路二" class="headerlink" title="2.2 思路二"></a>2.2 思路二</h3><p>本题的题意是希望考察大数的计算，因为int数组有可能会有益出，所以用字符串可以保证一定不会溢出。但是呢，由于规定的返回值是int数组，所以其实从返回值上来看，是一定不会溢出的，比较矛盾。这里给出思路二只是学习一下如何用字符串处理大数即可，不用特别纠结溢出这件事上。和思路一一样，先求出数字范围，然后从1开始打印到最大的数字，只不过这里用的是字符串去处理。</p>
<ul>
<li>时间复杂度：O(10^n)。</li>
<li>空间复杂度：O(10^n)。</li>
</ul>
<h2 id="3-算法流程"><a href="#3-算法流程" class="headerlink" title="3. 算法流程"></a>3. 算法流程</h2><h3 id="3-1-思路一流程"><a href="#3-1-思路一流程" class="headerlink" title="3.1 思路一流程"></a>3.1 思路一流程</h3><ol>
<li>初始化sum=1。</li>
<li>循环遍历乘10，让sum变为边界值。</li>
<li>新建res数组，长度大小为sum-1。</li>
<li>从1开始存入res，知道sum-1。</li>
</ol>
<h3 id="3-2-思路二流程"><a href="#3-2-思路二流程" class="headerlink" title="3.2 思路二流程"></a>3.2 思路二流程</h3><ol>
<li>初始化返回数组res，长度为最大值减一。</li>
<li>初始化字符串sb，使其初始值为n个”0”。</li>
<li>递增sb，使用字符去递增，递增过程中需要判断是否进位，存在进位则进位出加一，直到达到最大值为止，结束循环。</li>
<li>每次获取到一个值之后，遍历前方多余的”0”，将多余的”0”去掉，然后转换为int存到结果数组中。</li>
</ol>
<h2 id="4-代码实现"><a href="#4-代码实现" class="headerlink" title="4. 代码实现"></a>4. 代码实现</h2><h3 id="4-1-思路一代码"><a href="#4-1-思路一代码" class="headerlink" title="4.1 思路一代码"></a>4.1 思路一代码</h3><p><strong>Java</strong>代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] printNumbers(<span class="hljs-keyword">int</span> n)&#123;<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        sum *= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[sum - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;sum-<span class="hljs-number">1</span>; i++)&#123;<br>        res[i] = i + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="4-2-思路二代码"><a href="#4-2-思路二代码" class="headerlink" title="4.2 思路二代码"></a>4.2 思路二代码</h3><p><strong>Java</strong>代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] printNumbers_2(<span class="hljs-keyword">int</span> n)&#123;<br>    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[(<span class="hljs-keyword">int</span>)Math.pow(<span class="hljs-number">10</span>,n) - <span class="hljs-number">1</span>];<br>    StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>    <span class="hljs-comment">// 初始化字符串为n个&quot;0&quot;</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>        sb.append(<span class="hljs-string">&#x27;0&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (!increment(sb))&#123;<br>        <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (index&lt;sb.length() &amp;&amp; sb.charAt(index)==<span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>            index++;<br>        &#125;<br>        <span class="hljs-comment">// 从当前位置开始截取到最后，作为目标数存入</span><br>        res[count] = Integer.parseInt(sb.toString().substring(index));<br>        count++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">// 数字字符串加一的操作</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">increment</span><span class="hljs-params">(StringBuilder sb)</span></span>&#123;<br>    <span class="hljs-keyword">boolean</span> isCarry = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=sb.length()-<span class="hljs-number">1</span>; i&gt;=<span class="hljs-number">0</span>; i--)&#123;<br>        <span class="hljs-comment">// 数字字符+1</span><br>        <span class="hljs-keyword">char</span> s = (<span class="hljs-keyword">char</span>) (sb.charAt(i)+<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 判断是否进位</span><br>        <span class="hljs-keyword">if</span> (s&gt;<span class="hljs-string">&#x27;9&#x27;</span>)&#123;<br>            <span class="hljs-comment">// 进位则当前位置到最后替换成0</span><br>            sb.replace(i,i+<span class="hljs-number">1</span>,<span class="hljs-string">&quot;0&quot;</span>);<br>            <span class="hljs-comment">// 当前是否是第0个，是就不能进位</span><br>            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>)&#123;<br>                isCarry = <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 如果不进位，则当前位置到最后替换成加一后的字符</span><br>            sb.replace(i,i+<span class="hljs-number">1</span>,String.valueOf(s));<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-keyword">return</span> isCarry;<br>&#125;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>数组-构建数组</title>
    <url>/2021/12/14/constructArr/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每日一题，提升自己。今天分享一道关于数组构建的题目，且听我细细道来。</p>
<span id="more"></span>

<h1 id="数组-构建数组"><a href="#数组-构建数组" class="headerlink" title="数组 - 构建数组"></a>数组 - 构建数组</h1><h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B 中的元素 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。</p>
<p><strong>示例：</strong></p>
<blockquote>
<p>输入：[1,2,3,4,5]</p>
<p>输出：[120,60,40,30,24]</p>
</blockquote>
<p><strong>提示：</strong></p>
<blockquote>
<p>所有元素乘积之和不会溢出 32 位整数。</p>
<p>A.lengtn &lt;= 100000</p>
</blockquote>
<h2 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2. 解题思路"></a>2. 解题思路</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这道题如果可以用除法的话，那就很简单了，先遍历数组求出所有数的乘积，然后在依次除以每个位置对应的值即可。但是现在是不让使用除法，那么最简单的思路就是将<code>B[i]</code>每个位置都把所有需要的数乘一遍，这样可以解决问题，但是这样的问题就是所用的时间复杂度会非常高。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那怎么降低时间复杂度呢？方法将数组<code>B</code>每个位置的需要相乘的数构建成一个二维数组，然后以<code>A[i]</code>为界限，将其分割成左右三角形，其中每个三角形从<strong>尖部到底部</strong>都是可以累积的，这样上一次的计算结果就可以用于下一次的计算，大大减少了时间复杂度。具体见下图。</p>
<p><strong>复杂度：</strong></p>
<ul>
<li>时间复杂度：O(n)。因为左右三角形遍历求乘积的时间复杂度都是O(n)。</li>
<li>空间复杂度：O(1)。不将结果数组算入的话，只需要使用常量的工作空间。</li>
</ul>
<h2 id="3-算法流程"><a href="#3-算法流程" class="headerlink" title="3. 算法流程"></a>3. 算法流程</h2><ol>
<li>首先申请结果数组res。</li>
<li>求出左侧三角形从上到下的乘积值，并依次存入res[i]中。</li>
<li>求出右侧三角形从下到上的乘积值，并且和之前的res[i]做乘积存入，即可得到结果数组。</li>
</ol>
<p><img  src="image-20211217142156193.png"  ><span class="image-caption">计算左侧三角形</span></p>
<p><img  src="image-20211217142930181.png"  ><span class="image-caption">计算右侧三角形</span></p>
<h2 id="4-代码实现"><a href="#4-代码实现" class="headerlink" title="4. 代码实现"></a>4. 代码实现</h2><p><strong>Java</strong>代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] constructArr(<span class="hljs-keyword">int</span>[] a)&#123;<br>    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[a.length];<br>    <span class="hljs-comment">// 从上到下计算左下三角，见计算左侧三角形图</span><br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;a.length; i++)&#123;<br>        res[i] = left;<br>        left *= a[i];<br>    &#125;<br>    <span class="hljs-comment">// 从下到上计算右上三角并和之前的res[i]做乘积存入，见计算右侧三角形图</span><br>    <span class="hljs-keyword">int</span> right = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i= a.length-<span class="hljs-number">1</span>; i&gt;=<span class="hljs-number">0</span>; i--)&#123;<br>        res[i] *= right;<br>        right *= a[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器部署SSL证书</title>
    <url>/2019/10/06/server-SSL/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有时候项目需要服务器的协议是<code>https</code>协议，比如微信小程序的后台接口；这个时候就不得不把服务器协议修改为<code>https</code>。<code>https</code>和<code>http</code>有什么区别呢？区别就在于<code>https</code>比<code>http</code>多一个SSL证书，下面就是怎么获取SSL证书和怎么部署到服务器上。(唉，这也是当年自己踩了两个小时坑踩出来的啊！)</p>
<span id="more"></span>

<h1 id="服务器部署SSL证书"><a href="#服务器部署SSL证书" class="headerlink" title="服务器部署SSL证书"></a>服务器部署SSL证书</h1><h2 id="1-获取SSL证书"><a href="#1-获取SSL证书" class="headerlink" title="1. 获取SSL证书"></a>1. 获取SSL证书</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为当初我是服务器是在阿里云上租的，是<strong>Window Server</strong>所以SSL证书也是在阿里云上面获取的，当然，不要想着我会用钱去买这玩意，主要是太贵了，不过阿里云也算良心，能在上面免费获取一个一年的SSL证书。在这免费获取<a href="https://www.aliyun.com/product/cas?spm=5176.12825654.eofdhaal5.19.3dbd2c4ayD5k2Q&aly_as=nsmL9Pxx">阿里云SSL证书</a>，打开连接之后选择<strong>证书对比</strong>，里面有一个免费证书可以立即购买，阿里云免费证书是<em>Symantec</em>颁发的。购买之后在SSL证书控制台进行查看自己的证书，然后提交审核，有时很几分钟就审核完了，有时候要好几天，这就要看运气了。审核通过之后在SSL证书列表最后面点击下载，然后选择自己对应的服务器类型。下载下来的是一个压缩包。</p>
<h2 id="2-部署到Tomcat"><a href="#2-部署到Tomcat" class="headerlink" title="2. 部署到Tomcat"></a>2. 部署到Tomcat</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下载的压缩包里面有两个文件，一个是<code>.pfx</code>文件，这个就是我们的SSL证书；一个是<code>.txt</code>文件，这个是证书所对应的密码。此时SSL证书就到手了，接下来就可以进行部署了。将我们下载的证书部署到Tomcat上，首先需要通过Java jdk将<strong>pfx</strong>证书转换为<strong>jks</strong>证书，先将我们的<strong>prx</strong>证书放到jdk的bin目录下。然后通过cmd打开命令行窗口，进入到jdk的bin目录下，假设我们的证书是<strong>a.pfx</strong>，输入以下命令：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd">keytool -importkeystore -srckeystore a.pfx -destkeystore a.jks -srcstoretype PKCS12 -deststoretype JKS<br></code></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;回车后输入JKS证书密码和PFX证书密码，强烈推荐将JKS密码与PFX证书密码相同，否则可能会导致Tomcat启动失败。<br>运行截图如下：<br><img src="jks.png"></p>
<blockquote>
<p><strong>注意</strong>: pfx文件必须放到你的jdk的 bin目录下面哦，并且它生成的jks文件也会在此目录下面的哦。</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有了jks文件之后，下面就是对Tomcat的操作了，首先将刚刚获得的<strong>jks</strong>文件放到Tomcat的<strong>conf</strong>目录下，然后打开Tomcat的<strong>server.xml</strong>文件，也是在conf目录下，需要修改以下三个地方。<br>1.把</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;8080&quot;</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">&quot;HTTP/1.1&quot;</span> <span class="hljs-attr">address</span>=<span class="hljs-string">&quot;0.0.0.0&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">connectionTimeout</span>=<span class="hljs-string">&quot;20000&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">redirectPort</span>=<span class="hljs-string">&quot;8443&quot;</span>  /&gt;</span><br></code></pre></td></tr></table></figure>
<p>改成</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;80&quot;</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">&quot;HTTP/1.1&quot;</span> <span class="hljs-attr">address</span>=<span class="hljs-string">&quot;0.0.0.0&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">connectionTimeout</span>=<span class="hljs-string">&quot;20000&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">redirectPort</span>=<span class="hljs-string">&quot;443&quot;</span>  /&gt;</span><br></code></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中第一个80端口是为HTTP(HyperText Transport Protocol)即超文本传输协议开放的，此为上网冲浪使用次数最多的协议，第二个443端口是SSL的专用端口，HTTPS监听的端口是443端口。<br>2.把</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;8009&quot;</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">&quot;AJP/1.3&quot;</span> <span class="hljs-attr">redirectPort</span>=<span class="hljs-string">&quot;8443&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>
<p>改成</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;8009&quot;</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">&quot;AJP/1.3&quot;</span> <span class="hljs-attr">redirectPort</span>=<span class="hljs-string">&quot;443&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>
<p>使用443端口的理由同上。<br>3.把</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">&lt;Connector port=&quot;443&quot; protocol=&quot;org.apache.coyote.http11.Http11NioProtocol&quot;</span><br><span class="hljs-comment">               maxThreads=&quot;150&quot; SSLEnabled=&quot;true&quot;&gt;</span><br><span class="hljs-comment">        &lt;SSLHostConfig&gt;</span><br><span class="hljs-comment">            &lt;Certificate certificateKeystoreFile=&quot;conf/localhost-rsa.jks&quot;</span><br><span class="hljs-comment">                    type=&quot;RSA&quot; /&gt;</span><br><span class="hljs-comment">        &lt;/SSLHostConfig&gt;</span><br><span class="hljs-comment">    &lt;/Connector&gt;</span><br><span class="hljs-comment">--&gt;</span><br></code></pre></td></tr></table></figure>
<p>改成</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;443&quot;</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">&quot;org.apache.coyote.http11.Http11NioProtocol&quot;</span></span><br><span class="hljs-tag">               <span class="hljs-attr">maxThreads</span>=<span class="hljs-string">&quot;150&quot;</span> <span class="hljs-attr">SSLEnabled</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">SSLHostConfig</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Certificate</span> <span class="hljs-attr">certificateKeystoreFile</span>=<span class="hljs-string">&quot;conf/a.jks&quot;</span></span><br><span class="hljs-tag">                     <span class="hljs-attr">certificateKeystorePassword</span>=<span class="hljs-string">&quot;IBdiYc8W&quot;</span></span><br><span class="hljs-tag">                     <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;RSA&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">SSLHostConfig</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Connector</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先去掉注释，然后certificateKeystoreFile属性是让你告诉服务器需要哪个SSL证书，后面就填复制过去的那个jks文件的名字（记得带上jks后缀），然后加上certificateKeystorePassword这个属性，后面的属性值填秘钥。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;到这，关于server.xml文件的配置就完成了。</p>
<h2 id="3-部署到Nginx"><a href="#3-部署到Nginx" class="headerlink" title="3. 部署到Nginx"></a>3. 部署到Nginx</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在阿里云下载的压缩包里面有两个文件，一个是<code>.pem</code>文件，一个是<code>.key</code>文件。<a href="https://console.cloud.tencent.com/ssl/apply">腾讯云的免费证书</a>是<em>TrustAsia</em>颁发的，下载的压缩包里面有两个文件，一个是<code>.crt</code>文件，一个是<code>.key</code>文件。二者只是证书颁发商不同，实际都是可以满足需求的。这里选用的是阿里云申请的证书，进入到nginx的安装目录下，在<code>conf</code>目录下创建<code>cert</code>目录，然后将解压之后的文件放到该目录下。</p>
<p><img src="nginxSSL.png"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;打开<code>nginx.conf</code>配置文件，添加以下配置：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">server &#123;<br><br>        listen 443 ssl;  #新版本启用SSL功能。<br>    	# ssl on;   旧版本设置为on开启ssl功能<br>        server_name example.com;  # 替换成你的域名<br>        ssl_certificate cert/2837922_example.com.pem;   #替换成你的pem/crt文件名称<br>        ssl_certificate_key cert/2837922_example.com.key;   #替换成你的key文件名称<br>        ssl_session_timeout 5m;<br>        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;  #使用此加密套件。<br>        ssl_protocols TLSv1 TLSv1<span class="hljs-number">.1</span> TLSv1<span class="hljs-number">.2</span>;   #使用该协议进行配置。<br>        ssl_prefer_server_ciphers on;  <br><br><br>        # listen       <span class="hljs-number">80</span>;<br>        # server_name  localhost;<br><br>        #charset koi8-r;<br><br>        #access_log  logs/host.access.log  main;<br><br>        location / &#123;<br>            root   html;<br>            index  index.html index.htm;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后重启nginx服务器即可通过https访问服务器。</p>
<p>也可以使用全站加密，对于用户不知道网站可以进行 https 访问的情况下，让服务器自动把 http 的请求重定向到 https。在<code>nginx.conf</code>文件中添加以下配置：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">server &#123;<br>        listen       80;<br>        server_name  example.com;#替换成你的域名<br><br><br>        location / &#123;<br>            # 配置请求转发，将http的请求转发到https上面<br>            rewrite ^(.*)$ https:<span class="hljs-comment">//example.com/$1 permanent;#替换成你的域名</span><br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>



<h2 id="4-附加：开启SSL443端口"><a href="#4-附加：开启SSL443端口" class="headerlink" title="4. 附加：开启SSL443端口"></a>4. 附加：开启SSL443端口</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有时候我们完成以上工作之后，启动服务器依然没有办法访问到，这可能是因为云服务器的SSL端口没有打开。<br>1.打开”控制面板”–&gt;”系统和安全”–&gt;”Windows防火墙”</p>
<p>2.选择打开活关闭防火墙<br><img  src="1.png"   title="开启防火墙"><span class="image-caption">开启防火墙</span></p>
<p>3.启用Windows防火墙<br><img  src="2.png"   title="启用防火墙"><span class="image-caption">启用防火墙</span></p>
<p>4.选择”高级设置”<br><img  src="3.png"   title="高级设置"><span class="image-caption">高级设置</span></p>
<p>5.依次点击”入站规则”–&gt;”新建规则”</p>
<p>6.选择”端口”，然后”下一步”<br><img  src="4.png"   title="新建规则"><span class="image-caption">新建规则</span></p>
<p>7.选择”特定本地端口”，然后再后面的框中填入443(当然选择所有本地端口也可以开启443端口，但是端口全部开放可能会造成一定隐患，不建议)，然后”下一步”<br><img src="5.png"></p>
<p>8.选择”允许连接”，继续”下一步”<br><img src="6.png"></p>
<p>9.默认三个全部勾选，下一步<br><img src="7.png"></p>
<p>10.填写规则名称，建议填一个容易辨识的名字，描述可填可不填，点击完成<br><img src="8.png"></p>
<p>11.此时端口启用成功<br><img src="9.png"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;至此，所有配置和部署就已经全部完成了，接下来就可以通过<strong>https</strong>访问网站了。<br><img  src="10.png"  ><span class="image-caption">https访问</span></p>
]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派搭建Nextcloud私有云</title>
    <url>/2021/08/16/raspberry-nextcloud/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;距离树莓派入手时间已经半年多，由于时间问题，也一直没有部署过像样的东西，刚好最近入手了一块硬盘，所以就用树莓派加移动硬盘来搭建一个个人的私有云吧。这里以树莓派raspbain 10 buster系统为例，安装Nextcloud私有云。</p>
<h1 id="1-树莓派换源"><a href="#1-树莓派换源" class="headerlink" title="1. 树莓派换源"></a>1. 树莓派换源</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于国内环境，软件的下载安装相对比较慢，所以更换安装源来提高下载速度，更换下载源后更新软件的速度相对比较慢，其中很快做其他的事情，自行怎么方便怎么来。</p>
<h2 id="1-1-查看版本"><a href="#1-1-查看版本" class="headerlink" title="1.1 查看版本"></a>1.1 查看版本</h2><p>网上许多教程都不是基于最新的raspbain buster来进行更换的，这里需要注意一下，更换源之前先查看一下系统版本。</p>
<p><img src="%E6%9F%A5%E7%9C%8B%E7%89%88%E6%9C%AC.png"></p>
<h2 id="1-2-修改源"><a href="#1-2-修改源" class="headerlink" title="1.2 修改源"></a>1.2 修改源</h2><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 备份并编辑source.listwenjian </span><br>$ cp /etc/apt/sources.list /etc/apt/sources.back.list<br>$ vim /etc/apt/sources.list<br><span class="hljs-comment"># 注释所有内容，添加以下内容</span><br>deb http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main non-free contrib<br>deb-src http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main non-free contrib<br><br><br><span class="hljs-comment"># 备份并编辑raspi.list文件</span><br>$ cp /etc/apt/sources.list.d/raspi.list /etc/apt/sources.list.d/raspi.back.list<br>$ vim /etc/apt/sources.list.d/raspi.list<br><span class="hljs-comment"># 注释所有内容，替换如下内容</span><br>deb http://mirrors.tuna.tsinghua.edu.cn/raspberrypi/ buster main<br></code></pre></td></tr></table></figure>

<h2 id="1-3-更新源和软件"><a href="#1-3-更新源和软件" class="headerlink" title="1.3 更新源和软件"></a>1.3 更新源和软件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">sudo apt-get update<br>sudo apt-get upgrade -y<br></code></pre></td></tr></table></figure>

<blockquote>
<p>这个更新过程比较慢，建议这段时间可以到nextcloud官网中同时下载安装包，或进行其他不使用apt-get操作。</p>
</blockquote>
<h1 id="2-安装软件"><a href="#2-安装软件" class="headerlink" title="2. 安装软件"></a>2. 安装软件</h1><h2 id="2-1-安装apache"><a href="#2-1-安装apache" class="headerlink" title="2.1 安装apache"></a>2.1 安装apache</h2><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1.安装命令</span><br>sudo apt-get install apache2<br><br><span class="hljs-comment"># 2.启动apache2</span><br>systemctl start apache2<br><br><span class="hljs-comment"># 3.设置apache2开机自启</span><br>systemctl <span class="hljs-built_in">enable</span> apache2<br><br><span class="hljs-comment"># 附上其他命令</span><br><span class="hljs-comment"># 查看运行状态</span><br>systemctl status apache2<br><span class="hljs-comment"># 重启</span><br>systemctl restart apache2<br><span class="hljs-comment"># 停止</span><br>systemctl stop apache2<br></code></pre></td></tr></table></figure>

<h2 id="2-2-安装php"><a href="#2-2-安装php" class="headerlink" title="2.2 安装php"></a>2.2 安装php</h2><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1.安装php</span><br>sudo apt-get install php libapache2-mod-php -y<br><br><span class="hljs-comment"># 2.安装其他组件</span><br>sudo apt-get -y install php-fpm php-cli php-json php-curl php-imap php-gd php-mysql php-xml php-zip php-intl php-imagick php-mbstring -y<br></code></pre></td></tr></table></figure>

<h2 id="2-3-安装mariadb"><a href="#2-3-安装mariadb" class="headerlink" title="2.3 安装mariadb"></a>2.3 安装mariadb</h2><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1.安装</span><br>$ sudo apt-get install mariadb-server -y<br><br><span class="hljs-comment"># 2.开启远程登陆权限</span><br><span class="hljs-comment"># 2.1 切换目录</span><br>$ <span class="hljs-built_in">cd</span> /etc/mysql/mariadb.conf.d<br><span class="hljs-comment"># 2.2 找到修改权限的文件</span><br>$ grep -rn <span class="hljs-string">&quot;skip-networking&quot;</span> *<br><span class="hljs-comment"># 显示如下：在50-server.cnf文件的第26行</span><br>50-server.cnf:26:<span class="hljs-comment"># Instead of skip-networking the default is now to listen only on</span><br><span class="hljs-comment"># 2.3 编辑文件，注释掉  bind-address = 127.0.0.1</span><br>$ vim 50-server.cnf<br></code></pre></td></tr></table></figure>

<p>接下来是修改数据库配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 直接回车 不需要输入密码</span><br>$ mysql -uroot -p<br><br><span class="hljs-comment"># oc_admin可替换成自定义的用户名，password可替换成自定义的密码</span><br>&gt; create database nextcloud;<br>&gt; CREATE USER <span class="hljs-string">&#x27;oc_admin&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span> IDENTIFIED BY <span class="hljs-string">&#x27;password&#x27;</span>;<br>&gt; GRANT ALL PRIVILEGES ON *.* TO <span class="hljs-string">&#x27;oc_admin&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span> WITH GRANT OPTION;<br><br>&gt; flush privileges;<br>&gt; CREATE USER <span class="hljs-string">&#x27;oc_admin&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span> IDENTIFIED BY <span class="hljs-string">&#x27;password&#x27;</span>;<br>&gt; GRANT ALL PRIVILEGES ON *.* TO <span class="hljs-string">&#x27;oc_admin&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span> WITH GRANT OPTION;<br>&gt; flush privileges;<br></code></pre></td></tr></table></figure>

<h2 id="2-4-安装Nextcloud"><a href="#2-4-安装Nextcloud" class="headerlink" title="2.4 安装Nextcloud"></a>2.4 安装Nextcloud</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Nextcloud的安装包需要去官网进行下载，这里是<a href="https://nextcloud.com/install/#instructions-server">下载地址</a>。需要下载<code>tar.bz2</code>包。</p>
<p><img src="%E4%B8%8B%E8%BD%BDnextcloud.png"></p>
<p>下载完成后，需要上传到树莓派的<code>/var/www/html/</code>目录下。然后执行下面命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1.解压文件</span><br>tar jxf nextcloud-21.0.0.tar.bz2<br><span class="hljs-comment"># 2.添加data目录和授权</span><br>chown -R root:root nextcloud<br><span class="hljs-comment"># 3.进入nextcloud文件夹</span><br><span class="hljs-built_in">cd</span> nextcloud<br><span class="hljs-comment"># 4.创建数据文件夹</span><br>mkdir data<br><span class="hljs-comment"># 5.添加权限和授权</span><br>chown -R www-data:www-data data config apps<br></code></pre></td></tr></table></figure>

<h1 id="3-初始化Nextcloud"><a href="#3-初始化Nextcloud" class="headerlink" title="3. 初始化Nextcloud"></a>3. 初始化Nextcloud</h1><h2 id="3-1-初始化"><a href="#3-1-初始化" class="headerlink" title="3.1 初始化"></a>3.1 初始化</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;完成上面步骤，就可以进行初始化Nextcloud了，在电脑浏览器中输入地址：<code>树莓派ip:8080/nextcloud</code>。比如：<code>192.162.1.110:8080/nextcloud</code>。则可以打开nextcloud的登陆界面，选择用户名和密码，以及输入数据库用户名和密码，完成设置。如下：</p>
<p><img src="%E5%88%9D%E5%A7%8B%E5%8C%96nextcloud.png"></p>
<blockquote>
<p>关于数据目录，这里先默认选择<code>/var/www/html/nextcloud/data</code>。至于使用挂载目录，后面会讲到。如果想在初始化时就更换为挂载目录，可直接查看<a href="#guazai">挂载外设</a>。</p>
</blockquote>
<p>如果你的初始化出现下面错误，说创建数据库用户失败。这是因为在第一次初始化nextcloud的时候会在<code>/var/www/html/nextcloud/config</code>中创建一个config.php文件，文件记录nextcloud的配置信息。如果是第一次初始化，config.php中记录的数据库用户名会变成起初连接数据库的用户名加1。这里只需要手动的把1删除，之后再重新进行初始化操作，便可完成。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-string">&#x27;dbname&#x27;</span> =&gt; <span class="hljs-string">&#x27;nextcloud&#x27;</span>,<br><span class="hljs-string">&#x27;dbhost&#x27;</span> =&gt; <span class="hljs-string">&#x27;localhost:3306&#x27;</span>,<br><span class="hljs-string">&#x27;dbport&#x27;</span> =&gt; <span class="hljs-string">&#x27;&#x27;</span>,<br><span class="hljs-string">&#x27;dbtavleprefix&#x27;</span> =&gt; <span class="hljs-string">&#x27;oc_&#x27;</span>,<br><span class="hljs-string">&#x27;mysql.utf8mb4&#x27;</span> =&gt; <span class="hljs-literal">true</span>,<br><span class="hljs-string">&#x27;dbuser&#x27;</span> =&gt; <span class="hljs-string">&#x27;oc_admin1&#x27;</span>,<br></code></pre></td></tr></table></figure>

<p>如果登录出现不信任域名访问的错误，这是由于nextcloud的访问设置了白名单，所以在访问的时候需要添加白名单ip。编辑<code>config.php</code>文件，把要访问的ip或者域名添加进去。</p>
<p><img src="%E4%B8%8D%E4%BF%A1%E4%BB%BB%E5%9F%9F%E5%90%8D%E8%AE%BF%E9%97%AE.png"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ nano /var/www/html/nextcloud/config/config.php<br><span class="hljs-string">&#x27;trusted_domains&#x27;</span> =&gt; <br>  array (<br>    0 =&gt; <span class="hljs-string">&#x27;192.168.1.110:8080&#x27;</span>,<br>    1 =&gt; <span class="hljs-string">&#x27;xxx.com&#x27;</span>,<br>  ),<br></code></pre></td></tr></table></figure>

<p>之后再进行访问，就出现登陆页面，通过设置的用户名和密码进行登录即可。首页如下。</p>
<p><img src="%E9%A6%96%E9%A1%B5.png"></p>
<h2 id="3-2-其他配置"><a href="#3-2-其他配置" class="headerlink" title="3.2 其他配置"></a>3.2 其他配置</h2><h3 id="3-2-1-文件上传大小限制"><a href="#3-2-1-文件上传大小限制" class="headerlink" title="3.2.1 文件上传大小限制"></a>3.2.1 文件上传大小限制</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1.编辑php.ini文件</span><br>$ vim /etc/php/7.3/apache2/php.ini<br><span class="hljs-comment"># 2.找到相关属性，按照下方修改</span><br>upload_max_filesize = 16G<br>post_max_size = 16G<br>max_input_time 3600<br>max_execution_time 3600<br><br><span class="hljs-comment"># 3.解决浏览器超时问题</span><br>$ a2dismod reqtimeout<br><span class="hljs-comment"># 4.重启apache2</span><br>$ systemctl restart apache2<br></code></pre></td></tr></table></figure>

<p><span id="guazai"></span></p>
<h3 id="3-2-2-挂载外设"><a href="#3-2-2-挂载外设" class="headerlink" title="3.2.2 挂载外设"></a>3.2.2 挂载外设</h3><p>挂载外设有两种情况，一是直接将硬盘挂载到数据目录<code>data</code>下面；二是将硬盘挂载到其他目录，把数据目录更换成挂载的目录。</p>
<p><strong>1、硬盘挂载到数据目录<code>data</code>下面</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1.备份data数据</span><br>$ cp -r /var/www/html/nextcloud/data  /home/data<br><br><span class="hljs-comment"># 2.清空data目录</span><br>$ rm -v /var/www/html/nextcloud/data/*<br><br><span class="hljs-comment"># 3.查看接入的硬盘</span><br>$ fdisk -l<br>Device     Start        End    Sectors  Size Type<br>/dev/sda1     34      32767      32734   16M Microsoft reserved<br>/dev/sda2  32768 3907026943 3906994176  1.8T Microsoft basic data<br><br><span class="hljs-comment"># 4.查看硬盘的uuid和类型</span><br>$ blkid /dev/sda2<br>/dev/sda2: LABEL=<span class="hljs-string">&quot;pi&quot;</span> UUID=<span class="hljs-string">&quot;DBK3-5F1C&quot;</span> TYPE=<span class="hljs-string">&quot;exfat&quot;</span> PARTLABEL=<span class="hljs-string">&quot;Basic data partition&quot;</span> PARTUUID=<span class="hljs-string">&quot;51ejn2c4-f99f-46e5-a7cn-ca4m4e8db6bc&quot;</span><br> <span class="hljs-comment"># 5.挂载硬盘</span><br>$ mount -t exfat /dev/sda2 /var/www/html/nextcloud/data<br><span class="hljs-comment"># 取消挂载  umount /dev/sda2</span><br><br><span class="hljs-comment"># 6.开机自动挂载</span><br><span class="hljs-comment"># 6.1 编/etc/fstab文件 </span><br>$ vim /etc/fstab<br><span class="hljs-comment"># 6.2 添加以下内容，保存退出即可</span><br>UUID=<span class="hljs-string">&quot;DBK3-5F1C&quot;</span> /var/www/html/nextcloud/data exfat defaults,nofail 0 0<br><br><span class="hljs-comment"># 7.之后再将data文件夹下所有文件复制回来</span><br>$ cp -r  /home/data /var/www/html/nextcloud/data<br></code></pre></td></tr></table></figure>

<p><strong>2、硬盘挂载到其他目录</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1.创建挂载目录</span><br>$ mkdir /home/nextcloud<br><span class="hljs-comment"># 添加授权</span><br>chown -R root:root /home/nextcloud<br><br><span class="hljs-comment"># 2.挂载目录</span><br>$ mount -t exfat /dev/sda2  /home/nextcloud<br><br><span class="hljs-comment"># 3.开机自动挂载</span><br><span class="hljs-comment"># 3.1 编/etc/fstab文件 </span><br>$ vim /etc/fstab<br><span class="hljs-comment"># 3.2 添加以下内容，保存退出即可</span><br>UUID=<span class="hljs-string">&quot;DBK3-5F1C&quot;</span> /var/www/html/nextcloud/data exfat defaults,nofail 0 0<br><br><span class="hljs-comment"># 4.将data文件夹复制到挂载目录</span><br>$ cp -r /var/www/html/nextcloud/data/  /home/nextcloud/<br><br><span class="hljs-comment"># 5.修改nextcloud配置文件</span><br>$ vim /var/www/html/nextcloud/config/config.php<br><span class="hljs-comment"># 将数据目录更改</span><br><span class="hljs-string">&#x27;datadirectory&#x27;</span> =&gt; <span class="hljs-string">&#x27;/home/nextcloud/data&#x27;</span><br><br><span class="hljs-comment"># 6.重启apache2</span><br>$ systemctl restart apache2<br><br><span class="hljs-comment"># 7.如果访问时出现目录没有权限的情况，编辑nextcloud配置文件</span><br>$ vim /var/www/html/nextcloud/config/config.php<br><span class="hljs-comment"># 添加下面内容，保存重启apache2服务即可</span><br><span class="hljs-string">&#x27;check_data_directory_permissions&#x27;</span> =&gt; <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure>

<h1 id="4-性能优化"><a href="#4-性能优化" class="headerlink" title="4. 性能优化"></a>4. 性能优化</h1><h2 id="4-1-配置redis"><a href="#4-1-配置redis" class="headerlink" title="4.1 配置redis"></a>4.1 配置redis</h2><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1.安装redis</span><br>$ sudo apt-get install redis-server<br><br><span class="hljs-comment"># 2.修改redis配置</span><br>$ vim /etc/redis/redis.conf<br><span class="hljs-comment"># 修改daemonize 为 yes，取消以下内容的注释</span><br><span class="hljs-comment"># unixsocket /var/run/redis/redis-server.sock</span><br><span class="hljs-comment"># unixsocketperm 777</span><br><br><span class="hljs-comment"># 3.授权redis</span><br>$ usermod -g www-data redis<br>$ chown -R redis:www-data /var/run/redis<br>$ redis-server /etc/redis.conf<br><br><span class="hljs-comment"># 4.重启redis服务</span><br>$ service redis-server restart<br><br><span class="hljs-comment"># 5.安装apcu</span><br>$ sudo apt-get install php-apcu<br>$ sudo apt-get install php-redis<br><br><span class="hljs-comment"># 6.修改nextcloud的配置文件</span><br>$ vim /var/www/html/nextcloud/config/config.php<br><span class="hljs-comment"># 添加如下内容</span><br><span class="hljs-string">&#x27;memcache.local&#x27;</span> =&gt; <span class="hljs-string">&#x27;\OC\Memcache\APCu&#x27;</span>,<br><span class="hljs-string">&#x27;memcache.locking&#x27;</span> =&gt; <span class="hljs-string">&#x27;\OC\Memcache\Redis&#x27;</span>,<br><span class="hljs-string">&#x27;redis&#x27;</span> =&gt; <br>array (<br>    <span class="hljs-string">&#x27;host&#x27;</span> =&gt; <span class="hljs-string">&#x27;localhost&#x27;</span>,<br>    <span class="hljs-string">&#x27;port&#x27;</span> =&gt; 6379,<br>   ),<br>   <br><span class="hljs-comment"># 7.重启apache2服务</span><br>$ systemctl restart apache2<br></code></pre></td></tr></table></figure>

<h2 id="4-2-提高swap容量"><a href="#4-2-提高swap容量" class="headerlink" title="4.2 提高swap容量"></a>4.2 提高swap容量</h2><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1.修改配置文件</span><br>$ vim /etc/dphys-swapfile<br><span class="hljs-comment"># 修改字段CONF_SWPSIZE 值，默认为100，这里修改为 2048</span><br><br><span class="hljs-comment"># 2.重启swap</span><br>$ /etc/init.d/dphys-swapfile restart<br></code></pre></td></tr></table></figure>

<h2 id="4-3-提高sd卡速度"><a href="#4-3-提高sd卡速度" class="headerlink" title="4.3 提高sd卡速度"></a>4.3 提高sd卡速度</h2><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1.修改配置文件</span><br>$ sudo vim /boot/config.txt<br><span class="hljs-comment"># 加入下面一行内容</span><br>dtparam=sd_overclock=100<br><br><span class="hljs-comment"># 2.安装hdparm</span><br>$ hdparm -tT /dev/mmcblk0<br></code></pre></td></tr></table></figure>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以上就是用树莓派搭建Nextcloud私有云的具体步骤，用来当作笔记防止下次忘记，后续有什么新的功能在陆续添加。这次就到这了！</p>
]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>树莓派</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker部署应用</title>
    <url>/2020/04/20/docker-deployApp/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之前写过一篇关于<a href="/2019/11/11/docker-initUse/">Docker初使用</a>的笔记，简单介绍了Docker和基本使用。这里记录一下怎么将自己的项目打包成Docker镜像然后部署在服务器的Docker里。</p>
<span id="more"></span>

<h1 id="Docker部署应用"><a href="#Docker部署应用" class="headerlink" title="Docker部署应用"></a>Docker部署应用</h1><h2 id="1-制作镜像"><a href="#1-制作镜像" class="headerlink" title="1. 制作镜像"></a>1. 制作镜像</h2><h3 id="1-1-准备项目"><a href="#1-1-准备项目" class="headerlink" title="1.1 准备项目"></a>1.1 准备项目</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;打包镜像首先需要将自己的项目打包成jar包，我这里准备的是一个SpringBoot项目打包成的jar包。</p>
<h3 id="1-2-编写Dockerfile"><a href="#1-2-编写Dockerfile" class="headerlink" title="1.2 编写Dockerfile"></a>1.2 编写Dockerfile</h3><h4 id="1-2-1-关于Dockerfile"><a href="#1-2-1-关于Dockerfile" class="headerlink" title="1.2.1 关于Dockerfile"></a>1.2.1 关于Dockerfile</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dockerfile是一个包含用于组合映像的命令的文本文档。可以使用在命令行中调用任何命令。 Docker通过读取<code>Dockerfile</code>中的指令自动生成映像。一般包含四部分：基础镜像信息、维护者信息、镜像操作指令和容器启动时执行指令。Docker以从上到下的顺序运行Dockerfile的指令。为了指定基本映像，第一条指令必须是<em><strong>FROM</strong></em>。一个声明以<code>＃</code>字符开头则被视为注释。可以在Docker文件中使用<code>RUN</code>，<code>CMD</code>，<code>FROM</code>，<code>EXPOSE</code>，<code>ENV</code>等指令。</p>
<h4 id="1-2-2-演示文件"><a href="#1-2-2-演示文件" class="headerlink" title="1.2.2 演示文件"></a>1.2.2 演示文件</h4><p>这次演示的Dockerfile文件内容如下：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># This my first testapp Dockerfile</span><br><span class="hljs-comment"># Version 1.0</span><br><br><span class="hljs-comment"># Base images 基础镜像</span><br><span class="hljs-keyword">FROM</span> java:<span class="hljs-number">8</span><br><span class="hljs-comment"># 挂载目录</span><br><span class="hljs-keyword">VOLUME</span><span class="bash"> /tmp</span><br><span class="hljs-comment"># 文件放在当前目录下，拷过去会自动解压</span><br><span class="hljs-keyword">ADD</span><span class="bash"> testapp-0.0.1-SNAPSHOT.jar /app.jar</span><br><span class="hljs-comment"># 配置容器，使其可执行化。配合CMD可省去&quot;application&quot;，只使用参数。</span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="bash"> [<span class="hljs-string">&quot;java&quot;</span>,<span class="hljs-string">&quot;-Djava.security.edg=file:/dev/./urandom&quot;</span>,<span class="hljs-string">&quot;-jar&quot;</span>,<span class="hljs-string">&quot;/app.jar&quot;</span>]</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p><strong>#</strong> ： 为 Dockerfile 中的注释。</p>
</blockquote>
<h4 id="1-2-3-Dockerfile详解"><a href="#1-2-3-Dockerfile详解" class="headerlink" title="1.2.3 Dockerfile详解"></a>1.2.3 Dockerfile详解</h4><ul>
<li><strong>FROM</strong>：指定基础镜像，需要在哪个镜像建立。必须为第一个命令。</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 格式</span><br>　　<span class="hljs-keyword">FROM</span> &lt;image&gt;<br>　　<span class="hljs-keyword">FROM</span> &lt;image&gt;:&lt;tag&gt;<br>　　<span class="hljs-keyword">FROM</span> &lt;image&gt;@&lt;digest&gt;<br><span class="hljs-comment"># 示例</span><br>   <span class="hljs-keyword">FROM</span> mysql：<span class="hljs-number">5.6</span><br><span class="hljs-comment"># 提示</span><br>   tag或digest是可选的，如果不使用这两个值时，会使用latest版本的基础镜像<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>MAINTAINER</strong>：指定维护者信息。</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 格式</span><br>   <span class="hljs-keyword">MAINTAINER</span> &lt;name&gt;<br><span class="hljs-comment"># 示例</span><br>   <span class="hljs-keyword">MAINTAINER</span> byFan<br>   <span class="hljs-keyword">MAINTAINER</span> byfanx@<span class="hljs-number">163</span>.com<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>RUN</strong>：构建镜像时执行的命令。</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">RUN</span><span class="bash">用于在镜像容器中执行命令，其有以下两种命令执行方式：</span><br><span class="hljs-keyword">shell</span><span class="bash">执行</span><br><span class="hljs-comment"># 格式</span><br>   <span class="hljs-keyword">RUN</span><span class="bash"> &lt;<span class="hljs-built_in">command</span>&gt;</span><br><span class="hljs-comment"># 示例</span><br>   <span class="hljs-keyword">RUN</span><span class="bash"> apk update</span><br>   <br>exec执行<br><span class="hljs-comment"># 格式</span><br>   <span class="hljs-keyword">RUN</span><span class="bash"> [<span class="hljs-string">&quot;executable&quot;</span>, <span class="hljs-string">&quot;param1&quot;</span>, <span class="hljs-string">&quot;param2&quot;</span>]</span><br><span class="hljs-comment"># 示例</span><br>   <span class="hljs-keyword">RUN</span><span class="bash"> [<span class="hljs-string">&quot;/bin/bash&quot;</span>,<span class="hljs-string">&quot;-c&quot;</span>,<span class="hljs-string">&quot;echo hello&quot;</span>]</span><br><span class="hljs-comment"># 提示</span><br>   <span class="hljs-keyword">RUN</span><span class="bash">指令创建的中间镜像会被缓存，并会在下次构建中使用。如果不想使用这些缓存镜像，可以在构建时指定--no-cache参数，如：docker build --no-cache</span><br></code></pre></td></tr></table></figure>

<ul>
<li><strong>WORKDIR</strong>：指定当前工作目录，相当于 <code>cd</code>。</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 格式</span><br>   <span class="hljs-keyword">WORKDIR</span><span class="bash"> /path/to/workdir</span><br><span class="hljs-comment"># 示例</span><br>   <span class="hljs-keyword">WORKDIR</span><span class="bash"> /a  (这时工作目录为/a)</span><br>   <span class="hljs-keyword">WORKDIR</span><span class="bash"> b  (这时工作目录为/a/b)</span><br>   <span class="hljs-keyword">WORKDIR</span><span class="bash"> c  (这时工作目录为/a/b/c)</span><br><span class="hljs-comment"># 提示</span><br>   通过<span class="hljs-keyword">WORKDIR</span><span class="bash">设置工作目录后，Dockerfile中其后的命令RUN、CMD、ENTRYPOINT、ADD、COPY等命令都会在该目录下执行。在使用docker run运行容器时，可以通过-w参数覆盖构建时所设置的工作目录。</span><br></code></pre></td></tr></table></figure>

<ul>
<li><strong>EXPOSE</strong>：指定容器要打开的端口。</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 格式</span><br>   <span class="hljs-keyword">EXPOSE</span> &lt;port&gt; [&lt;port&gt;...]<br><span class="hljs-comment"># 示例</span><br>   <span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">80</span> <span class="hljs-number">443</span><br>   <span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">11211</span>/tcp<br><span class="hljs-comment"># 提示</span><br>   <span class="hljs-keyword">EXPOSE</span>并不会让容器的端口访问到主机。要使其可访问，需要在docker <span class="hljs-keyword">run</span><span class="bash">运行容器时通过-p来发布这些端口，或通过-P参数来发布EXPOSE导出的所有端口</span><br></code></pre></td></tr></table></figure>

<ul>
<li><strong>ENV</strong>：定义环境变量</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 格式</span><br>   <span class="hljs-keyword">ENV</span> &lt;key&gt; &lt;value&gt;    <span class="hljs-comment"># 会被后续 RUN 指令使用，并在容器运行时保持。&lt;key&gt;之后的所有内容均会被视为其&lt;value&gt;的组成部分，因此，一次只能设置一个变量</span><br>   <span class="hljs-keyword">ENV</span> &lt;key&gt;=&lt;value&gt; ...   <span class="hljs-comment"># 可以设置多个变量，每个变量为一个&quot;&lt;key&gt;=&lt;value&gt;&quot;的键值对，如果&lt;key&gt;中包含空格，可以使用\来进行转义，也可以通过&quot;&quot;来进行标示；另外，反斜线也可以用于续行</span><br><span class="hljs-comment"># 示例</span><br>   <span class="hljs-keyword">ENV</span> myName byFan<br>   <span class="hljs-keyword">ENV</span> mySex Man<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>ADD</strong>：将本地文件添加到容器中，tar类型文件会自动解压(网络压缩资源不会被解压)，可以访问网络资源，类似wget。</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 格式</span><br>   <span class="hljs-keyword">ADD</span><span class="bash"> &lt;src&gt; &lt;dest&gt;</span><br>   <span class="hljs-keyword">ADD</span><span class="bash"> [<span class="hljs-string">&quot;&lt;src&gt;&quot;</span>,<span class="hljs-string">&quot;&lt;dest&gt;&quot;</span>]  <span class="hljs-comment"># 用于支持包含空格的路径</span></span><br><span class="hljs-comment"># 示例</span><br>   <span class="hljs-keyword">ADD</span><span class="bash"> hom* /mydir/         <span class="hljs-comment"># 添加所有以&quot;hom&quot;开头的文件</span></span><br>    <span class="hljs-keyword">ADD</span><span class="bash"> hom?.txt /mydir/    <span class="hljs-comment"># ? 替代一个单字符,例如：&quot;home.txt&quot;</span></span><br>    <span class="hljs-keyword">ADD</span><span class="bash"> <span class="hljs-built_in">test</span> relativeDir/   <span class="hljs-comment"># 添加 &quot;test&quot; 到 `WORKDIR`/relativeDir/</span></span><br>    <span class="hljs-keyword">ADD</span><span class="bash"> <span class="hljs-built_in">test</span> /absoluteDir/  <span class="hljs-comment"># 添加 &quot;test&quot; 到 /absoluteDir/</span></span><br></code></pre></td></tr></table></figure>

<ul>
<li><strong>COPY</strong>：复制本地主机的 （为 Dockerfile 所在目录的相对路径）到容器中的。功能类似ADD，但是是不会自动解压文件，也不能访问网络资源。</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 格式</span><br>   <span class="hljs-keyword">COPY</span><span class="bash"> &lt;src&gt; &lt;dest&gt;</span><br>   <span class="hljs-keyword">COPY</span><span class="bash"> [<span class="hljs-string">&quot;&lt;src&gt;&quot;</span>,<span class="hljs-string">&quot;&lt;dest&gt;&quot;</span>]  <span class="hljs-comment"># 用于支持包含空格的路径</span></span><br><span class="hljs-comment"># 示例</span><br>   <span class="hljs-keyword">COPY</span><span class="bash"> test.txt /tmp</span><br></code></pre></td></tr></table></figure>

<ul>
<li><strong>VOLUME</strong>：挂载目录，创建一个可以从本地主机或其他容器挂载的挂载点，一般用来存放数据库和需要保持的数据等。</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 格式</span><br>   <span class="hljs-keyword">VOLUME</span><span class="bash"> [<span class="hljs-string">&quot;/path/to/dir&quot;</span>]</span><br><span class="hljs-comment"># 示例</span><br>   <span class="hljs-keyword">VOLUME</span><span class="bash"> [<span class="hljs-string">&quot;/data&quot;</span>]</span><br>   <span class="hljs-keyword">VOLUME</span><span class="bash"> [<span class="hljs-string">&quot;/var/www&quot;</span>, <span class="hljs-string">&quot;/var/log/apache2&quot;</span>, <span class="hljs-string">&quot;/etc/apache2&quot;</span></span><br><span class="hljs-comment"># 提示</span><br>   一个卷可以存在于一个或多个容器的指定目录，该目录可以绕过联合文件系统，并具有以下功能：<br>   (<span class="hljs-number">1</span>) 卷可以容器间共享和重用<br>   (<span class="hljs-number">2</span>) 容器并不一定要和其它容器共享卷<br>   (<span class="hljs-number">3</span>) 修改卷后会立即生效<br>   (<span class="hljs-number">4</span>) 对卷的修改不会对镜像产生影响<br>   (<span class="hljs-number">5</span>) 卷会一直存在，直到没有任何容器在使用它<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>USER</strong>：指定运行容器时的用户名或 UID，后续的 RUN 也会使用指定用户。使用USER指定用户时，可以使用用户名、UID或GID，或是两者的组合。当服务不需要管理员权限时，可以通过该命令指定运行用户。并且可以在之前创建所需要的用户。</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 格式</span><br>   <span class="hljs-keyword">USER</span> <span class="hljs-keyword">user</span><br>　　<span class="hljs-keyword">USER</span> <span class="hljs-keyword">user</span>:group<br>　　<span class="hljs-keyword">USER</span> uid<br>　　<span class="hljs-keyword">USER</span> uid:gid<br>　　<span class="hljs-keyword">USER</span> <span class="hljs-keyword">user</span>:gid<br>　　<span class="hljs-keyword">USER</span> uid:group<br><span class="hljs-comment"># 示例</span><br>   <span class="hljs-keyword">USER</span> byfan<br><span class="hljs-comment"># 提示</span><br>   使用<span class="hljs-keyword">USER</span>指定用户后，Dockerfile中其后的命令<span class="hljs-keyword">RUN</span><span class="bash">、CMD、ENTRYPOINT都将使用该用户。镜像构建完成后，通过docker run运行容器时，可以通过-u参数来覆盖所指定的用户。</span><br></code></pre></td></tr></table></figure>

<ul>
<li><strong>ENTRYPOINT</strong>：配置容器，使其可执行化。配合CMD可省去”application”，只使用参数。</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 格式</span><br>   <span class="hljs-keyword">ENTRYPOINT</span><span class="bash"> [<span class="hljs-string">&quot;executable&quot;</span>, <span class="hljs-string">&quot;param1&quot;</span>, <span class="hljs-string">&quot;param2&quot;</span>]   <span class="hljs-comment"># (可执行文件, 优先)</span></span><br>    <span class="hljs-keyword">ENTRYPOINT</span><span class="bash"> <span class="hljs-built_in">command</span> param1 param2   <span class="hljs-comment"># (shell内部命令)</span></span><br><span class="hljs-comment"># 示例</span><br>   <span class="hljs-keyword">FROM</span> ubuntu<br>   <span class="hljs-keyword">ENTRYPOINT</span><span class="bash"> [<span class="hljs-string">&quot;top&quot;</span>,<span class="hljs-string">&quot;-b&quot;</span>]</span><br>   <span class="hljs-keyword">CMD</span><span class="bash"> [<span class="hljs-string">&quot;-c&quot;</span>]</span><br><span class="hljs-comment"># 提示</span><br>   <span class="hljs-keyword">ENTRYPOINT</span><span class="bash">与CMD非常类似，不同的是通过docker run执行的命令不会覆盖ENTRYPOINT，而docker run命令中指定的任何参数，都会被当做参数再次传递给ENTRYPOINT。Dockerfile中只允许有一个ENTRYPOINT命令，多指定时会覆盖前面的设置，而只执行最后的ENTRYPOINT指令。</span><br></code></pre></td></tr></table></figure>

<ul>
<li><strong>CMD</strong>：构建容器后调用，也就是在容器启动时才进行调用。</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 格式</span><br>   <span class="hljs-keyword">CMD</span><span class="bash"> [<span class="hljs-string">&quot;executable&quot;</span>,<span class="hljs-string">&quot;param1&quot;</span>,<span class="hljs-string">&quot;param2&quot;</span>]   <span class="hljs-comment"># (执行可执行文件，优先)</span></span><br>    <span class="hljs-keyword">CMD</span><span class="bash"> [<span class="hljs-string">&quot;param1&quot;</span>,<span class="hljs-string">&quot;param2&quot;</span>]   <span class="hljs-comment"># (设置了ENTRYPOINT，则直接调用ENTRYPOINT添加参数)</span></span><br>    <span class="hljs-keyword">CMD</span><span class="bash"> <span class="hljs-built_in">command</span> param1 param2   <span class="hljs-comment"># (执行shell内部命令)</span></span><br><span class="hljs-comment"># 示例</span><br>   <span class="hljs-keyword">CMD</span><span class="bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;This is a test.&quot;</span> | wc -</span><br>   <span class="hljs-keyword">CMD</span><span class="bash"> [<span class="hljs-string">&quot;/usr/bin/wc&quot;</span>,<span class="hljs-string">&quot;--help&quot;</span>]</span><br><span class="hljs-comment"># 提示</span><br>   <span class="hljs-keyword">CMD</span><span class="bash">不同于RUN，CMD用于指定在容器启动时所要执行的命令，而RUN用于指定镜像构建时所要执行的命令。每个 Dockerfile 只能有一条 CMD 命令。如果指定了多条命令，只有最后一条会被执行。如果用户启动容器时候指定了运行的命令，则会覆盖掉 CMD 指定的命令。</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>ENTRYPOINT 和 CMD 的区别：ENTRYPOINT 指定了该镜像启动时的入口，CMD 则指定了容器启动时的命令，当两者共用时，完整的启动命令像是 ENTRYPOINT + CMD 这样。使用 ENTRYPOINT 的好处是在我们启动镜像就像是启动了一个可执行程序，在 CMD 上仅需要指定参数；另外在我们需要自定义 CMD 时不容易出错。</p>
<p>可以使用以下命令覆盖默认的参数，方便调试 Dockerfile 中的 bug：</p>
<p><code>docker run -it --entrypoint=/bin/dockerfile feiyu/entrypoint:1</code></p>
</blockquote>
<ul>
<li><strong>ONBUILD</strong>：用于设置镜像触发器。</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 格式</span><br>   <span class="hljs-keyword">ONBUILD</span> [INSTRUCTION]<br><span class="hljs-comment"># 示例</span><br>   <span class="hljs-keyword">ONBUILD</span> <span class="hljs-keyword">ADD</span><span class="bash"> . /app/src</span><br>　　<span class="hljs-keyword">ONBUILD</span> <span class="hljs-keyword">RUN</span><span class="bash"> /usr/<span class="hljs-built_in">local</span>/bin/python-build --dir /app/src</span><br><span class="hljs-comment"># 提示</span><br>   在构建本镜像时不生效，在基于此镜像构建镜像时生效。<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>LABLE</strong>：用于为镜像添加元数据。</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 格式</span><br>   <span class="hljs-keyword">LABEL</span><span class="bash"> &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</span><br><span class="hljs-comment"># 示例</span><br>   <span class="hljs-keyword">LABEL</span><span class="bash"> version=<span class="hljs-string">&quot;1.0&quot;</span> description=<span class="hljs-string">&quot;这是一个Web服务器&quot;</span> by=<span class="hljs-string">&quot;IT笔录&quot;</span></span><br><span class="hljs-comment"># 提示</span><br>   使用<span class="hljs-keyword">LABEL</span><span class="bash">指定元数据时，一条LABEL指定可以指定一或多条元数据，指定多条元数据时不同元数据之间通过空格分隔。推荐将所有的元数据通过一条LABEL指令指定，以免生成过多的中间镜像。</span><br></code></pre></td></tr></table></figure>

<ul>
<li><strong>ARG</strong>：用于指定传递给构建运行时的变量。</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 格式</span><br>   <span class="hljs-keyword">ARG</span> &lt;name&gt;[=&lt;default value&gt;]<br><span class="hljs-comment"># 示例</span><br>   <span class="hljs-keyword">ARG</span> site<br>   <span class="hljs-keyword">ARG</span> build_user=www<br></code></pre></td></tr></table></figure>

<h3 id="1-3-创建镜像"><a href="#1-3-创建镜像" class="headerlink" title="1.3 创建镜像"></a>1.3 创建镜像</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将准备好的项目jar包和Dockerfile文件上传到你的Linux服务器的同一目录下。然后执行下面命令来创建一个镜像。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">docker build -t testapp:1.0 .<br></code></pre></td></tr></table></figure>

<blockquote>
<p><strong>-t</strong>：指定镜像名字和TAG。</p>
<p><strong>注意</strong>：这里最后面有一个 ’   <strong>.</strong>   ‘，代表的是Dockerfile文件所在的路径(当前目录)，也可以替换为一个具体的Dockerfile的路径。</p>
</blockquote>
<p>然后就可以看到下面的执行过程。</p>
<p><img src="image-20200421115234434.png"></p>
<p>接下来通过<code>docker images</code>命令进行查看，就可以看到我们刚刚创建的镜像。</p>
<p><img src="image-20200421115653201.png"></p>
<h3 id="1-4-运行项目"><a href="#1-4-运行项目" class="headerlink" title="1.4 运行项目"></a>1.4 运行项目</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;运行项目就是通过刚刚我们制作的镜像来创建一个容器，然后进行运行，运行成功返回容器的id。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">docker run -d -p 8080:8080  --name testApp testapp:1.0<br></code></pre></td></tr></table></figure>

<blockquote>
<p><strong>-d：</strong>标识是让docker容器在后台运行。</p>
<p><strong>-p：</strong>标识端口映射，前面是主机对外服务端口，后面是映射到docker容器的端口。</p>
<p><strong>–name：</strong>定义一个容器的名字，方便后面执行操作。如果没有指定name，那么deamon会自动生成一个随机数字符串当作UUID。</p>
<p>最后一个是你创建容器使用的镜像名称和TAG。</p>
</blockquote>
<p>然后就可以运行<code>docker ps -a</code>命令进行查看运行的容器了。</p>
<h2 id="2-部署Nginx"><a href="#2-部署Nginx" class="headerlink" title="2. 部署Nginx"></a>2. 部署Nginx</h2><h3 id="2-1-拉取Nginx镜像"><a href="#2-1-拉取Nginx镜像" class="headerlink" title="2.1 拉取Nginx镜像"></a>2.1 拉取Nginx镜像</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;拉取当前最新的Nginx的镜像。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">docker pull nginx<br></code></pre></td></tr></table></figure>

<h3 id="2-2-运行Nginx"><a href="#2-2-运行Nginx" class="headerlink" title="2.2 运行Nginx"></a>2.2 运行Nginx</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据刚刚拉取下来的nginx镜像，运行一个容器。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">docker run -d -p 80:80 --name nginxV1 nginx<br></code></pre></td></tr></table></figure>

<p>这样nginx服务器就运行完成了，就可以进行访问了。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为要对容器内部的配置文件进行编辑，而容器内部是没有<code>vim</code>编辑器的，可以下载一个，但是每次配置都学要进入到容器内部操作。显得太麻烦。也可以使用目录挂载的形式。首先创建本地目录，用于存放Nginx容器的相关文件信息。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">mkdir -p /home/nginx/html /home/nginx/logs /home/nginx/conf<br></code></pre></td></tr></table></figure>

<blockquote>
<p><strong>-p</strong>：确保目录名称存在，不存在的就建一个。</p>
</blockquote>
<p>其中：</p>
<ul>
<li>html：目录将映射为nginx容器配置的虚拟目录。</li>
<li>logs：目录将映射为nginx容器目录的日志内容。</li>
<li>conf：目录里的配置文件将映射为nginx容器的配置文件。</li>
</ul>
<p>将nginxV1容器内nginx默认的配置文件拷贝到当前目录下的conf目录。也可以通过容器id进行复制，容器id可以通过<code>docker ps -a</code>命令进行查看。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">docker cp nginxV1:/etc/nginx/nginx.conf /home/nginx/conf/<br></code></pre></td></tr></table></figure>

<p>然后进行部署:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">docker run -d -p 80:80 --name nginxV2 -v /home/nginx/html:/usr/share/nginx/html -v /home/nginx/logs:/var/log/nginx -v /home/nginx/conf/nginx.conf:/etc/nginx/nginx.conf nginx<br></code></pre></td></tr></table></figure>

<blockquote>
<p><strong>-v /home/nginx/www:/usr/share/nginx/html</strong>：将我们自己创建的 www 目录挂载到容器的 /usr/share/nginx/html。</p>
<p><strong>-v /home/nginx/conf/nginx.conf:/etc/nginx/nginx.conf</strong>：将我们自己创建的 nginx.conf 挂载到容器的 /etc/nginx/nginx.conf。</p>
<p><strong>-v /home/nginx/logs:/var/log/nginx</strong>：将我们自己创建的 logs 挂载到容器的 /var/log/nginx。</p>
</blockquote>
<p>启动成功之后，就可以在本地配置我们的nginx.conf了，配置好之后重新启动容器即可生效。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">docker restart nginx<br></code></pre></td></tr></table></figure>

<p>在nginx原来的配置文件中，它的<code>server</code>块没有直接写在nginx.conf里，而是通过<code>include /etc/nginx/conf.d/*.conf;</code>引入的。在容器的<code>/etc/nginx/conf.d/</code>目录下，有一个<code>default.conf</code>文件，进入容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">docker exec -it nginxV2 /bin/bash<br></code></pre></td></tr></table></figure>

<blockquote>
<p>上述操作也可以将容器名替换成容器id，退出容器时执行<strong>exit</strong>就行。</p>
</blockquote>
<p>查看<code>default.conf</code>文件内容如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">server &#123;<br>    listen       80;<br>    server_name  localhost;<br><br>    #charset koi8-r;<br>    #access_log  /var/log/nginx/host.access.log  main;<br><br>    location / &#123;<br>        root   /usr/share/nginx/html;<br>        index  index.html index.htm;<br>    &#125;<br><br>    #error_page  <span class="hljs-number">404</span>              /<span class="hljs-number">404.</span>html;<br><br>    # redirect server error pages to the static page /<span class="hljs-number">50</span>x.html<br>    #<br>    error_page   <span class="hljs-number">500</span> <span class="hljs-number">502</span> <span class="hljs-number">503</span> <span class="hljs-number">504</span>  /<span class="hljs-number">50</span>x.html;<br>    location = /<span class="hljs-number">50</span>x.html &#123;<br>        root   /usr/share/nginx/html;<br>    &#125;<br><br>    # proxy the PHP scripts to Apache listening on <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">80</span><br>    #<br>    #location ~ \.php$ &#123;<br>    #    proxy_pass   http:<span class="hljs-comment">//127.0.0.1;</span><br>    #&#125;<br><br>    # pass the PHP scripts to FastCGI server listening on <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">9000</span><br>    #<br>    #location ~ \.php$ &#123;<br>    #    root           html;<br>    #    fastcgi_pass   127.0.0.1:<span class="hljs-number">9000</span>;<br>    #    fastcgi_index  index.php;<br>    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;<br>    #    include        fastcgi_params;<br>    #&#125;<br><br>    # deny access to .htaccess files, if Apache&#x27;s document root<br>    # concurs with nginx&#x27;s one<br>    #<br>    #location ~ /\.ht &#123;<br>    #    deny  all;<br>    #&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到这里就是一个<code>server</code>块。如果不使用想外部引入，那么就可以把上面nginx.conf文件中的<code>include</code>那一句给去掉，然后直接在nginx.conf里进行<code>server</code>块的配置。每次重新配置完nginx.conf文件之后，都需要重启容器。</p>
<h3 id="2-4-部署SSL证书"><a href="#2-4-部署SSL证书" class="headerlink" title="2.4 部署SSL证书"></a>2.4 部署SSL证书</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先获取SSL证书，<a href="https://www.aliyun.com/product/cas?spm=5176.12825654.eofdhaal5.19.3dbd2c4ayD5k2Q&aly_as=nsmL9Pxx">阿里云免费证书</a>是<em>Symantec</em>颁发的，下载的压缩包里面有两个文件，一个是<code>.pem</code>文件，一个是<code>.key</code>文件。<a href="https://console.cloud.tencent.com/ssl/apply">腾讯云的免费证书</a>是<em>TrustAsia</em>颁发的，下载的压缩包里面有两个文件，一个是<code>.crt</code>文件，一个是<code>.key</code>文件。二者只是证书颁发商不同，实际都是可以满足需求的。这里选用腾讯云申请的证书。因为我们之前启动容器时只映射了80端口，而<code>https</code>默认的时443端口，所以我们现在重新启动一个容器。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">docker run -d -p 80:80 -p 443:443 --name nginxV3 -v /home/nginx/html:/usr/share/nginx/html -v /home/nginx/logs:/var/log/nginx -v /home/nginx/conf/nginx.conf:/etc/nginx/nginx.conf nginx<br></code></pre></td></tr></table></figure>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先将下载到的两个证书文件上传到Linux服务器，然后在nginx配置文件目录下创建<code>cert</code>目录，将证书文件放到该目录下。然后将存放证书文件的目录复制到容器中存放nginx配置文件的目录下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">docker cp /home/nginx/conf/cert nginxV3:/etc/nginx/<br></code></pre></td></tr></table></figure>

<p>然后修改配置文件。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">server &#123;<br><br>        listen 443 ssl;  #新版本启用SSL功能。<br>    	# ssl on;   旧版本设置为on开启ssl功能<br>        server_name example.com;  # 替换成你的域名<br>        ssl_certificate cert/example.com.crt;   #替换成你的pem/crt文件名称<br>        ssl_certificate_key cert/example.com.key;   #替换成你的key文件名称<br>        ssl_session_timeout 5m;<br>        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;  #使用此加密套件。<br>        ssl_protocols TLSv1 TLSv1<span class="hljs-number">.1</span> TLSv1<span class="hljs-number">.2</span>;   #使用该协议进行配置。<br>        ssl_prefer_server_ciphers on;  <br><br><br>        # listen       <span class="hljs-number">80</span>;<br>        # server_name  localhost;<br><br>        #charset koi8-r;<br><br>        #access_log  logs/host.access.log  main;<br><br>        location / &#123;<br>            root   html;<br>            index  index.html index.htm;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对于用户不知道网站可以进行 https 访问的情况下，可以使用全站加密，让服务器自动把 <code>http</code> 的请求重定向到 <code>https</code>。在<code>nginx.conf</code>文件中添加以下配置：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">server &#123;<br>        listen       80;<br>        server_name  example.com;#替换成你的域名<br><br><br>        location / &#123;<br>            # 配置请求转发，将http的请求转发到https上面<br>            rewrite ^(.*)$ https:<span class="hljs-comment">//example.com/$1 permanent;#替换成你的域名</span><br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>然后重启容器即可。</p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本篇主要记录了一下如何将自己的项目制作成Docker镜像，然后能在docker运行。以及Nginx的相关部署。关于docker还有很多东西要学，这里就对自己学的一点点东西做一个笔记，以方便下次使用。其余的等啥时候用到了在进行学习，这次就到这吧。</p>
]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Java获取主机信息</title>
    <url>/2021/12/22/JavaGetHostInfo/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最近在做一个主机资源监控的需求，首先是获取一些最简单的基本参，像一些主机名称、系统类型、ip、cpu、内存和磁盘等等这些数据，看起来虽然很简单，Java的基本库就能完成，但是真的去使用的时候，还是有一些坑的。记录一下，已备后用。</p>
<span id="more"></span>

<h1 id="Java获取主机信息"><a href="#Java获取主机信息" class="headerlink" title="Java获取主机信息"></a>Java获取主机信息</h1><h2 id="1-获取基本信息"><a href="#1-获取基本信息" class="headerlink" title="1. 获取基本信息"></a>1. 获取基本信息</h2><h3 id="1-1-获取主机名称和系统"><a href="#1-1-获取主机名称和系统" class="headerlink" title="1.1 获取主机名称和系统"></a>1.1 获取主机名称和系统</h3><p>主机名称可以通过网络类<strong>InetAddress</strong>来获取，主机系统和用户可以通过<strong>System</strong>类进行获取。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getLocalHost</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">try</span>&#123;<br>        InetAddress ip = InetAddress.getLocalHost();<br>        String localName = ip.getHostName();<br>        String osName = System.getProperty(<span class="hljs-string">&quot;os.name&quot;</span>);<br>        String userName = System.getProperty(<span class="hljs-string">&quot;user.name&quot;</span>);<br>        String osVersion = System.getProperty(<span class="hljs-string">&quot;os.version&quot;</span>);<br>        String osArch = System.getProperty(<span class="hljs-string">&quot;os.arch&quot;</span>);<br>        <br>        System.out.println(<span class="hljs-string">&quot;当前用户：&quot;</span> + userName);<br>        System.out.println(<span class="hljs-string">&quot;用户的主目录：&quot;</span>+props.getProperty(<span class="hljs-string">&quot;user.home&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;用户的当前工作目录：&quot;</span>+props.getProperty(<span class="hljs-string">&quot;user.dir&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;主机名称：&quot;</span> + localName);<br>        System.out.println(<span class="hljs-string">&quot;主机系统：&quot;</span> + osName);<br>        System.out.println(<span class="hljs-string">&quot;系统版本：&quot;</span> + osVersion);<br>        System.out.println(<span class="hljs-string">&quot;系统架构：&quot;</span> + osArch);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="1-2-获取用户信息"><a href="#1-2-获取用户信息" class="headerlink" title="1.2 获取用户信息"></a>1.2 获取用户信息</h3><p>用户信息都是使用<strong>System</strong>类进行获取。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getUserInfo</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">try</span>&#123;<br>        String userName = System.getProperty(<span class="hljs-string">&quot;user.name&quot;</span>);<br>        String userHome = System.getProperty(<span class="hljs-string">&quot;user.home&quot;</span>);<br>        String userDir = System.getProperty(<span class="hljs-string">&quot;user.dir&quot;</span>);<br>        <br>        System.out.println(<span class="hljs-string">&quot;当前用户：&quot;</span> + userName);<br>        System.out.println(<span class="hljs-string">&quot;用户主目录：&quot;</span>+ userHome);<br>        System.out.println(<span class="hljs-string">&quot;当前工作目录：&quot;</span>+ userDir);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="1-3-获取主机IP等信息"><a href="#1-3-获取主机IP等信息" class="headerlink" title="1.3 获取主机IP等信息"></a>1.3 获取主机IP等信息</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;主机的ip可以通过网络类<strong>InetAddress</strong>进行获取，但是这个方法很玄学，机器上多网卡还有虚拟机时，获取到就不准确了。目前做的获取的方法是痛殴便利网卡来获取ip。因为遍历网卡来获取ip要过滤一些不重要的网卡，过滤的方法是来自<strong>“经验”</strong>的笨方法，可以借鉴，但不保证日后网卡条件复杂的情况下获取不准确。测试的是Linux、Mac和Windows系统可用。因为过滤条件不一样，所以分为Windows获取和非Windows获取。</p>
<p><strong>Windows系统获取IP：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getWindowsIpAndMac</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Enumeration&lt;NetworkInterface&gt; allNetInterfaces = NetworkInterface.getNetworkInterfaces();<br>        <span class="hljs-comment">// 遍历网卡接口</span><br>        <span class="hljs-keyword">while</span> (allNetInterfaces.hasMoreElements()) &#123;<br>            NetworkInterface netInterface = allNetInterfaces.nextElement();<br>            <span class="hljs-comment">// 去除回环接口，子接口，未运行和接口</span><br>            <span class="hljs-keyword">if</span> (netInterface.isLoopback() || netInterface.isVirtual() || !netInterface.isUp()) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>			<br>            <span class="hljs-comment">// 重点来了：“经验”之谈</span><br>            <span class="hljs-comment">// 为了过滤掉虚拟机的网卡，可以通过网卡名来进行基础过滤。windows主机ip对应的网卡名会包含下面三个：Intel  无线、Realtek  网线、Ethernet  兼容xp系统</span><br>            <span class="hljs-keyword">if</span> (!netInterface.getDisplayName().contains(<span class="hljs-string">&quot;Intel&quot;</span>)<br>                &amp;&amp; !netInterface.getDisplayName().contains(<span class="hljs-string">&quot;Realtek&quot;</span>)<br>                &amp;&amp; !netInterface.getDisplayName().contains(<span class="hljs-string">&quot;Ethernet&quot;</span>)) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <br>            String ip = <span class="hljs-string">&quot;&quot;</span>;<br>            String mac = <span class="hljs-string">&quot;&quot;</span>;<br>            String niName = <span class="hljs-string">&quot;&quot;</span>;<br>            Enumeration&lt;InetAddress&gt; addresses = netInterface.getInetAddresses();<br>            <span class="hljs-keyword">while</span> (addresses.hasMoreElements()) &#123;<br>                InetAddress ia = addresses.nextElement();<br>                <span class="hljs-comment">// 去除本地回环地址，子接口，未运行和地址</span><br>                <span class="hljs-keyword">if</span> (ia != <span class="hljs-keyword">null</span> &amp;&amp; !ia.isLoopbackAddress() &amp;&amp; ia.isSiteLocalAddress() &amp;&amp; !ia.isAnyLocalAddress()) &#123;<br>                    <span class="hljs-comment">// 判断是否是ip v4地址</span><br>                    <span class="hljs-keyword">if</span> (ia <span class="hljs-keyword">instanceof</span> Inet4Address) &#123;<br>                        ip = ia.getHostAddress();<br>                        <span class="hljs-comment">// 获取MAC地址</span><br>                        mac = getMac(ia);<br>                        niName = netInterface.getName();<br>                        <span class="hljs-keyword">if</span> (StringUtils.isNotBlank(ip) &amp;&amp; StringUtils.isNotBlank(mac) &amp;&amp; StringUtils.isNotBlank(niName))&#123;<br>                            System.out.println(<span class="hljs-string">&quot;当前网卡：&quot;</span>+niName);<br>                            System.out.println(<span class="hljs-string">&quot;当前主机ip：&quot;</span>+ip);<br>                            System.out.println(<span class="hljs-string">&quot;当前主机MAC：&quot;</span>+mac);<br>                            <span class="hljs-keyword">return</span>;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (SocketException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>非Windows系统获取IP：</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实和windows获取的差不多，也是遍历网卡然后进行过滤，不过这个没有“经验”，不知道要过滤那些，所以用<strong>InetAddress</strong>进行获取，经测试这个在非windows上获取的还是准确的（可能我linux网卡单一）。不过为了获取当前的网卡用了一个更笨的方法，既然当前获取的ip是准确的，那就根据ip去获取网卡。不过目前没有找到这个方法，所以可以在遍历网卡时取出符合当前ip的网卡。（此方法在我这个需求里是可以的，不保证拿走就能用）。</p>
<p><img  src="image-20211222173816612.png"  ><span class="image-caption">机智如我</span></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getLinuxIpAndMac</span><span class="hljs-params">(AgentMonitor agentMonitor)</span></span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 先获取ip</span><br>        InetAddress iad = InetAddress.getLocalHost();<br>        String localIp = iad.getHostAddress();<br><br>        <span class="hljs-comment">// 遍历网卡</span><br>        Enumeration&lt;NetworkInterface&gt; allNetInterfaces = NetworkInterface.getNetworkInterfaces();<br>        <span class="hljs-keyword">while</span> (allNetInterfaces.hasMoreElements()) &#123;<br>            NetworkInterface netInterface = allNetInterfaces.nextElement();<br>            <span class="hljs-comment">// 去除回环接口，子接口，未运行和接口</span><br>            <span class="hljs-keyword">if</span> (netInterface.isLoopback() || netInterface.isVirtual() || !netInterface.isUp()) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            String ip = <span class="hljs-string">&quot;&quot;</span>;<br>            String mac = <span class="hljs-string">&quot;&quot;</span>;<br>            String niName = <span class="hljs-string">&quot;&quot;</span>;<br>            Enumeration&lt;InetAddress&gt; addresses = netInterface.getInetAddresses();<br>            <span class="hljs-keyword">while</span> (addresses.hasMoreElements()) &#123;<br>                InetAddress ia = addresses.nextElement();<br>                <span class="hljs-keyword">if</span> (ia != <span class="hljs-keyword">null</span> &amp;&amp; !ia.isLoopbackAddress() &amp;&amp; ia.isSiteLocalAddress() &amp;&amp; !ia.isAnyLocalAddress()) &#123;<br>                    <span class="hljs-comment">// 判断是否是ip v4地址且是否和已获取的ip一致</span><br>                    <span class="hljs-keyword">if</span> (ia <span class="hljs-keyword">instanceof</span> Inet4Address &amp;&amp; ia.getHostAddress().equals(localIp)) &#123;<br>                        ip = ia.getHostAddress();<br>                        <span class="hljs-comment">// 获取MAC地址</span><br>                        mac = getMac(ia);<br>                        niName = netInterface.getName();<br>                        <span class="hljs-keyword">if</span> (StringUtils.isNotBlank(ip) &amp;&amp; StringUtils.isNotBlank(mac) &amp;&amp; StringUtils.isNotBlank(niName))&#123;<br>                            System.out.println(<span class="hljs-string">&quot;当前网卡：&quot;</span>+niName);<br>                            System.out.println(<span class="hljs-string">&quot;当前主机ip：&quot;</span>+ip);<br>                            System.out.println(<span class="hljs-string">&quot;当前主机MAC：&quot;</span>+mac);<br>                            <span class="hljs-keyword">return</span>;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>获取MAC地址</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getMac</span><span class="hljs-params">(InetAddress ia)</span></span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//获取网卡，获取地址</span><br>        <span class="hljs-keyword">byte</span>[] mac = NetworkInterface.getByInetAddress(ia).getHardwareAddress();<br>        StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer();<br>        <span class="hljs-keyword">if</span> (mac != <span class="hljs-keyword">null</span> &amp;&amp; mac.length&gt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;mac.length; i++) &#123;<br>                <span class="hljs-keyword">if</span>(i!=<span class="hljs-number">0</span>) &#123;<br>                    sb.append(<span class="hljs-string">&quot;-&quot;</span>);<br>                &#125;<br>                <span class="hljs-comment">//字节转换为整数</span><br>                String str = Integer.toHexString(mac[i] &amp; <span class="hljs-number">0xff</span>);<br>                <span class="hljs-keyword">if</span>(str.length()==<span class="hljs-number">1</span>) &#123;<br>                    sb.append(<span class="hljs-string">&quot;0&quot;</span>).append(str);<br>                &#125;<span class="hljs-keyword">else</span> &#123;<br>                    sb.append(str);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.toString().toUpperCase();<br>    &#125; <span class="hljs-keyword">catch</span> (SocketException e) &#123;<br>        e.printStackTrace();<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="2-获取CPU信息"><a href="#2-获取CPU信息" class="headerlink" title="2. 获取CPU信息"></a>2. 获取CPU信息</h2><p>获取CPU的信息这里选用的是**<a href="https://github.com/oshi/oshi">oshi</a><strong>工具，经测试这个获取的还是比较准确的，而且该工具还可以获得其他硬件信息，能获取到的还是比较全面的。首先需要引入</strong>oshi**的依赖。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.oshi<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>oshi-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.12.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p><strong>oshi</strong>是依赖于<strong>JNA</strong>，需要导入<code>jna</code>和<code>jna-platform</code>我这里用的<strong>oshi</strong>是<em>3.12.2</em>版本，对应使用的<strong>JNA</strong>的版本是<em>5.2.0</em>。springboot项目是自带JNA的，如果不是springboot项目需要额外导入。如果springboot项目自带的JNA版本过低，也需要额外导入高版本的JNA。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>net.java.dev.jna<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jna<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
</blockquote>
<p><img  src="image-20211223104609629.png"  ><span class="image-caption">JNA版本</span></p>
<h3 id="2-1-获取CPU核数"><a href="#2-1-获取CPU核数" class="headerlink" title="2.1 获取CPU核数"></a>2.1 获取CPU核数</h3><p><strong>oshi</strong>中的<strong>CentralProcessor</strong>进行获取。获取CPU物理可用的核数，如果有开启超频，那么获取的CPU核数可能会大于物理核数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getCpuCount</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 获取SystemInfo实例</span><br>        SystemInfo systemInfo = <span class="hljs-keyword">new</span> SystemInfo();<br>        <span class="hljs-comment">// 获取CentralProcessor实例</span><br>        CentralProcessor processor = systemInfo.getHardware().getProcessor();<br>        <span class="hljs-comment">// 获取CPU核数</span><br>        <span class="hljs-keyword">int</span> cpuCount = processor.getLogicalProcessorCount();<br>        System.out.println(<span class="hljs-string">&quot;CPU核数：&quot;</span>+cpuCount);<br>    &#125; <span class="hljs-keyword">catch</span> (SocketException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="2-2-获取CPU使用率"><a href="#2-2-获取CPU使用率" class="headerlink" title="2.2 获取CPU使用率"></a>2.2 获取CPU使用率</h3><p>获取系统范围的CPU负载时，一共获取7个部分的负载。</p>
<ul>
<li>CPU 空闲且系统没有未完成的磁盘 I/O 请求的时间。</li>
<li>在系统有未完成的磁盘 I/O 请求期间一个或多个 CPU 空闲的时间。在windows不可用。在MacOS不可用。</li>
<li>CPU 用于服务硬件 IRQ 的时间。在MacOS不可用。</li>
<li>在具有良好优先级的用户级别执行时发生的 CPU 利用率。在windows不可用。</li>
<li>CPU 用于服务软 IRQ 的时间。</li>
<li>管理程序专用于系统中其他来宾的时间。</li>
<li>在系统级别（内核）执行时发生的 CPU 利用率。</li>
<li>在用户级别（应用程序）执行时发生的 CPU 使用率。</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要使用此方法计算总体空闲时间，就要包括上面所有部分，这样计算出来的结果更准确且兼容各种平台。分两次获取上面信息，间隔1秒。这样就能计算出1秒的CPU各方面使用的差值，通过每一项的差值除以总量，便可以得到每一项的CPU使用率。</p>
<p>通过下面方法还可以获得CPU时间间隔内的使用率和总使用率。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getCpuInfo</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        SystemInfo systemInfo = <span class="hljs-keyword">new</span> SystemInfo();<br>        CentralProcessor processor = systemInfo.getHardware().getProcessor();<br>        <span class="hljs-comment">// 获取系统范围的cpu负载技计数</span><br>        <span class="hljs-keyword">long</span>[] prevTicks = processor.getSystemCpuLoadTicks();<br>        <span class="hljs-comment">// 睡眠1s</span><br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">long</span>[] ticks = processor.getSystemCpuLoadTicks();<br>        <span class="hljs-comment">// 具有良好优先级的用户级别</span><br>        <span class="hljs-keyword">long</span> nice = ticks[CentralProcessor.TickType.NICE.getIndex()] - prevTicks[CentralProcessor.TickType.NICE.getIndex()];<br>        <span class="hljs-comment">// 硬件服务</span><br>        <span class="hljs-keyword">long</span> irq = ticks[CentralProcessor.TickType.IRQ.getIndex()] - prevTicks[CentralProcessor.TickType.IRQ.getIndex()];<br>        <span class="hljs-comment">// 软服务使用</span><br>        <span class="hljs-keyword">long</span> softirq = ticks[CentralProcessor.TickType.SOFTIRQ.getIndex()] - prevTicks[CentralProcessor.TickType.SOFTIRQ.getIndex()];<br>        <span class="hljs-comment">// 管理程序使用</span><br>        <span class="hljs-keyword">long</span> steal = ticks[CentralProcessor.TickType.STEAL.getIndex()] - prevTicks[CentralProcessor.TickType.STEAL.getIndex()];<br>        <span class="hljs-comment">// 系统使用</span><br>        <span class="hljs-keyword">long</span> cSys = ticks[CentralProcessor.TickType.SYSTEM.getIndex()] - prevTicks[CentralProcessor.TickType.SYSTEM.getIndex()];<br>        <span class="hljs-comment">// 用户使用</span><br>        <span class="hljs-keyword">long</span> user = ticks[CentralProcessor.TickType.USER.getIndex()] - prevTicks[CentralProcessor.TickType.USER.getIndex()];<br>        <span class="hljs-comment">// 等待使用</span><br>        <span class="hljs-keyword">long</span> iowait = ticks[CentralProcessor.TickType.IOWAIT.getIndex()] - prevTicks[CentralProcessor.TickType.IOWAIT.getIndex()];<br>        <span class="hljs-comment">// 空闲使用</span><br>        <span class="hljs-keyword">long</span> idle = ticks[CentralProcessor.TickType.IDLE.getIndex()] - prevTicks[CentralProcessor.TickType.IDLE.getIndex()];<br>        <span class="hljs-keyword">long</span> totalCpu = user + nice + cSys + idle + iowait + irq + softirq + steal;<br>        <span class="hljs-keyword">double</span> sysRate = cSys * <span class="hljs-number">1.0</span> / totalCpu;<br>        <span class="hljs-keyword">double</span> userRate = user * <span class="hljs-number">1.0</span> / totalCpu;<br>        <span class="hljs-keyword">double</span> waitRate = cSys * <span class="hljs-number">1.0</span> / totalCpu;<br>        <span class="hljs-keyword">double</span> idleRate = cSys * <span class="hljs-number">1.0</span> / totalCpu;<br>        <span class="hljs-keyword">double</span> betweenRate = processor.getSystemCpuLoadBetweenTicks();<br>        <span class="hljs-keyword">double</span> cpuLoad = processor.getSystemCpuLoad();<br>        System.out.println(<span class="hljs-string">&quot;cpu系统使用率:&quot;</span> + <span class="hljs-keyword">new</span> DecimalFormat(<span class="hljs-string">&quot;#.##%&quot;</span>).format(sysRate));<br>        System.out.println(<span class="hljs-string">&quot;cpu用户使用率:&quot;</span> + <span class="hljs-keyword">new</span> DecimalFormat(<span class="hljs-string">&quot;#.##%&quot;</span>).format(userRate));<br>        System.out.println(<span class="hljs-string">&quot;cpu当前等待率:&quot;</span> + <span class="hljs-keyword">new</span> DecimalFormat(<span class="hljs-string">&quot;#.##%&quot;</span>).format(waitRate));<br>        System.out.println(<span class="hljs-string">&quot;cpu当前空闲率:&quot;</span> + <span class="hljs-keyword">new</span> DecimalFormat(<span class="hljs-string">&quot;#.##%&quot;</span>).format(idleRate));<br>        <span class="hljs-comment">// 获取cpu最近(时间间隔内)使用率</span><br>        System.out.println(<span class="hljs-string">&quot;CPU load: &quot;</span>+ <span class="hljs-keyword">new</span> DecimalFormat(<span class="hljs-string">&quot;#.##%&quot;</span>).format(betweenRate) +<span class="hljs-string">&quot;(counting ticks)&quot;</span>);<br>        <span class="hljs-comment">// 获取cpu使用率</span><br>        System.out.println(<span class="hljs-string">&quot;CPU load: &quot;</span>+ <span class="hljs-keyword">new</span> DecimalFormat(<span class="hljs-string">&quot;#.##%&quot;</span>).format(cpuLoad) +<span class="hljs-string">&quot;(OS MXBean)&quot;</span>);<br>    &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="3-获取内存信息"><a href="#3-获取内存信息" class="headerlink" title="3. 获取内存信息"></a>3. 获取内存信息</h2><h3 id="3-1-获取主机内存"><a href="#3-1-获取主机内存" class="headerlink" title="3.1 获取主机内存"></a>3.1 获取主机内存</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;获取内存信息可以使用<strong>OperatingSystemMXBean</strong> 来获取。内存信息可以获取到的有<strong>内存总量</strong>和<strong>可用内存</strong>，通过这两个值在计算出内存已经使用的量和内存的使用率，测试时在Linux获取的数据不太精确，只获取到的空闲内存，获取不到可用内存。获取内存信息同样也可以使用<strong>oshi</strong>包中的<strong>SystemInfo</strong>类进行获取，这个获取的还是挺准确的。</p>
<p><strong>OperatingSystemMXBean</strong>获取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getMemInfo</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        OperatingSystemMXBean osmxb = (OperatingSystemMXBean) ManagementFactory.getOperatingSystemMXBean();<br>        <span class="hljs-comment">// 总内存，单位：字节</span><br>            <span class="hljs-keyword">long</span> total = osmxb.getTotalPhysicalMemorySize();<br>            <span class="hljs-comment">// 空闲内存，单位：字节</span><br>            <span class="hljs-keyword">long</span> free = osmxb.getFreePhysicalMemorySize();<br>            <span class="hljs-comment">// 可用内存，单位：字节</span><br>            <span class="hljs-keyword">long</span> usable = osmxb.getFreePhysicalMemorySize();<br>            <span class="hljs-comment">// 已使用内存，单位：字节</span><br>            <span class="hljs-keyword">long</span> used = total - free;<br>            <span class="hljs-comment">// 内存使用率</span><br>            <span class="hljs-keyword">double</span> useRate = used * <span class="hljs-number">1.0</span> / total;<br>            System.out.println(<span class="hljs-string">&quot;总共内存：&quot;</span> + <span class="hljs-keyword">new</span> DecimalFormat(<span class="hljs-string">&quot;#.##&quot;</span>).format(total*<span class="hljs-number">1.0</span> / Math.pow(<span class="hljs-number">1024</span>,<span class="hljs-number">3</span>)) + <span class="hljs-string">&quot;G&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;空闲内存：&quot;</span> + <span class="hljs-keyword">new</span> DecimalFormat(<span class="hljs-string">&quot;#.##&quot;</span>).format(free*<span class="hljs-number">1.0</span> / Math.pow(<span class="hljs-number">1024</span>,<span class="hljs-number">3</span>)) + <span class="hljs-string">&quot;G&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;已用内存：&quot;</span> + <span class="hljs-keyword">new</span> DecimalFormat(<span class="hljs-string">&quot;#.##&quot;</span>).format(used*<span class="hljs-number">1.0</span> / Math.pow(<span class="hljs-number">1024</span>,<span class="hljs-number">3</span>)) + <span class="hljs-string">&quot;G&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;可用内存：&quot;</span> + <span class="hljs-keyword">new</span> DecimalFormat(<span class="hljs-string">&quot;#.##&quot;</span>).format(usable*<span class="hljs-number">1.0</span> / Math.pow(<span class="hljs-number">1024</span>,<span class="hljs-number">3</span>)) + <span class="hljs-string">&quot;G&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;内存使用率：&quot;</span> + <span class="hljs-keyword">new</span> DecimalFormat(<span class="hljs-string">&quot;#.##%&quot;</span>).format(useRate * <span class="hljs-number">100.0</span>));<br><br>    &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>oshi.SystemInfo</strong>获取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getMemInfo</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        SystemInfo systemInfo = <span class="hljs-keyword">new</span> SystemInfo();<br>        GlobalMemory memory = systemInfo.getHardware().getMemory();<br>        <span class="hljs-comment">// 总内存，单位：字节</span><br>        <span class="hljs-keyword">long</span> total = memory.getTotal();<br>        <span class="hljs-comment">// 可用内存，单位：字节</span><br>        <span class="hljs-keyword">long</span> usable = memory.getAvailable()；<br>        <span class="hljs-comment">// 已使用内存，单位：字节</span><br>        <span class="hljs-keyword">long</span> used = total - usable;<br>        <span class="hljs-comment">// 内存使用率</span><br>        <span class="hljs-keyword">double</span> useRate = used * <span class="hljs-number">1.0</span> / total;<br>        System.out.println(<span class="hljs-string">&quot;总共内存：&quot;</span> + <span class="hljs-keyword">new</span> DecimalFormat(<span class="hljs-string">&quot;#.##&quot;</span>).format(total*<span class="hljs-number">1.0</span> / Math.pow(<span class="hljs-number">1024</span>,<span class="hljs-number">3</span>)) + <span class="hljs-string">&quot;G&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;已用内存：&quot;</span> + <span class="hljs-keyword">new</span> DecimalFormat(<span class="hljs-string">&quot;#.##&quot;</span>).format(used*<span class="hljs-number">1.0</span> / Math.pow(<span class="hljs-number">1024</span>,<span class="hljs-number">3</span>)) + <span class="hljs-string">&quot;G&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;可用内存：&quot;</span> + <span class="hljs-keyword">new</span> DecimalFormat(<span class="hljs-string">&quot;#.##&quot;</span>).format(usable*<span class="hljs-number">1.0</span> / Math.pow(<span class="hljs-number">1024</span>,<span class="hljs-number">3</span>)) + <span class="hljs-string">&quot;G&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;内存使用率：&quot;</span> + <span class="hljs-keyword">new</span> DecimalFormat(<span class="hljs-string">&quot;#.##%&quot;</span>).format(useRate * <span class="hljs-number">100.0</span>));<br>    &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="3-2-获取JVM内存"><a href="#3-2-获取JVM内存" class="headerlink" title="3.2 获取JVM内存"></a>3.2 获取JVM内存</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;获取<code>JVM</code>的内存信息需要使用<strong>MemoryMXBean</strong>接口中的<strong>MemoryUsage</strong>类。JVM信息主要是在系统运行时对JVM的使用情况。包括初始的内存大小、最大可用的内存以及当前已经使用的内存大小。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getJvmMemInfo</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        MemoryMXBean memoryMXBean = ManagementFactory.getMemoryMXBean();<br>        <span class="hljs-comment">// 椎内存使用情况</span><br>        MemoryUsage memoryUsage = memoryMXBean.getHeapMemoryUsage();<br>        <span class="hljs-comment">// jvm初始总内存，单位：字节</span><br>        <span class="hljs-keyword">long</span> initTotalMemorySize = memoryUsage.getInit();<br>        <span class="hljs-comment">// jvm最大可用内存，单位：字节</span><br>        <span class="hljs-keyword">long</span> free = osmxb.getFreePhysicalMemorySize();<br>        <span class="hljs-comment">// jvm已使用的内存，单位：字节</span><br>        <span class="hljs-keyword">long</span> usable = osmxb.getFreePhysicalMemorySize();<br>        <br>        System.out.println(<span class="hljs-string">&quot;jvm初始总内存：&quot;</span> + <span class="hljs-keyword">new</span> DecimalFormat(<span class="hljs-string">&quot;#.##&quot;</span>).format(total*<span class="hljs-number">1.0</span> / Math.pow(<span class="hljs-number">1024</span>,<span class="hljs-number">3</span>)) + <span class="hljs-string">&quot;G&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;jvm最大可用内存：&quot;</span> + <span class="hljs-keyword">new</span> DecimalFormat(<span class="hljs-string">&quot;#.##&quot;</span>).format(free*<span class="hljs-number">1.0</span> / Math.pow(<span class="hljs-number">1024</span>,<span class="hljs-number">3</span>)) + <span class="hljs-string">&quot;G&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;jvm已使用的内存：&quot;</span> + <span class="hljs-keyword">new</span> DecimalFormat(<span class="hljs-string">&quot;#.##&quot;</span>).format(used*<span class="hljs-number">1.0</span> / Math.pow(<span class="hljs-number">1024</span>,<span class="hljs-number">3</span>)) + <span class="hljs-string">&quot;G&quot;</span>);<br><br>    &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="4-获取磁盘信息"><a href="#4-获取磁盘信息" class="headerlink" title="4. 获取磁盘信息"></a>4. 获取磁盘信息</h2><p>获取磁盘的使用情况用的是基础的<strong>File</strong>类。首先是从根目录遍历所有磁盘信息，通过下面方法获取磁盘信息。</p>
<ul>
<li><strong>file.getTotalSpace()</strong> ：获取当前磁盘的总内存</li>
<li><strong>file.getFreeSpace()</strong> ：获取当前磁盘的空闲内存</li>
<li><strong>file.getUsableSpace()</strong> ：获取当前磁盘的可用内存</li>
</ul>
<p>通过上面获取的三个参数，可以计算磁盘总的已使用内存和当前磁盘的内存使用率。</p>
<p>在计算每一个磁盘的信息时，通过全局变量统计所有磁盘的信息总和，然后计算出主机总的磁盘内存和使用率。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> RADIX 内存进制大小，&quot;经验&quot;之谈是：Windows下进制是1024，Mac和Linux是1000</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getDiskInfo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> RADIX)</span></span>&#123;<br>    <span class="hljs-comment">// 统计总内存</span><br>    <span class="hljs-keyword">long</span> total = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 统计总空闲</span><br>    <span class="hljs-keyword">long</span> free = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 统计总可用</span><br>    <span class="hljs-keyword">long</span> usable = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 统计总已用</span><br>    <span class="hljs-keyword">long</span> used = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 磁盘总使用</span><br>    <span class="hljs-keyword">double</span> usedRate = <span class="hljs-number">0.0</span>；<br>    <span class="hljs-keyword">try</span>&#123;<br><br>        File[] disks = File.listRoots();<br>        <span class="hljs-keyword">for</span> (File file : disks)&#123;<br>            <span class="hljs-comment">// 统计总量</span><br>            total += file.getTotalSpace();<br>            free += file.getFreeSpace();<br>            usable += file.getUsableSpace();<br>            used += file.getTotalSpace() - file.getFreeSpace();<br>            <br>            String diskPath = file.getPath();<br>            <span class="hljs-keyword">long</span> diskTotal = file.getTotalSpace();<br>            <span class="hljs-keyword">long</span> diskFree = file.getFreeSpace();<br>            <span class="hljs-keyword">long</span> diskUsable = file.getUsableSpace();<br>            <span class="hljs-keyword">long</span> diskUsed = diskTotal - diskFree;<br>            <span class="hljs-keyword">double</span> diskUsedRate = diskUsed * <span class="hljs-number">1.0</span> / diskTotal;<br>         <br>            System.out.println(<span class="hljs-string">&quot;磁盘路径：&quot;</span> + diskPath);<br>            System.out.println(<span class="hljs-string">&quot;总共空间：&quot;</span>+ <span class="hljs-keyword">new</span> DecimalFormat(<span class="hljs-string">&quot;#.##&quot;</span>).format(diskTotal*<span class="hljs-number">1.0</span> / Math.pow(RADIX,<span class="hljs-number">3</span>)) + <span class="hljs-string">&quot;G&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;空闲空间：&quot;</span>+ <span class="hljs-keyword">new</span> DecimalFormat(<span class="hljs-string">&quot;#.##&quot;</span>).format(diskFree*<span class="hljs-number">1.0</span> / Math.pow(RADIX,<span class="hljs-number">3</span>)) + <span class="hljs-string">&quot;G&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;可用空间：&quot;</span>+ <span class="hljs-keyword">new</span> DecimalFormat(<span class="hljs-string">&quot;#.##&quot;</span>).format(diskUsable*<span class="hljs-number">1.0</span> / Math.pow(RADIX,<span class="hljs-number">3</span>)) + <span class="hljs-string">&quot;G&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;已用空间：&quot;</span>+ <span class="hljs-keyword">new</span> DecimalFormat(<span class="hljs-string">&quot;#.##&quot;</span>).format(diskUsed*<span class="hljs-number">1.0</span> / Math.pow(RADIX,<span class="hljs-number">3</span>)) + <span class="hljs-string">&quot;G&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;空间使用率：&quot;</span> + <span class="hljs-keyword">new</span> DecimalFormat(<span class="hljs-string">&quot;#.##%&quot;</span>).format(diskUsedRate*<span class="hljs-number">100</span>));<br>            <br>        &#125;<br>        <br>        String rootPath = <span class="hljs-string">&quot;/&quot;</span>;<br>        usedRate = used * <span class="hljs-number">1.0</span> / total;<br>        <br>        System.out.println(<span class="hljs-string">&quot;磁盘根路径：&quot;</span>+ rootPath);<br>        System.out.println(<span class="hljs-string">&quot;主机总共空间：&quot;</span>+ <span class="hljs-keyword">new</span> DecimalFormat(<span class="hljs-string">&quot;#.##&quot;</span>).format(total*<span class="hljs-number">1.0</span> / Math.pow(RADIX,<span class="hljs-number">3</span>)) + <span class="hljs-string">&quot;G&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;主机总空闲空间：&quot;</span>+ <span class="hljs-keyword">new</span> DecimalFormat(<span class="hljs-string">&quot;#.##&quot;</span>).format(free*<span class="hljs-number">1.0</span> / Math.pow(RADIX,<span class="hljs-number">3</span>)) + <span class="hljs-string">&quot;G&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;主机总可用空间：&quot;</span>+ <span class="hljs-keyword">new</span> DecimalFormat(<span class="hljs-string">&quot;#.##&quot;</span>).format(usable*<span class="hljs-number">1.0</span> / Math.pow(RADIX,<span class="hljs-number">3</span>)) + <span class="hljs-string">&quot;G&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;主机总已用空间：&quot;</span>+ <span class="hljs-keyword">new</span> DecimalFormat(<span class="hljs-string">&quot;#.##&quot;</span>).format(used*<span class="hljs-number">1.0</span> / Math.pow(RADIX,<span class="hljs-number">3</span>)) + <span class="hljs-string">&quot;G&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;主机总使用率：&quot;</span> + <span class="hljs-keyword">new</span> DecimalFormat(<span class="hljs-string">&quot;#.##%&quot;</span>).format(usedRate*<span class="hljs-number">100.0</span>));<br>        <br>    &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="5-获取Java环境信息"><a href="#5-获取Java环境信息" class="headerlink" title="5. 获取Java环境信息"></a>5. 获取Java环境信息</h2><p>这块就是补充说明了，暂时没用到，先保留一下，已备后用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getJavaInfo</span><span class="hljs-params">()</span></span>&#123;<br>    Properties props=System.getProperties();<br>    System.out.println(<span class="hljs-string">&quot;Java的运行环境版本：&quot;</span>+props.getProperty(<span class="hljs-string">&quot;java.version&quot;</span>));<br>    System.out.println(<span class="hljs-string">&quot;Java的运行环境供应商：&quot;</span>+props.getProperty(<span class="hljs-string">&quot;java.vendor&quot;</span>));<br>    System.out.println(<span class="hljs-string">&quot;Java供应商的URL：&quot;</span>+props.getProperty(<span class="hljs-string">&quot;java.vendor.url&quot;</span>));<br>    System.out.println(<span class="hljs-string">&quot;Java的安装路径：&quot;</span>+props.getProperty(<span class="hljs-string">&quot;java.home&quot;</span>));<br>    System.out.println(<span class="hljs-string">&quot;Java的虚拟机规范版本：&quot;</span>+props.getProperty(<span class="hljs-string">&quot;java.vm.specification.version&quot;</span>));<br>    System.out.println(<span class="hljs-string">&quot;Java的虚拟机规范供应商：&quot;</span>+props.getProperty(<span class="hljs-string">&quot;java.vm.specification.vendor&quot;</span>));<br>    System.out.println(<span class="hljs-string">&quot;Java的虚拟机规范名称：&quot;</span>+props.getProperty(<span class="hljs-string">&quot;java.vm.specification.name&quot;</span>));<br>    System.out.println(<span class="hljs-string">&quot;Java的虚拟机实现版本：&quot;</span>+props.getProperty(<span class="hljs-string">&quot;java.vm.version&quot;</span>));<br>    System.out.println(<span class="hljs-string">&quot;Java的虚拟机实现供应商：&quot;</span>+props.getProperty(<span class="hljs-string">&quot;java.vm.vendor&quot;</span>));<br>    System.out.println(<span class="hljs-string">&quot;Java的虚拟机实现名称：&quot;</span>+props.getProperty(<span class="hljs-string">&quot;java.vm.name&quot;</span>));<br>    System.out.println(<span class="hljs-string">&quot;Java运行时环境规范版本：&quot;</span>+props.getProperty(<span class="hljs-string">&quot;java.specification.version&quot;</span>));<br>    System.out.println(<span class="hljs-string">&quot;Java运行时环境规范供应商：&quot;</span>+props.getProperty(<span class="hljs-string">&quot;java.specification.vender&quot;</span>));<br>    System.out.println(<span class="hljs-string">&quot;Java运行时环境规范名称：&quot;</span>+props.getProperty(<span class="hljs-string">&quot;java.specification.name&quot;</span>));<br>    System.out.println(<span class="hljs-string">&quot;Java的类格式版本号：&quot;</span>+props.getProperty(<span class="hljs-string">&quot;java.class.version&quot;</span>));<br>    System.out.println(<span class="hljs-string">&quot;Java的类路径：&quot;</span>+props.getProperty(<span class="hljs-string">&quot;java.class.path&quot;</span>));<br>    System.out.println(<span class="hljs-string">&quot;加载库时搜索的路径列表：&quot;</span>+props.getProperty(<span class="hljs-string">&quot;java.library.path&quot;</span>));<br>    System.out.println(<span class="hljs-string">&quot;默认的临时文件路径：&quot;</span>+props.getProperty(<span class="hljs-string">&quot;java.io.tmpdir&quot;</span>));<br>    System.out.println(<span class="hljs-string">&quot;一个或多个扩展目录的路径：&quot;</span>+props.getProperty(<span class="hljs-string">&quot;java.ext.dirs&quot;</span>));<br>   <br>    System.out.println(<span class="hljs-string">&quot;文件分隔符：&quot;</span>+props.getProperty(<span class="hljs-string">&quot;file.separator&quot;</span>));<span class="hljs-comment">//在 unix 系统中是＂／＂ System.out.println(&quot;路径分隔符：&quot;+props.getProperty(&quot;path.separator&quot;));//在 unix 系统中是＂:＂ System.out.println(&quot;行分隔符：&quot;+props.getProperty(&quot;line.separator&quot;));//在 unix 系统中是＂/n＂ System.out.println(&quot;用户的账户名称：&quot;+props.getProperty(&quot;user.name</span><br>&#125;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>知识点</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>SpootBoot-项目搭建</title>
    <url>/2019/10/22/springboot-create/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最近有一个项目用到了SpringBoot框架，这也是我第一次用这个框架，对于新手小白来说，不是怎么友好，但是一旦搭建好了，确实上手很快，不用管底层是怎么实现的，也不用问某些东西是干嘛的，问就是去百度。因为人家的规定的就是让那么写，咱就是个使用者，跟着写就对了。emmmmmmm，好了，不在这瞎白活了，下面进入正题，开始搭建一个SpringBoot项目。</p>
<span id="more"></span>

<h1 id="SpringBoot项目搭建"><a href="#SpringBoot项目搭建" class="headerlink" title="SpringBoot项目搭建"></a>SpringBoot项目搭建</h1><h2 id="1-SpringBoot"><a href="#1-SpringBoot" class="headerlink" title="1. SpringBoot"></a>1. SpringBoot</h2><h3 id="1-1-什么是SpringBoot"><a href="#1-1-什么是SpringBoot" class="headerlink" title="1.1 什么是SpringBoot"></a>1.1 什么是SpringBoot</h3><blockquote>
<p>Spring Boot makes it easy to create stand-alone, production-grade Spring based Applications that you can “just run”.<br>We take an opinionated view of the Spring platform and third-party libraries so you can get started with minimum fuss. Most Spring Boot applications need very little Spring configuration.</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这段话是摘自官网的介绍，大致意思就是使用SpringBoot可以轻松快速的创建独立的、生产级别的基于Spring的应用程序。</p>
<h3 id="1-2-优势"><a href="#1-2-优势" class="headerlink" title="1.2 优势"></a>1.2 优势</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SpringBoot对开发效率的提升是全方位的，在没有使用SpringBoot之前开发一个web项目需要做那些工作</p>
<ul>
<li>配置web.xml，加载Spring和SpringMVC</li>
<li>配置数据库连接、配置Spring事务</li>
<li>配置加载配置文件的读取、开启注解</li>
<li>配置日志文件</li>
<li>部署tomcat调试</li>
<li>……</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而且还要添加一大堆记不住名字的jar包，有可能还要考虑各个版本的兼容性、冲突性等各种可行性。是不是感觉很复杂？就这步骤还是使用SSM(Spring+SpringMVC+MyBatis)整合搭建的。不说以前的JavaBean+servlet+Jsp的模式，就拿SSH(Struts+Spring+Hibernate)来说比这还要复杂，各种xml搞的让人头大。这个时候再来看一下SpringBoot搭建项目，就简单明了的几个配置文件，而且大多还都是自动配置，而且内置的有tomcat，使用idea创建更是方便，idea内置的各种工具可以实现全部全部框架的自动生成。</p>
<blockquote>
<p><strong>突出优势：</strong><br>简单、快速、方便的搭建项目<br>主流开发框架无配置集成<br>提高开发效率、部署效率</p>
</blockquote>
<h2 id="2-项目搭建"><a href="#2-项目搭建" class="headerlink" title="2. 项目搭建"></a>2. 项目搭建</h2><h3 id="2-1-开发环境"><a href="#2-1-开发环境" class="headerlink" title="2.1 开发环境"></a>2.1 开发环境</h3><blockquote>
<p>os:Windows 10<br>ide:IDEA 2019.2.3<br>jdk:1.8.0<br>maven:3.6.1<br>tomcat:9.0(框架自带)</p>
</blockquote>
<h3 id="2-2-创建项目"><a href="#2-2-创建项目" class="headerlink" title="2.2 创建项目"></a>2.2 创建项目</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用idea新建项目时，选择左侧的Spring Initializr，这是idea提供的快速创建，然后点击next。<br><img  src="%E6%96%B0%E5%BB%BA.png"  ><span class="image-caption">新建</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下一个页面是配置项目信息。Group是域；Artifact一般代表公司名称；这两个参数都是提供给Maven的；下面的Name和Package会自动补全，Package是项目总包名；Type一般都选择Mavne；Language一般选择Java，也可以使用其他虚拟机语言，比如Kotlin、Groovy；Packaging是项目打包方式，可以选择打成jar包或者war包。Java Version对于JDK选择8。配置完成之后点击next。</p>
<blockquote>
<ul>
<li>坐标Group ID是项目组织唯一的标识符，实际对应项目中的package包。</li>
<li>坐标Artifact ID是项目的唯一的标识符，实际对应项目的project name名称，Artifact不可包含大写字母。</li>
</ul>
</blockquote>
<p><img  src="%E9%85%8D%E7%BD%AE.png"  ><span class="image-caption">配置</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来是Dependencies初始化依赖，此处勾选Web–&gt;Spring Web。<br><img  src="Dependencies.png"  ><span class="image-caption">Dependencies</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;选择项目路径。然后Finish。<br><img  src="%E8%B7%AF%E5%BE%84.png"  ><span class="image-caption">路径</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为项目是依托于Maven的，第一次加载时间较长，是因为所有的配置都需要在网络上请求下来，下载完毕后项目目录如下所示。<br><img  src="%E7%9B%AE%E5%BD%95.png"  ><span class="image-caption">目录</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;简单介绍一下目录，大致可以分成三块。</p>
<blockquote>
<ul>
<li>java: 代码的源文件，逻辑代码都在这个里面存放着，里面的DemoApplication.java是系统的启动文件。</li>
<li>resource: 资源文件夹，存放的是所有静态资源和配置文件。application.properties是主要配置文件，可以添加其他配置，不够我一般习惯将其改为application.yaml格式，这个看个人习惯。有一点就是static文件夹西下的静态文件可以直接通过url访问到。templates文件夹下的不能通过url访问，需要通过controller跳转进行访问。</li>
<li>test: 测试模块。用于项目发布前的测试，里卖弄内置一个Junit测试。</li>
</ul>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在文件夹最外面有一个pom.xml文件，这个是引入外部依赖的文件。下面会说明。</p>
<h3 id="2-3-测试运行"><a href="#2-3-测试运行" class="headerlink" title="2.3 测试运行"></a>2.3 测试运行</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;项目创建出来之后，先写个简单的controller进行测试一下。在之前的<code>com.example.demo</code>下新建一个controller文件夹，创建编写HelloWorldController类进行测试。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.demo.controller;<br><br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: fby</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: 2019/10/23 下午5:38</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Version</span> 1.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloworldController</span> </span>&#123;<br>    <span class="hljs-meta">@RequestMapping(&quot;hello&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello World!恭喜你，测试成功!&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里的controller还是和SpringMVC很像的，唯一不同的一点就是<code>@RestController</code>这个注解，他就相当于是<code>@Controller</code>和<code>@ResponseBody</code>这两个注解的合体版。将这个注解打在类上的话，那么这个controller类里的所有方法都等于打上了<code>@ResponseBody</code>。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后就开始运行了，点击右上角的运行箭头或者直接启动DemoApplication.java类。<br><img  src="%E6%B5%8B%E8%AF%95.png"  ><span class="image-caption">测试</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后你就会看到控制台输出SpringBoot了。这个时候就意味着项目已经启动成功了，然后访问<a href="localhost:8080/hello.do">localhost:8080/hello.do</a><br><img  src="%E6%B5%8B%E8%AF%95%E6%88%90%E5%8A%9F.png"  ><span class="image-caption">测试成功</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以看到信息已经返回，测试成功。</p>
<h2 id="3-项目分析"><a href="#3-项目分析" class="headerlink" title="3. 项目分析"></a>3. 项目分析</h2><h3 id="3-1-pom-xml文件"><a href="#3-1-pom-xml文件" class="headerlink" title="3.1 pom.xml文件"></a>3.1 pom.xml文件</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在创建SpringBoot项目的时候会自动生成一个pom.xml文件。如下所示。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.0.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>demo<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>demo<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>Demo project for Spring Boot<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.vintage<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-vintage-engine<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个相比于一般的pom.xml文件多了一个<code>&lt;parent&gt;</code>标签，这个标签是配置在SpringBoot的父级依赖，有了这个，当前的项目才是SpringBoot项目，<code>spring-boot-starter-parent</code>是一个特殊的’starter’，它用来提供maven默认依赖，使用它之后常用的包依赖就可以省去<code>version</code>标签。</p>
<h3 id="3-2-入口类"><a href="#3-2-入口类" class="headerlink" title="3.2 入口类"></a>3.2 入口类</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SpringBoot项目通常有一个名为*Applicaton的入口类，入口类里面就只有一个<code>main</code>方法，这个<code>main</code>方法其实就是一个标准的Java应用的入口方法。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>@SpringBootApplication</code>是SpringBoot的核心注解，它是一个组合注解，该注解组合了：<code>@Configuration</code>、<code>@EnableAutoConfiguration</code>、<code>@ComponenScan</code>。若不使用<code>@SpringBootApplication</code>注解也可以使用这三个注解代替。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>@Configuration</code>注解和它的搭档<code>@Bean</code>在一起使用就可以创建一个简单的Spring配置类，可以用来代替相应的xml配置文件。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>@EnableAutoConfiguration</code>让SpringBoot根据类路径中的jar包依赖为当前项目进行自动配置Spring的上下文。例如，添加了<code>spring-boot-starter-web</code>依赖，会自动添加Tomcat和SpringMVC的依赖，那么SpringBoot会对Tomcat和SpringMVC进行自动配置。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>@ComponenScan</code>会自动扫描指定包下的全部标有<code>@Component</code>的类，并注册成Bean，当然包括<code>@Component</code>下的子注解<code>@Service</code>、<code>@Repository</code>、<code>@Controller</code>。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SpringBoot还会自动扫描<code>@SpringBootApplication</code>所在类的同级包以及子包里的Bean，所以入口类建议就配置在grounpID+arctifactID组合的包名下(这里为<code>com.example.demo</code>包)，使用idea自动创建项目的话idea会自动在这里创建。如果其他包没有和入口启动类在同一级的话，需要配置包扫描注解，<code>@EntityScan(&quot;xx.xx.entity&quot;)</code>:扫描实体类包；<code>@EnableJpaRepositories(basePackages = &#123;&quot;xx.xx.jpa&quot;&#125;)</code>：扫描jpa包；<code>@ComponentScan(basePackages = &#123;&quot;xx.xx.controller&quot;, &quot;xx.xx.service&quot;, &quot;xx.xx.service.Impl&quot;&#125;)</code>：扫描controller包、service包和Impl包。</p>
<h3 id="3-3-配置文件"><a href="#3-3-配置文件" class="headerlink" title="3.3 配置文件"></a>3.3 配置文件</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SpringBoot使用一个全局配置文件<code>application.properties</code>，它的作用是对一些默认配置的配置进行修改，放置在<code>src/main/resources</code>目录或者类路径的<code>/config</code>下。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SpringBoot不仅支持常规的properties配置文件，还支持yaml语言的配置文件。yaml是以数据为中心的语言，在配置数据的时候具有面向对象的特征。</p>
<h2 id="4-使用SpringBoot"><a href="#4-使用SpringBoot" class="headerlink" title="4. 使用SpringBoot"></a>4. 使用SpringBoot</h2><h3 id="4-1-集成JSP"><a href="#4-1-集成JSP" class="headerlink" title="4.1 集成JSP"></a>4.1 集成JSP</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SpringBot默认视图支持是Thymeleaf模板引擎，但是现在掌握的还不是很深，所以还是先来看看怎么集成JSP吧。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.在pom.xml文件中集成JSP，向pom.xlm添加以下依赖。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jstl<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>tomcat-embed-jasper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.在<code>application.yml</code>文件中配置视图解析器，将我们的JSP文件重定向到/WEB-INF/views/目录下。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span> <br>  <span class="hljs-attr">mvc:</span> <br>    <span class="hljs-attr">view:</span> <br>      <span class="hljs-attr">prefix:</span> <span class="hljs-string">/WEB-INF/views/</span><br>      <span class="hljs-attr">suffix:</span> <span class="hljs-string">.jsp</span><br></code></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.编写一个controller，注解要用<code>@Controller</code>,不能用<code>@RestController</code>注解，不然不能写jsp。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.demo.controller;<br><br><span class="hljs-keyword">import</span> org.springframework.stereotype.Controller;<br><span class="hljs-keyword">import</span> org.springframework.ui.Model;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: fby</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: 2019/10/23 下午5:38</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Version</span> 1.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloworldController</span> </span>&#123;<br>    <span class="hljs-meta">@RequestMapping(&quot;hello2.do&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(Model model)</span></span>&#123;<br>        model.addAttribute(<span class="hljs-string">&quot;str&quot;</span>,<span class="hljs-string">&quot;Hello World!恭喜你，测试成功!&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.在<code>src/main</code>目录下一次创建’webapp/WEB-INF/views’目录，并创建一个hello.jsp文件。</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><code class="hljs jsp">&lt;%@ page language=<span class="hljs-string">&quot;java&quot;</span> contentType=<span class="hljs-string">&quot;text/html; charset=UTF-8&quot;</span> pageEncoding=<span class="hljs-string">&quot;UTF-8&quot;</span> %&gt;<br>猜猜会输出什么？&lt;br&gt;<br>$&#123;str&#125;<br></code></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后在浏览器输入<a href="localhost:8080/hello2.do">localhost:8080/hello2.do</a>就可以看到以下效果了。<br><img  src="%E6%B5%8B%E8%AF%95JSP%E6%88%90%E5%8A%9F.png"  ><span class="image-caption">测试JSP</span></p>
<h3 id="4-2-集成MyBatis"><a href="#4-2-集成MyBatis" class="headerlink" title="4.2 集成MyBatis"></a>4.2 集成MyBatis</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;是不是看到这就已经可以自己使用SpringBoot和JSP开发一个静态网页呢？开不开心？不要激动，下面还有数据库没连接呢，接下来就来看看怎么集成MyBatis吧。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.在<code>pom.xml</code>中添加对MySql和Mybatis的依赖。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- mybatis --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!-- mysql --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.21<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.在application.yml配置文件添加配置。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">mvc:</span><br>    <span class="hljs-attr">view:</span><br>      <span class="hljs-attr">prefix:</span> <span class="hljs-string">/WEB-INF/views/</span><br>      <span class="hljs-attr">suffix:</span> <span class="hljs-string">.jsp</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://127.0.0.1:3306/test?characterEncoding=UTF-8</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">admin</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.jdbc.Driver</span><br></code></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.先在<code>com.example.demo</code>下创建<code>domain</code>和<code>mapper</code>包，再创建<code>User</code>实体类和<code>UserMapper</code>映射类分别放在<code>domain</code>和<code>mapper</code>包下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.demo.domain;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: fby</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: 2019/10/23 下午6:00</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.id = id;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.demo.mapper;<br><br><span class="hljs-keyword">import</span> com.example.demo.domain.User;<br><span class="hljs-keyword">import</span> org.apache.ibatis.annotations.Mapper;<br><span class="hljs-keyword">import</span> org.apache.ibatis.annotations.Select;<br><br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: fby</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: 2019/10/23 下午6:00</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> </span>&#123;<br>    <span class="hljs-meta">@Select(&quot;select * from user&quot;)</span><br>    <span class="hljs-function">List&lt;User&gt; <span class="hljs-title">findAll</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.然后在<code>controller</code>包下创建<code>UserController</code>类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.demo.controller;<br><br><span class="hljs-keyword">import</span> com.example.demo.domain.User;<br><span class="hljs-keyword">import</span> com.example.demo.mapper.UserMapper;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Controller;<br><span class="hljs-keyword">import</span> org.springframework.ui.Model;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: fby</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: 2019/10/23 下午6:00</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserMapper userMapper;<br>    <span class="hljs-meta">@RequestMapping(&quot;/userList.do&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">userList</span><span class="hljs-params">(Model model)</span></span>&#123;<br>        List&lt;User&gt; list = userMapper.findAll();<br>        model.addAttribute(<span class="hljs-string">&quot;list&quot;</span>,list);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;list&quot;</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.编写一个<code>list.jsp</code>文件，用来显示数据库中准备好的数据。</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><code class="hljs jsp">&lt;%@ page language=<span class="hljs-string">&quot;java&quot;</span> contentType=<span class="hljs-string">&quot;text/html; charset=UTF-8&quot;</span><br>         pageEncoding=<span class="hljs-string">&quot;UTF-8&quot;</span>%&gt;<br><br>&lt;%@ taglib uri=<span class="hljs-string">&quot;http://java.sun.com/jsp/jstl/core&quot;</span> prefix=<span class="hljs-string">&quot;c&quot;</span>%&gt;<br><br>&lt;table border=<span class="hljs-string">&#x27;1&#x27;</span> cellspacing=<span class="hljs-string">&#x27;0&#x27;</span>&gt;<br>    &lt;tr&gt;<br>        &lt;td&gt;id&lt;/td&gt;<br>        &lt;td&gt;name&lt;/td&gt;<br>        &lt;td&gt;age&lt;/td&gt;<br>    &lt;/tr&gt;<br>    &lt;c:forEach items=<span class="hljs-string">&quot;$&#123;list&#125;&quot;</span> <span class="hljs-keyword">var</span>=<span class="hljs-string">&quot;u&quot;</span> varStatus=<span class="hljs-string">&quot;user&quot;</span>&gt;<br>        &lt;tr&gt;<br>            &lt;td&gt;$&#123;u.id&#125;&lt;/td&gt;<br>            &lt;td&gt;$&#123;u.name&#125;&lt;/td&gt;<br>            &lt;td&gt;$&#123;u.age&#125;&lt;/td&gt;<br>        &lt;/tr&gt;<br>    &lt;/c:forEach&gt;<br>&lt;/table&gt;<br></code></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.在浏览器访问<a href="localhost:8080/userList.do">localhost:8080/userList.do</a>即可看到数据库里数据。<br><img  src="%E6%B5%8B%E8%AF%95MyBatis.png"  ><span class="image-caption">测试Mybatis</span></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以上就是使用SpringBoot搭建项目的全部内容，并且集成了JSP和MyBatis，按照上面的步骤一步一步的来，就可以搭建一个基于SpringBoot的web项目了。</p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot-整合SpringDataJPA</title>
    <url>/2019/10/27/springboot-springDataJPA/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JPA的全称是<strong>Java Persistence API</strong>，Persistence 是持久化的意思。所以，中文全称是【JAVA对象持久化的 API】。简单来说，可以理解为是一种JAVA的标准规范，这个规范为JAVA对象的持久化制定了一些标准的接口。要注意的是，JPA只是一个接口规范，而不是实现。具体实现由各供应商来完成，例如Hibernate，TopLink,OpenJPA都很好地实现了JPA接口。</p>
<span id="more"></span>
<h1 id="SpringBoot整合SpringDataJPA"><a href="#SpringBoot整合SpringDataJPA" class="headerlink" title="SpringBoot整合SpringDataJPA"></a>SpringBoot整合SpringDataJPA</h1><h2 id="1-SpringBootDataJPA"><a href="#1-SpringBootDataJPA" class="headerlink" title="1. SpringBootDataJPA"></a>1. SpringBootDataJPA</h2><h3 id="1-1-简述"><a href="#1-1-简述" class="headerlink" title="1.1 简述"></a>1.1 简述</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SpringDataJPA是较大的SpringData系列的一部分，可轻松实现基于JPA的存储库。该模块处理对基于JPA的数据访问层的增强支持。它使构建使用数据访问技术的Spring支持的应用程序变得更加容易。默认底层是Hibernate，使用JPA的Repository能极大的减少对数据库的访问的代码量，仅仅使用内部接口就可以完成简单的CRUD等操作。</p>
<h3 id="1-2-特征"><a href="#1-2-特征" class="headerlink" title="1.2 特征"></a>1.2 特征</h3><ul>
<li>基于Spring和JPA构建存储库的先进支持。</li>
<li>支持Querydsl谓词，从而支持类型安全的JPA查询。</li>
<li>域类的透明审核。</li>
<li>分页支持，动态查询支持，集成自定义数据访问代码的能力。</li>
<li><code>@Query</code>引导时验证带注释的查询。</li>
<li>支持基于XML的实体映射。</li>
<li>通过引入JavaConfig的存储库配置<code>@EnableJpaReposituries</code>。</li>
</ul>
<h2 id="2-搭建项目"><a href="#2-搭建项目" class="headerlink" title="2. 搭建项目"></a>2. 搭建项目</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该项目是一个完整的开发项目，所有的逻辑代码都放在了Controller层，数据源使用alibaba的<em>Druid</em>数据源。</p>
<h3 id="2-1-导入依赖-修改配置文件"><a href="#2-1-导入依赖-修改配置文件" class="headerlink" title="2.1 导入依赖/修改配置文件"></a>2.1 导入依赖/修改配置文件</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先在pom.xml文件原来的基础中添加依赖。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后再修改application配置文件，添加关于Druid和SpringBootJPA的依赖。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-comment"># 配置视图解析</span><br>  <span class="hljs-attr">mvc:</span><br>    <span class="hljs-attr">view:</span><br>      <span class="hljs-attr">prefix:</span> <span class="hljs-string">/WEB-INF/views/</span><br>      <span class="hljs-attr">suffix:</span> <span class="hljs-string">.jsp</span><br>  <span class="hljs-comment"># 配置数据源</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://127.0.0.1:3306/test?characterEncoding=UTF-8&amp;serverTimezone=UTC</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">admin</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>    <span class="hljs-comment">#最大活跃数</span><br>    <span class="hljs-attr">maxaActive:</span> <span class="hljs-number">20</span><br>    <span class="hljs-comment">#初始化数量</span><br>    <span class="hljs-attr">InitialSize:</span> <span class="hljs-number">1</span><br>    <span class="hljs-comment">#最大连接等待时间</span><br>    <span class="hljs-attr">maxWait:</span> <span class="hljs-number">60000</span><br>    <span class="hljs-comment">#打开PSCache，并指定大小</span><br>    <span class="hljs-attr">poolPreparedStatements:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">maxPoolPreparedStatementPerConnectionSize:</span> <span class="hljs-number">20</span><br>    <span class="hljs-attr">minIdle:</span> <span class="hljs-number">1</span><br>    <span class="hljs-attr">connectionProperties:</span> <span class="hljs-string">druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000</span><br>    <span class="hljs-attr">timeBetweenEvictionRunsMillis:</span> <span class="hljs-number">60000</span><br>    <span class="hljs-attr">minEvictableIdleTimeMillis:</span> <span class="hljs-number">300000</span><br>    <span class="hljs-attr">validationQuery:</span> <span class="hljs-string">select</span> <span class="hljs-number">1</span> <span class="hljs-string">from</span> <span class="hljs-string">dual</span><br>    <span class="hljs-attr">testWhileIdle:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">testOnBorrow:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">testOnReturn:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">filters:</span> <span class="hljs-string">stat,</span> <span class="hljs-string">wall,</span> <span class="hljs-string">log4j</span><br>  <span class="hljs-comment"># 配置JPA</span><br>  <span class="hljs-attr">jpa:</span><br>    <span class="hljs-attr">database:</span> <span class="hljs-string">mysql</span><br>    <span class="hljs-attr">show-sql:</span> <span class="hljs-literal">true</span>                 <span class="hljs-comment"># 是否打印sql</span><br>    <span class="hljs-attr">generate-ddl:</span> <span class="hljs-literal">true</span>             <span class="hljs-comment"># 是否生成ddl</span><br>    <span class="hljs-attr">hibernate:</span>                     <span class="hljs-comment"># 数据库表的创建方式:更新 </span><br>        <span class="hljs-attr">ddl-auto:</span> <span class="hljs-string">update</span><br>    <span class="hljs-attr">properties:</span><br>        <span class="hljs-comment">### 数据库方言,告诉hibernate这是mysql</span><br>        <span class="hljs-attr">hibernate.dialect:</span> <span class="hljs-string">com.demo.mysql.MySQLDialectUTF8</span><br>        <span class="hljs-comment">### 控制条打印sql格式化输出</span><br>        <span class="hljs-attr">hibernate.format_sql:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数据库方言设置，新建<code>mysql</code>包，创建<code>MySQLDialectUTF8</code>类。将默认的字符集编码设置为UTF8。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.demo.mysql;<br><br><span class="hljs-keyword">import</span> org.hibernate.dialect.MySQL5Dialect;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 重写数据库方言，设置默认字符集为utf8</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MySQLDialectUTF8</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MySQL5Dialect</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getTableTypeString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot; ENGINE=InnoDB DEFAULT CHARSET=utf8&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>注意</strong><br>配置数据库连接，8.0以上的版本再写法上有些不一样，以下是新版写法。8.0以下版本的写法不变。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://127.0.0.1:3306/test?characterEncoding=UTF-8&amp;serverTimezone=UTC</span><br><span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br></code></pre></td></tr></table></figure>
<p>这时候mysql驱动也需要是8.0以上版本的。pom.xml依赖如下。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.16<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="2-2-使用JpaRepository"><a href="#2-2-使用JpaRepository" class="headerlink" title="2.2 使用JpaRepository"></a>2.2 使用JpaRepository</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为JPA的底层就是Hibernate，所以需要一个实体类对数据库表表结构进行映射，在启动项目时，会自动根据实体类创建相应的表结构。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.demo.domain;<br><br><span class="hljs-keyword">import</span> javax.persistence.*;<br><span class="hljs-keyword">import</span> java.io.Serializable;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: FBY</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: 2019/10/27 14:26</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Version</span> 1.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Entity</span><br><span class="hljs-meta">@Table(name = &quot;stu&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br>    <br>    <span class="hljs-meta">@Id</span><br>    <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span><br>    <span class="hljs-meta">@Column(name = &quot;id&quot;)</span><br>    <span class="hljs-keyword">private</span> Integer id;<br>    <br>    <span class="hljs-meta">@Column(name = &quot;name&quot;)</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <br>    <span class="hljs-meta">@Column(name = &quot;age&quot;)</span><br>    <span class="hljs-keyword">private</span> Integer age;<br>    <br>    <span class="hljs-meta">@Column(name = &quot;address&quot;)</span><br>    <span class="hljs-keyword">private</span> String address;<br><br>    <span class="hljs-comment">/*getter and setter*/</span>    <br>&#125;<br></code></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面对该类中用到的注解做一个简单说明：使用<code>@Entity</code>会对实体类进行持久化操作，当JPA检测到实体类中有<code>@Entity</code>注解时，会在数据库中生成相对应的表结构信息。<code>@Table</code>用来指定该实体类对应的表明。<code>@Id</code>用来指定主键，配合<code>@GeneratedValue(strategy = GenerationType.IDENTITY)</code>指定主键的自增策略，这里将主键自增交给数据库去做，所以使用<code>IDENTITY</code>。<code>@Column</code>用来指定对应表中的字段名。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之后创建一个<code>jpa</code>包，然后在下面创建<code>StudentJPA</code>接口，继承<strong>JpaRepository</strong>，需要两个参数，一个时实体类对象，一个是主键类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> jpa;<br><br><span class="hljs-keyword">import</span> com.example.demo.domain.Student;<br><span class="hljs-keyword">import</span> org.springframework.data.jpa.repository.JpaRepository;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: FBY</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: 2019/10/27 14:53</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Version</span> 1.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">StudentJPA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">Student</span>,<span class="hljs-title">Integer</span>&gt; </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;查看<code>JpaRepository</code>源码可以之后该接口又继承了<code>PagingAndSortingRepository</code>和<code>QueryByExampleExecutor</code>这两个接口，<code>PagingAndSortingRepository</code>又继承了<code>CrudRepository</code>接口。这些接口基本上看名字就知道这个接口大概实现了什么方法，这就是命名规范的好处啊。</p>
<h4 id="2-2-1-CrudRepository"><a href="#2-2-1-CrudRepository" class="headerlink" title="2.2.1 CrudRepository"></a>2.2.1 CrudRepository</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看名字可以知道，该接口包含饿了crud等操作，也就是<code>creat</code>、<code>select</code>、<code>delete</code>、<code>update</code>、<code>exist</code>、<code>count</code>。如果继承了该接口，就会拥有该接口所有的实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@NoRepositoryBean</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CrudRepository</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">ID</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Repository</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">ID</span>&gt; </span>&#123;<br>    &lt;S extends T&gt; <span class="hljs-function">S <span class="hljs-title">save</span><span class="hljs-params">(S var1)</span></span>;<br>    &lt;S extends T&gt; <span class="hljs-function">Iterable&lt;S&gt; <span class="hljs-title">saveAll</span><span class="hljs-params">(Iterable&lt;S&gt; var1)</span></span>;<br>    <span class="hljs-function">Optional&lt;T&gt; <span class="hljs-title">findById</span><span class="hljs-params">(ID var1)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">existsById</span><span class="hljs-params">(ID var1)</span></span>;<br>    <span class="hljs-function">Iterable&lt;T&gt; <span class="hljs-title">findAll</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">Iterable&lt;T&gt; <span class="hljs-title">findAllById</span><span class="hljs-params">(Iterable&lt;ID&gt; var1)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">count</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deleteById</span><span class="hljs-params">(ID var1)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(T var1)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deleteAll</span><span class="hljs-params">(Iterable&lt;? extends T&gt; var1)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deleteAll</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2-2-2-PagingAndSortingRepository"><a href="#2-2-2-PagingAndSortingRepository" class="headerlink" title="2.2.2 PagingAndSortingRepository"></a>2.2.2 PagingAndSortingRepository</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该接口时分页和排序，，而且继承了<code>CrudRepository</code>接口，拥有其所有的接口实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@NoRepositoryBean</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">PagingAndSortingRepository</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">ID</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">CrudRepository</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">ID</span>&gt; </span>&#123;<br>    <span class="hljs-function">Iterable&lt;T&gt; <span class="hljs-title">findAll</span><span class="hljs-params">(Sort var1)</span></span>;<br>    <span class="hljs-function">Page&lt;T&gt; <span class="hljs-title">findAll</span><span class="hljs-params">(Pageable var1)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2-2-3-QueryByExampleExecutor"><a href="#2-2-3-QueryByExampleExecutor" class="headerlink" title="2.2.3 QueryByExampleExecutor"></a>2.2.3 QueryByExampleExecutor</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个接口实现了条件查询和复杂查询，可以使用exmple的方式查询。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">QueryByExampleExecutor</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    &lt;S extends T&gt; <span class="hljs-function">Optional&lt;S&gt; <span class="hljs-title">findOne</span><span class="hljs-params">(Example&lt;S&gt; var1)</span></span>;<br>    &lt;S extends T&gt; <span class="hljs-function">Iterable&lt;S&gt; <span class="hljs-title">findAll</span><span class="hljs-params">(Example&lt;S&gt; var1)</span></span>;<br>    &lt;S extends T&gt; <span class="hljs-function">Iterable&lt;S&gt; <span class="hljs-title">findAll</span><span class="hljs-params">(Example&lt;S&gt; var1, Sort var2)</span></span>;<br>    &lt;S extends T&gt; <span class="hljs-function">Page&lt;S&gt; <span class="hljs-title">findAll</span><span class="hljs-params">(Example&lt;S&gt; var1, Pageable var2)</span></span>;<br>    &lt;S extends T&gt; <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">count</span><span class="hljs-params">(Example&lt;S&gt; var1)</span></span>;<br>    &lt;S extends T&gt; <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">exists</span><span class="hljs-params">(Example&lt;S&gt; var1)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2-2-4-JpaRepository"><a href="#2-2-4-JpaRepository" class="headerlink" title="2.2.4 JpaRepository"></a>2.2.4 JpaRepository</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们用的就是这个接口，它拥有以上所有接口的方法实现，并且添加了条件查询和保存集合数据的方法，实现了该接口基本上简单的数据库操作就不需要我们自己写SQL语句了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@NoRepositoryBean</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">ID</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">PagingAndSortingRepository</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">ID</span>&gt;, <span class="hljs-title">QueryByExampleExecutor</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-function">List&lt;T&gt; <span class="hljs-title">findAll</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">List&lt;T&gt; <span class="hljs-title">findAll</span><span class="hljs-params">(Sort var1)</span></span>;<br>    <span class="hljs-function">List&lt;T&gt; <span class="hljs-title">findAllById</span><span class="hljs-params">(Iterable&lt;ID&gt; var1)</span></span>;<br>    &lt;S extends T&gt; <span class="hljs-function">List&lt;S&gt; <span class="hljs-title">saveAll</span><span class="hljs-params">(Iterable&lt;S&gt; var1)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">flush</span><span class="hljs-params">()</span></span>;<br>    &lt;S extends T&gt; <span class="hljs-function">S <span class="hljs-title">saveAndFlush</span><span class="hljs-params">(S var1)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deleteInBatch</span><span class="hljs-params">(Iterable&lt;T&gt; var1)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deleteAllInBatch</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">T <span class="hljs-title">getOne</span><span class="hljs-params">(ID var1)</span></span>;<br>    &lt;S extends T&gt; <span class="hljs-function">List&lt;S&gt; <span class="hljs-title">findAll</span><span class="hljs-params">(Example&lt;S&gt; var1)</span></span>;<br>    &lt;S extends T&gt; <span class="hljs-function">List&lt;S&gt; <span class="hljs-title">findAll</span><span class="hljs-params">(Example&lt;S&gt; var1, Sort var2)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="3-使用JPA"><a href="#3-使用JPA" class="headerlink" title="3. 使用JPA"></a>3. 使用JPA</h2><h3 id="3-1-创建Service层"><a href="#3-1-创建Service层" class="headerlink" title="3.1 创建Service层"></a>3.1 创建Service层</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;新建<code>jpa</code>包，在该包下创建<code>StudentuJpa</code>接口，并让其继承<code>JpaRepository</code>，这样该接口就拥有了它的所有方法实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.demo.jpa;<br><br><span class="hljs-keyword">import</span> com.example.demo.domain.Student;<br><span class="hljs-keyword">import</span> org.springframework.data.jpa.repository.JpaRepository;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: FBY</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: 2019/10/27 16:06</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Version</span> 1.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">StudentJpa</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">Student</span>,<span class="hljs-title">Integer</span>&gt; </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;新建<code>service</code>包，在该包<code>StudentService</code>接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.demo.service;<br><br><span class="hljs-keyword">import</span> com.example.demo.domain.Student;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: FBY</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: 2019/10/27 16:03</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Version</span> 1.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">StudentService</span> </span>&#123;<br>    <span class="hljs-comment">// 增加/修改</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">(Student student)</span></span>;<br>    <span class="hljs-comment">// 删除</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deleteById</span><span class="hljs-params">(Integer id)</span></span>;<br>    <span class="hljs-comment">// id查询</span><br>    <span class="hljs-function">Student <span class="hljs-title">findById</span><span class="hljs-params">(Integer id)</span></span>;<br>    <span class="hljs-comment">// 查询所有</span><br>    <span class="hljs-function">List&lt;Student&gt; <span class="hljs-title">findAll</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<code>service</code>包下新建<code>Impl</code>包，在该包下创建<code>StudentServiceImpl</code>实现类。注入<code>StudentJpa</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.demo.service.Impl;<br><br><span class="hljs-keyword">import</span> com.example.demo.domain.Student;<br><span class="hljs-keyword">import</span> com.example.demo.jpa.StudentJpa;<br><span class="hljs-keyword">import</span> com.example.demo.service.StudentService;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Optional;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: FBY</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: 2019/10/27 16:04</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Version</span> 1.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StudentServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">StudentService</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> StudentJpa studentJpa;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">(Student student)</span> </span>&#123;<br>        studentJpa.save(student);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteById</span><span class="hljs-params">(Integer id)</span> </span>&#123;<br>        studentJpa.deleteById(id);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Student <span class="hljs-title">findById</span><span class="hljs-params">(Integer id)</span> </span>&#123;<br>        Optional&lt;Student&gt; optional = studentJpa.findById(id);<br>         <span class="hljs-keyword">if</span>(optional.isPresent())&#123;<br>            <span class="hljs-keyword">return</span> optional.get();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Student&gt; <span class="hljs-title">findAll</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> studentJpa.findAll();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>关于根据主键进行查找，<code>findById(Integer id)</code>返回封装后的对象<code>Optional&lt;T&gt;</code>，在Optional类中有很多内置的方法，其中<code>isPresen()</code>方法返回Optional对象是否为null的结果，如果当前对象有值就返回<code>true</code>，否则返回<code>false</code>，当结果有值时，然后调用它的<code>get()</code>方法，会返回一个<T>类型的实体类对象，即我们要查询的对象。</p>
</blockquote>
<blockquote>
<p>根据主键查找提供的还有另一个方法，就是<code>getOne(Integer id)</code>，这个方法返回的时代理对象，无法直接操作，还有可能会出现<code>hibernate lazyxxx  no session</code>的错误，在测试方法上加上<code>@Transactional</code>注解可以解决报错的问题。</p>
</blockquote>
<h3 id="3-2-创建Controller层"><a href="#3-2-创建Controller层" class="headerlink" title="3.2 创建Controller层"></a>3.2 创建Controller层</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<code>controller</code>包下创建<code>StudentJPAController</code>类，这次测试就不再使用页面了，只需要看到返回数据即可，所以注解使用<code>@RestControlle</code>，并注入<code>StudentService</code>。返回json格式验证数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.demo.controller;<br><br><span class="hljs-keyword">import</span> com.example.demo.service.StudentService;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: FBY</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: 2019/10/27 21:34</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Version</span> 1.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StudentJPAController</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> StudentService service;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="3-3-测试"><a href="#3-3-测试" class="headerlink" title="3.3 测试"></a>3.3 测试</h3><h4 id="3-3-1-增加-修改"><a href="#3-3-1-增加-修改" class="headerlink" title="3.3.1 增加/修改"></a>3.3.1 增加/修改</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;往数据库里添加数据只需要将实体类当作参数，调用JPA的<code>save</code>方法即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/add&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">add</span><span class="hljs-params">()</span></span>&#123;<br>    Student stu = <span class="hljs-keyword">new</span> Student();<br>    stu.setName(<span class="hljs-string">&quot;fanfan&quot;</span>);<br>    stu.setAge(<span class="hljs-number">19</span>);<br>    stu.setAddress(<span class="hljs-string">&quot;郑州轻工业大学&quot;</span>);<br>    service.save(stu);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;添加成功&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>save方法不仅仅用于增加，如果传入的实体类中设置了主键，那么save方法就会变为根据主键更新数据库的操作。要注意的是save用于更新时，更新的是实体类里的所有字段，不设置值的字段会被更新成null。</p>
</blockquote>
<h4 id="3-3-2-删除"><a href="#3-3-2-删除" class="headerlink" title="3.3.2 删除"></a>3.3.2 删除</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>JpaRepository</code>提供的有根据主键删除的方法<code>deleteById</code>，直接在底层调用即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/delete.do&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">delete</span><span class="hljs-params">(Integer id)</span></span>&#123;<br>    service.deleteById(id);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;删除成功&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="3-3-4-查询"><a href="#3-3-4-查询" class="headerlink" title="3.3.4 查询"></a>3.3.4 查询</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;查询全部直接在底层使用JpaRepository内部实现的<code>findAll</code>方法。在浏览器进行访问就可以看到数据库准备的数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/findAll.do&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Student&gt; <span class="hljs-title">findAll</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> service.findAll();<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img  src="%E6%B5%8B%E8%AF%95%E6%9F%A5%E8%AF%A2%E6%89%80%E6%9C%89.png"  ><span class="image-caption">测试查询所有</span></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据id查询一个也是调用底层方法<code>findById</code>就可以实现，具体上面已经详细介绍去了，在这里就不演示了。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于实例查询,需要用到这个<strong>ExampleMatcher</strong>——匹配器。</p>
<blockquote>
<p><strong>ExampleMatcher</strong>实例查询三要素：</p>
<ul>
<li>实体对象：在ORM框架中与Table对应的域对象，一个对象代表数据库表中的一条记录，如上例中User对象，对应user表。在构建查询条件时，一个实体对象代表的是查询条件中的“数值”部分。如：要查询姓“X”的客户，实体对象只需要存储条件值“X”。</li>
<li>ExampleMatcher对象：它是匹配“实体对象”的，表示了如何使用“实体对象”中的“值”进行查询，它代表的是“查询方式”，解释了如何去查的问题。如：要查询姓“X”的客户，即姓名以“X”开头的客户，该对象就表示了“以某某开头的”这个查询方式，如上例中:withMatcher(“userName”, GenericPropertyMatchers.startsWith())</li>
<li>实例：即Example对象，代表的是完整的查询条件。由实体对象（查询条件值）和匹配器（查询方式）共同创建。最终根据实例来findAll即可。</li>
</ul>
</blockquote>
<p>示例：根据姓名、年龄、地址模糊查询。首先在<code>StudentService</code>接口里添加方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 实例查询</span><br><span class="hljs-function">List&lt;Student&gt; <span class="hljs-title">findByExample</span><span class="hljs-params">(Student student)</span></span>;<br></code></pre></td></tr></table></figure>
<p>然后在<code>StudentServiceImpl</code>类中添加实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Student&gt; <span class="hljs-title">findByExample</span><span class="hljs-params">(Student student)</span> </span>&#123;<br>    <span class="hljs-comment">// 创建匹配器，即如何使用查询条件</span><br>    ExampleMatcher matcher = ExampleMatcher.matching()      <span class="hljs-comment">//构建对象</span><br>            .withMatcher(<span class="hljs-string">&quot;name&quot;</span>,ExampleMatcher.GenericPropertyMatchers.startsWith())       <span class="hljs-comment">// &quot;姓名&quot;采用模糊查询匹配开头，即&#123;name&#125;%</span><br>            .withMatcher(<span class="hljs-string">&quot;age&quot;</span>,ExampleMatcher.GenericPropertyMatchers.contains())       <span class="hljs-comment">// &quot;年龄&quot;采用模糊查询，即%&#123;age&#125;%</span><br>            .withMatcher(<span class="hljs-string">&quot;address&quot;</span>,ExampleMatcher.GenericPropertyMatchers.contains())  <span class="hljs-comment">// &quot;地址&quot;采用模糊查询，即%&#123;address&#125;%</span><br>            .withIgnorePaths(<span class="hljs-string">&quot;id&quot;</span>,<span class="hljs-string">&quot;xxx&quot;</span>)    <span class="hljs-comment">// 忽略id和xxx字段，不管是什么值都不加入查询条件</span><br>            .withIgnoreCase()               <span class="hljs-comment">// 忽略大小写</span><br>            .withIgnoreNullValues();        <span class="hljs-comment">// 忽略空字段</span><br>    <span class="hljs-comment">// 创建实例</span><br>    Example&lt;Student&gt; example = Example.of(student,matcher);<br>    <span class="hljs-keyword">return</span> studentJpa.findAll(example);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>之后在<code>StudentJPAController</code>类编写逻辑代码，打开浏览器访问即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/findByExample.do&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Student&gt; <span class="hljs-title">findByExample</span><span class="hljs-params">(Student student)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> service.findByExample(student);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>ExampleMatcher.GenericPropertyMatcher方法</strong></p>
<ul>
<li>caseSensitive(): 字符串区分大小写。</li>
<li>contains(): 全字符模糊匹配。</li>
<li>endsWith(): 结尾模糊匹配。</li>
<li>starsWith(): 开头模糊匹配</li>
<li>exact(): 精准匹配，也就是相等。</li>
<li>ignoreCase(): 字符串不区分大小写</li>
<li>storeDefaultMatching(): 默认匹配。</li>
<li>regex(): 正则表达式匹配</li>
</ul>
<p><strong>StringMatcher参数</strong></p>
<!-- Matching|生成语句|说明 -->
<table>
<thead>
<tr>
<th>Matching</th>
<th align="center">生成语句</th>
<th align="right">说明</th>
</tr>
</thead>
<tbody><tr>
<td>DEFAULT (case-sensitive)</td>
<td align="center">firstname = ?0</td>
<td align="right">默认（大小写敏感）</td>
</tr>
<tr>
<td>DEFAULT (case-insensitive)</td>
<td align="center">LOWER(firstname) = LOWER(?0)</td>
<td align="right">默认（忽略大小写）</td>
</tr>
<tr>
<td>EXACT (case-sensitive)</td>
<td align="center">firstname = ?0</td>
<td align="right">精确匹配（大小写敏感）</td>
</tr>
<tr>
<td>EXACT (case-insensitive)</td>
<td align="center">LOWER(firstname) = LOWER(?0)</td>
<td align="right">精确匹配（忽略大小写）</td>
</tr>
<tr>
<td>STARTING (case-sensitive)</td>
<td align="center">firstname like ?0 + ‘%’</td>
<td align="right">前缀匹配（大小写敏感）</td>
</tr>
<tr>
<td>STARTING (case-insensitive)</td>
<td align="center">LOWER(firstname) like LOWER(?0) + ‘%’</td>
<td align="right">前缀匹配（忽略大小写）</td>
</tr>
<tr>
<td>ENDING (case-sensitive)</td>
<td align="center">firstname like ‘%’ + ?0</td>
<td align="right">后缀匹配（大小写敏感）</td>
</tr>
<tr>
<td>ENDING (case-insensitive)</td>
<td align="center">LOWER(firstname) like ‘%’ + LOWER(?0)</td>
<td align="right">后缀匹配（忽略大小写）</td>
</tr>
<tr>
<td>CONTAINING (case-sensitive)</td>
<td align="center">firstname like ‘%’ + ?0 + ‘%’</td>
<td align="right">模糊查询（大小写敏感）</td>
</tr>
<tr>
<td>CONTAINING (case-insensitive)</td>
<td align="center">LOWER(firstname) like ‘%’ + LOWER(?0) + ‘%’</td>
<td align="right">模糊查询（忽略大小写）</td>
</tr>
</tbody></table>
<p>补充：官方创建ExampleMatcher例子(1.8 lambda)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">ExampleMatcher matcher = ExampleMatcher.matching()<br>  .withMatcher(<span class="hljs-string">&quot;firstname&quot;</span>, match -&gt; match.endsWith())<br>  .withMatcher(<span class="hljs-string">&quot;firstname&quot;</span>, match -&gt; match.startsWith());<br>&#125;<br></code></pre></td></tr></table></figure>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除此之外，只要继承了<code>JpaRepository</code>接口，我们还能使用方法规则进行查询。举个例子，我在<code>StudentJpa</code>接口中定义一个<code>Student findByNameAndAge(String name,Integer age);</code>方法，那么它就可以直接被解析成：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">from</span> stu <span class="hljs-keyword">where</span> name<span class="hljs-operator">=</span>? <span class="hljs-keyword">and</span> age<span class="hljs-operator">=</span>? <br></code></pre></td></tr></table></figure>
<p>是不是感觉很book思议？我第一次见也是感觉很神奇，一个简单的查询就这么在底层写个方法就被实现了，完全不用多写其他的东西，在这里提供了好多方法规则查询idea自带的方法提示，超级方便。只不过它的弊端就是对于复杂的操作语句，方法名会会变得很长，而且很难精准解析。<br><img  src="%E8%A7%84%E5%88%99%E6%9F%A5%E8%AF%A2.png"  ><span class="image-caption">规则查询</span></p>
<h4 id="3-3-5-自定义语句"><a href="#3-3-5-自定义语句" class="headerlink" title="3.3.5 自定义语句"></a>3.3.5 自定义语句</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果想对SQL语句进行细致优化，我们还可以使用<code>@Query</code>注解自定义SQL语句。在<code>StudentJpa</code>接口中添加以下方法，并且自定义SQL语句。<code>nativeQuery</code>这个设置为true表明使用原生SQL，否则默认启用HQL。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Query(value = &quot;select * from stu where age&gt;=?&quot;,nativeQuery = true)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Student&gt; <span class="hljs-title">SelectByAge</span><span class="hljs-params">(Integer age)</span></span>;<br><br><span class="hljs-meta">@Transactional</span><br><span class="hljs-meta">@Modifying</span><br><span class="hljs-meta">@Query(value = &quot;delete from stu where name=?&quot;,nativeQuery = true)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteByName</span><span class="hljs-params">(String name)</span></span>;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>在@Query 注解里设置value ，?1、?2 分别代表第一第二个参数。<code>@Query</code>只能用于查询，如果想用该注解实现其他操作类型就需要配合<code>@Modifying</code>注解一起使用，但是只是这么写的话会抛出一个<code>TranscationRequiredException</code>异常，意思就是当前操作需要开启事务，所以需要在这个前加上<code>@Transactional</code>注解开启自动化管理事务。</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如同<code>@Query</code>注解一样，增删改查都可以使用原生SQL对数据库进行操作，所需要的注解分别是<code>@Insert</code>，<code>@Delete</code>，<code>@Update</code>，<code>@Select</code>。他们的在写SQL语句的时候取值可以使用<code>#&#123;&#125;</code>进行取值，内容下形参变量名。这几个属于<strong>Mybatis</strong>的注解，所以在使用的时候需要引入以下依赖。可以使用对应操作的注解，也可以使用<code>@Quey</code>加上另外两个注解配合使用。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- mybatis依赖坐标 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h4 id="3-3-6-自定义的BaseRepository"><a href="#3-3-6-自定义的BaseRepository" class="headerlink" title="3.3.6 自定义的BaseRepository"></a>3.3.6 自定义的BaseRepository</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;正常情况下一个项目肯定不可能就继承一个<code>JpaRepository</code>接口，再使用其他模块时还需要多个接口继承，如果每一个业务数据接口都继承几个相同的接口的话也不是不可以，但是对于系统设计和代码复用性来说不是个好的选择，这是我们可与创建一个我们自定的基础Repository。新建一个<code>base</code>包，在该包下创建一个<code>BaseRepositury</code>接口，并继承<code>JpaRepository</code>，日后使用其他模块时，在该接口进行添加即可。以后再创建Jpa接口只需要继承<code>BaseRepository</code>就行了，它有了<code>JpaRepository</code>所有实现方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.demo.base;<br><br><span class="hljs-keyword">import</span> org.springframework.data.jpa.repository.JpaRepository;<br><span class="hljs-keyword">import</span> org.springframework.data.repository.NoRepositoryBean;<br><span class="hljs-keyword">import</span> java.io.Serializable;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: FBY</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: 2019/10/28 21:33</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Version</span> 1.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@NoRepositoryBean</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BaseRepository</span>&lt;<span class="hljs-title">T</span>,<span class="hljs-title">PK</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Serializable</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">T</span>,<span class="hljs-title">PK</span>&gt; </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>@NoRepositoryBean:这个注解如果配置在继承了JpaRepository接口以及其他SpringDataJpa内部的接口的子接口时，子接口不会 被作为一个Repository创建代理类。</p>
</blockquote>
<h4 id="3-3-6-分页查询"><a href="#3-3-6-分页查询" class="headerlink" title="3.3.6 分页查询"></a>3.3.6 分页查询</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在一般的项目中，分页总是必不可少的，SpringDataJpa也内置了分页的方法。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先在<code>domian</code>包下创建一个<code>PageEntity</code>实体类，添加几个字段：当前页码、每页条数、排序列和排序方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.demo.domain;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: FBY</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: 2019/10/28 21:37</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Version</span> 1.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PageEntity</span> </span>&#123;<br><br>    <span class="hljs-comment">// 默认页码</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> page=<span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 默认每页数量</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> size=<span class="hljs-number">2</span>;<br>    <span class="hljs-comment">// 排序列名为id</span><br>    <span class="hljs-keyword">protected</span> String sidx=<span class="hljs-string">&quot;id&quot;</span>;<br>    <span class="hljs-comment">// 排序规则</span><br>    <span class="hljs-keyword">protected</span> String sord=<span class="hljs-string">&quot;desc&quot;</span>;<br>    <br>    <span class="hljs-comment">/*getter and setter*/</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;修改<code>Student</code>类继承<code>PageEntity</code>类，由于数据不多，这里测试就设定每页显示三条数据。在<code>StudentService</code>里面添加方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//分页查询</span><br><span class="hljs-function">List&lt;Student&gt; <span class="hljs-title">findAllPage</span><span class="hljs-params">(PageRequest pageRequest)</span></span>;<br></code></pre></td></tr></table></figure>
<p>在<code>StudentServiceImpl</code>里添加实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Student&gt; <span class="hljs-title">findAllPage</span><span class="hljs-params">(PageRequest pageRequest)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> studentJpa.findAll(pageRequest).getContent();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在<code>StudentJPAController</code>中添加新的方法，并添加对应的分页逻辑，此处分页的页码是从<strong>0</strong>开是的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/page.do&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Student&gt; <span class="hljs-title">page</span><span class="hljs-params">(Integer page)</span></span>&#123;<br>    Student student = <span class="hljs-keyword">new</span> Student();<br>    student.setSize(<span class="hljs-number">3</span>);<br>    student.setPage(page);<br>    <span class="hljs-keyword">return</span> service.findAllPage(PageRequest.of(student.getPage()-<span class="hljs-number">1</span>,student.getSize()));<br>&#125;<br></code></pre></td></tr></table></figure>
<p>接下来重启项目并访问该方法。<br><img  src="%E6%B5%8B%E8%AF%95%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2.png"  ><span class="image-caption">测试分页查询</span></p>
<h4 id="3-3-7-排序"><a href="#3-3-7-排序" class="headerlink" title="3.3.7 排序"></a>3.3.7 排序</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>PageEntity</code>已经预设好了对应的排序字段，所以重新编辑page方法，将Sort对象添加在<code>PageRequest.of()</code>方法中就可以实现排序。我们现在将顺序按照id倒序排序，SpringDataJPA对排序方式添加了一个枚举类型，创建<code>Sort</code>对象时也需要枚举对象，因为我们<code>PageEntity</code>配置的是字符串，所以上面多了一步判断排序方法返回枚举对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/page.do&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Student&gt; <span class="hljs-title">page</span><span class="hljs-params">(Integer page)</span></span>&#123;<br>    Student student = <span class="hljs-keyword">new</span> Student();<br>    student.setSize(<span class="hljs-number">3</span>);<br>    student.setPage(page);<br>    student.setSord(<span class="hljs-string">&quot;id&quot;</span>);<br>    <span class="hljs-comment">// 获取排序对象</span><br>    Sort.Direction sort_Direction = Sort.Direction.ASC.toString().equalsIgnoreCase(student.getSord()) ? Sort.Direction.ASC : Sort.Direction.DESC;<br>    <span class="hljs-comment">// 设置排序对象</span><br>    Sort sort = <span class="hljs-keyword">new</span> Sort(sort_Direction,student.getSidx());<br>    <span class="hljs-comment">// 执行排序分页</span><br>    <span class="hljs-keyword">return</span> service.findAllPage(PageRequest.of(student.getPage()-<span class="hljs-number">1</span>,student.getSize(),sort));<br>&#125;<br></code></pre></td></tr></table></figure>
<p>重启项目，刷新页面即可。</p>
<!-- ![测试排序分页](测试排序分页.png) -->
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以上就是SpringBoot整合SpringDataJPA的全部过程了，看完这篇，你就能简单使用JPA来实现项目需求了。是不是感觉很好用？对，它就是很好用。对于我们简单的数据处理真的很方便，很省事。但是大型项目中一些复杂的查询，比如一对多、多对多等，这些底层实现还是要自己动手写的，这些应该也有封装好的更方便的方法，至少对于写这篇笔记时候的我还不知道，以后慢慢了解慢慢学呗。就这么多吧，继续加油！！！</p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot-整合Thymeleaf</title>
    <url>/2019/10/24/springboot-thymeleaf/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;学习完SpringBoot之后，以后写web项目就用它了，以前开发web项目使用的还是JSP页面，但是SpringBoot官方是不支持JSP的，它默认支持的模板是Thymeleaf，既然学习了SpringBoot，怎么的也要学习一下人家的官方”原配”啊。</p>
<span id="more"></span>
<h1 id="SpringBoot整合Thymeleaf"><a href="#SpringBoot整合Thymeleaf" class="headerlink" title="SpringBoot整合Thymeleaf"></a>SpringBoot整合Thymeleaf</h1><h2 id="1-Thymeleaf"><a href="#1-Thymeleaf" class="headerlink" title="1. Thymeleaf"></a>1. Thymeleaf</h2><h3 id="1-1-模板引擎"><a href="#1-1-模板引擎" class="headerlink" title="1.1 模板引擎"></a>1.1 模板引擎</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;市面上主流的 Java 模板引擎有：JSP、Velocity、Freemarker、Thymeleaf。JSP 本质也是模板引擎，SpringBoot官方推荐使用<strong>Thymeleaf</strong>模板引擎。模板引擎原理图如下，模板引擎的作用都是将模板(页面)和数据进行整合然后输出显示，区别在于不同的模板使用不同的语法，如JSP的JSTL表达式，以及JSP自己的表达式和语法，同理Thymeleaf也有自己的语法。<br><img  src="%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E.png"  ><span class="image-caption">模板引擎</span></p>
<h3 id="1-2-简述Thymeleaf"><a href="#1-2-简述Thymeleaf" class="headerlink" title="1.2 简述Thymeleaf"></a>1.2 简述Thymeleaf</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Thymeleaf是适用于Web和独立环境的现代服务器端Java模板引擎。简单说， Thymeleaf 是一个跟 Velocity、FreeMarker 类似的模板引擎，它可以完全替代JSP。Thymeleaf的主要目标是为开发工作流程带来优雅的自然模板 -HTML可以在浏览器中正确显示，也可以作为静态原型工作，从而可以在开发团队中加强协作。</p>
<h3 id="1-3-Thymeleaf优势"><a href="#1-3-Thymeleaf优势" class="headerlink" title="1.3 Thymeleaf优势"></a>1.3 Thymeleaf优势</h3><ul>
<li>1、Thymeleaf 在有网络和无网络的环境下皆可运行，即它可以让美工在浏览器查看页面的静态效果，也可以让程序员在服务器查看带数据的动态页面效果。这是由于它支持 html 原型，然后在 html 标签里增加额外的属性来达到模板+数据的展示方式。浏览器解释 html 时会忽略未定义的标签属性，所以 thymeleaf 的模板可以静态地运行；当有数据返回到页面时，Thymeleaf 标签会动态地替换掉静态内容，使页面动态显示。</li>
<li>2、Thymeleaf 开箱即用的特性。它提供标准和spring标准两种方言，可以直接套用模板实现JSTL、 OGNL表达式效果，避免每天套模板、该jstl、改标签的困扰。同时开发人员也可以扩展和创建自定义的方言。</li>
<li>3、Thymeleaf 提供spring标准方言和一个与 SpringMVC 完美集成的可选模块，可以快速的实现表单绑定、属性编辑器、国际化等功能。</li>
</ul>
<h2 id="2-SpringBoot使用Thymeleaf"><a href="#2-SpringBoot使用Thymeleaf" class="headerlink" title="2. SpringBoot使用Thymeleaf"></a>2. SpringBoot使用Thymeleaf</h2><h3 id="2-1-配置Thymeleaf"><a href="#2-1-配置Thymeleaf" class="headerlink" title="2.1 配置Thymeleaf"></a>2.1 配置Thymeleaf</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.在pom.xml文件引入thymeleaf模板引擎依赖。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- thymeleaf依赖 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.在application.yml中配置thymeleaf模板解析器属性。thymeleaf配置是在spring配置下的。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>    <span class="hljs-attr">thymeleaf:</span><br>        <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span>                           <span class="hljs-comment"># 是否为Web框架启用Thymeleaf视图解析</span><br>        <span class="hljs-attr">prefix:</span> <span class="hljs-string">classpath:/templates/</span>           <span class="hljs-comment"># 配置视图解析器前缀</span><br>        <span class="hljs-attr">suffix:</span> <span class="hljs-string">.html</span>                           <span class="hljs-comment"># 配置试图解析器后缀</span><br>        <span class="hljs-attr">mode:</span> <span class="hljs-string">HTML</span>                              <span class="hljs-comment"># 应用于模板的html模式</span><br>        <span class="hljs-attr">encoding:</span> <span class="hljs-string">utf-8</span>                         <span class="hljs-comment"># 编码格式 </span><br>        <span class="hljs-attr">servlet.content-type:</span> <span class="hljs-string">text/html</span>         <span class="hljs-comment"># 指定请求信息格式</span><br>        <span class="hljs-attr">cache:</span> <span class="hljs-literal">false</span>                            <span class="hljs-comment"># 模板缓存。开发时关闭缓存,不然没法看到实时页面</span><br></code></pre></td></tr></table></figure>

<h3 id="2-2-使用Thymeleaf"><a href="#2-2-使用Thymeleaf" class="headerlink" title="2.2 使用Thymeleaf"></a>2.2 使用Thymeleaf</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.在templates文件夹下创建thymeleaf.html模板文件。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>亲爱的<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;name&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>，你好！<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.创建一个controller类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.demo.controller;<br><br><span class="hljs-keyword">import</span> org.springframework.stereotype.Controller;<br><span class="hljs-keyword">import</span> org.springframework.ui.Model;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: fby</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: 2019/10/24 下午7:53</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThymeleafController</span> </span>&#123;<br>    <span class="hljs-meta">@RequestMapping(&quot;/thymeleaf.do&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">thymeleaf</span><span class="hljs-params">(Model model)</span></span>&#123;<br>        model.addAttribute(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;fanfan&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;thymeleaf&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.然后启动项目，在浏览器中输入<a href="localhost:8080/thymeleaf.do">localhost:8080/thymeleaf.do</a>，成功的页面显示如下。<br><img  src="%E6%B5%8B%E8%AF%95.png"  ><span class="image-caption">测试</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**注意:**这里需要说明一下，html5创建的模板里<code>&lt;meta&gt;</code>标签是下面这样的。这个一开始是没有结束符号的，springboot默认使用的版本是<code>thymeleaf2.0</code>，如果使用<code>3.0</code>的话需要将其改写为带有结束标语的。要么就删掉，因为在<code>yml</code>文件中已经设置了编码(一般不建议)。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html">html5模板：<br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>thymeleaf3.0版本改写为<br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>

<h2 id="3-Thymeleaf详解"><a href="#3-Thymeleaf详解" class="headerlink" title="3. Thymeleaf详解"></a>3. Thymeleaf详解</h2><h3 id="3-1-引入"><a href="#3-1-引入" class="headerlink" title="3.1 引入"></a>3.1 引入</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要想在html文件里使用thymeleaf的语法，首先要现在文件里引入<code>th</code>标签的命名空间。<code>xmlns</code>属性可以在文档里定义一个或多个可供选择的命名空间。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.w3.org/1999/xhtml&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="3-2-常用th标签"><a href="#3-2-常用th标签" class="headerlink" title="3.2 常用th标签"></a>3.2 常用th标签</h3><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html">关键字          功能介绍                                           示例<br>th:id           替换id                              <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">th:id</span>=<span class="hljs-string">&quot;&#x27;xxx&#x27; + $&#123;collect.id&#125;&quot;</span>/&gt;</span><br>th:text         文本替换                            <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;collect.description&#125;&quot;</span>&gt;</span>description<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>th:utext        支持html的文本替换                  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:utext</span>=<span class="hljs-string">&quot;$&#123;htmlcontent&#125;&quot;</span>&gt;</span>conten<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>th:object       替换对象                            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:object</span>=<span class="hljs-string">&quot;$&#123;session.user&#125;&quot;</span>&gt;</span><br>th:value        属性赋值                            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">th:value</span>=<span class="hljs-string">&quot;$&#123;user.name&#125;&quot;</span> /&gt;</span><br>th:with         变量赋值运算                         <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:with</span>=<span class="hljs-string">&quot;isEven=$&#123;prodStat.count&#125;%2==0&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>th:style        设置样式                            &lt;th:style=&quot;&#x27;display:&#x27; + @&#123;($&#123;sitrue&#125; ? &#x27;none&#x27; : &#x27;inline-block&#x27;)&#125; + &#x27;&#x27;&quot;&gt;<br>th:onclick      点击事件                            &lt;th:οnclick=&quot;&#x27;getCollect()&#x27;&quot;&gt;<br>th:each         属性赋值                            <span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">&quot;user,userStat:$&#123;users&#125;&quot;</span>&gt;</span><br>th:if           判断条件                            <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:if</span>=<span class="hljs-string">&quot;$&#123;userId == collect.userId&#125;&quot;</span> &gt;</span><br>th:unless       和th:if判断相反                     <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;/login&#125;&quot;</span> <span class="hljs-attr">th:unless</span>=<span class="hljs-string">$&#123;session.user</span> != <span class="hljs-string">null&#125;</span>&gt;</span>Login<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>th:href         链接地址                            <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;/login&#125;&quot;</span> <span class="hljs-attr">th:unless</span>=<span class="hljs-string">$&#123;session.user</span> != <span class="hljs-string">null&#125;</span>&gt;</span>Login<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span> /&gt;<br>th:switch       多路选择 配合th:case 使用            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:switch</span>=<span class="hljs-string">&quot;$&#123;user.role&#125;&quot;</span>&gt;</span><br>th:case         th:switch的一个分支                  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:case</span>=<span class="hljs-string">&quot;&#x27;admin&#x27;&quot;</span>&gt;</span>User is an administrator<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>th:fragment     布局标签，定义一个代码片段，          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:fragment</span>=<span class="hljs-string">&quot;alert&quot;</span>&gt;</span><br>                方便其它地方引用   <br>th:include      布局标签，替换内容到引入的文件        <span class="hljs-tag">&lt;<span class="hljs-name">head</span> <span class="hljs-attr">th:include</span>=<span class="hljs-string">&quot;layout :: htmlhead&quot;</span> <span class="hljs-attr">th:with</span>=<span class="hljs-string">&quot;title=&#x27;xx&#x27;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span> /&gt;<br>th:replace      布局标签，替换整个标签到引入的文件     <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:replace</span>=<span class="hljs-string">&quot;fragments/header :: title&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>th:selected     selected选择框 选中                  th:selected=&quot;($&#123;xxx.id&#125; == $&#123;configObj.dd&#125;)&quot;<br>th:src          图片类地址引入                       <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;img-responsive&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;App Logo&quot;</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">&quot;@&#123;/img/logo.png&#125;&quot;</span> /&gt;</span><br>th:inline       定义js脚本可以使用变量               <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">th:inline</span>=<span class="hljs-string">&quot;javascript&quot;</span>&gt;</span><span class="handlebars"><span class="xml"></span></span><br><span class="xml"><span class="handlebars">th:action       表单提交的地址                       <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;subscribe.html&quot;</span> <span class="hljs-attr">th:action</span>=<span class="hljs-string">&quot;@&#123;/subscribe&#125;&quot;</span>&gt;</span></span></span><br><span class="xml"><span class="handlebars">th:attr         设置标签属性，多个属性可以用比如       &lt;th:attr=&quot;src=@&#123;/image/aa.jpg&#125;,title=#&#123;logo&#125;&quot;&gt;</span></span><br><span class="xml"><span class="handlebars">                逗号分隔 </span></span><br><span class="xml"><span class="handlebars">th:remove       删除某个属性                         <span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">th:remove</span>=<span class="hljs-string">&quot;all&quot;</span>&gt;</span></span></span><br><span class="xml"><span class="handlebars">　　　　　　　　　　　　　　　　　　　　			   1.all:删除包含标签和所有的孩子。</span></span><br><span class="xml"><span class="handlebars">　　　　　　　　　　　　　　　　　　　　			   2.body:不包含标记删除,但删除其所有的孩子。</span></span><br><span class="xml"><span class="handlebars">　　　　　　　　　　　　　　　　　　　　			   3.tag:包含标记的删除,但不删除它的孩子。</span></span><br><span class="xml"><span class="handlebars">　　　　　　　　　　　　　　　　　　　　			   4.all-but-first:删除所有包含标签的孩子,除了第一个。</span></span><br><span class="xml"><span class="handlebars">　　　　　　　　　　　　　　　　　　　　			   5.none:什么也不做。这个值是有用的动态评估。</span></span><br></code></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还有非常多的标签，这里只列出最常用的几个,由于一个标签内可以包含多个th:x属性，其生效的优先级顺序为:<br>include,each,if/unless/switch/case,with,attr/attrprepend/attrappend,value/href,src ,etc,text/utext,fragment,remove。</p>
<h3 id="3-3-常用语法"><a href="#3-3-常用语法" class="headerlink" title="3.3 常用语法"></a>3.3 常用语法</h3><h4 id="3-3-1-标准表达式"><a href="#3-3-1-标准表达式" class="headerlink" title="3.3.1 标准表达式"></a>3.3.1 标准表达式</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Thymeleaf语法有很多，想更深入了解的话可以去看<a href="https://www.thymeleaf.org/doc/tutorials/2.1/usingthymeleaf.html">官方文档</a>。在这先简单介绍一下标准表达式功能：</p>
<ul>
<li>简单表达式<ul>
<li>变量表达式: <strong>${…}</strong></li>
<li>选择表达式: <strong>*{…}</strong></li>
<li>消息表达式: <strong>#{…}</strong></li>
<li>链接URL表达式: <strong>@{…}</strong></li>
</ul>
</li>
<li>文字<ul>
<li>文本文字: <code>&#39;one text&#39;</code>，…</li>
<li>号码文字: <code>0</code>，<code>34</code>，<code>3.2</code>，…</li>
<li>布尔文字: <code>true</code>，<code>false</code></li>
<li>空文字: <code>null</code></li>
<li>文字标记: <code>one</code>，<code>sometext</code>，…</li>
</ul>
</li>
<li>文字操作<ul>
<li>字符串串联: <code>+</code></li>
<li>文字替换: <code>|The name is $&#123;naem&#125;|</code></li>
</ul>
</li>
<li>算数运算<ul>
<li>二元运算符: <code>+</code>，<code>-</code>，<code>*</code>，<code>/</code>，<code>%</code></li>
<li>减号(一元运算符): <code>-</code></li>
</ul>
</li>
<li>布尔运算<ul>
<li>二元运算符: <code>and</code>，<code>or</code></li>
<li>布尔否定(一元运算符): <code>!</code>，<code>not</code></li>
</ul>
</li>
<li>比较和平等<ul>
<li>比较: <code>&gt;</code>，<code>&lt;</code>，<code>&gt;=</code>，<code>&lt;=</code> <code>（gt，lt，ge，le）</code></li>
<li>等号运算符: <code>==</code>，<code>!=</code> <code>(eq，ne)</code></li>
</ul>
</li>
<li>条件运算符<ul>
<li>如果-则: <code>(if) ? (then)</code></li>
<li>如果-则-否则: <code>(if) ? (then) : (else)</code></li>
<li>默认: <code>(value) ?: (defautvalue)</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>以上所有的这些功能都可以进行组合和嵌套。<br><code>&#39;User is of type &#39; + ($&#123;user.isAdmin()&#125; ? &#39;Administrator&#39; : ($&#123;user.type&#125; ?: &#39;Unknown&#39;))</code></p>
</blockquote>
<h4 id="3-3-2-赋值、字符串的拼接"><a href="#3-3-2-赋值、字符串的拼接" class="headerlink" title="3.3.2 赋值、字符串的拼接"></a>3.3.2 赋值、字符串的拼接</h4><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 直接取值 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>  <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;collect.description&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 标签内赋值 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>hello，[[$&#123;collect.description&#125;]]<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 取值拼接 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;&#x27;Welcome to our application, &#x27; + $&#123;user.name&#125; + &#x27;!&#x27;&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;字符串拼接还有另外一种简洁的写法。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;|Welcome to our application, $&#123;user.name&#125;!|&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h4 id="3-3-3-条件判断If-Unless"><a href="#3-3-3-条件判断If-Unless" class="headerlink" title="3.3.3 条件判断If/Unless"></a>3.3.3 条件判断If/Unless</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Thymeleaf中使用<code>th:if</code>和<code>th:unless</code>属性进行条件判断，下面的例子中，<code>&lt;a&gt;</code>标签只有在th:if中条件成立时才显示：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:if</span>=<span class="hljs-string">&quot;$&#123;myself==&#x27;yes&#x27;&#125;&quot;</span> &gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:unless</span>=<span class="hljs-string">$&#123;session.user</span> != <span class="hljs-string">null&#125;</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;/login&#125;&quot;</span> &gt;</span>Login<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>th:unless于th:if恰好相反，只有表达式中的条件不成立，才会显示其内容。<br>也可以使用 (if) ? (then) : (else) 这种语法来判断显示的内容。</p>
</blockquote>
<h4 id="3-3-4-for循环"><a href="#3-3-4-for循环" class="headerlink" title="3.3.4 for循环"></a>3.3.4 for循环</h4><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>  <span class="hljs-attr">th:each</span>=<span class="hljs-string">&quot;item,iterStat : $&#123;list&#125;&quot;</span>&gt;</span> <br>   <span class="hljs-tag">&lt;<span class="hljs-name">th</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;row&quot;</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;collect.id&#125;&quot;</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">td</span> &gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">&quot;$&#123;item.webLogo&#125;&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;item.url&#125;&quot;</span>&gt;</span>Mark<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;item.title&#125;&quot;</span>&gt;</span>Otto<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;item.description&#125;&quot;</span>&gt;</span>@mdo<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;item.index&#125;&quot;</span>&gt;</span>index<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>list是后台传入的数据，item是设置每次循环的对象名(自定义)。</p>
</blockquote>
<p>iterStat称作状态变量，属性有:</p>
<ul>
<li>index: 当前迭代对象的index(从0开始计算)</li>
<li>count: 当前迭代对象的index(从1开始计算)</li>
<li>size: 被迭代对象的大小</li>
<li>current: 当前迭代变量</li>
<li>even/odd: 布尔值，当前循环是否是偶数/奇数(从0开始计算)</li>
<li>first: 布尔值，当前循环是否是第一个</li>
<li>last: 布尔值，当前循环是否是最后一个</li>
</ul>
<h4 id="3-3-5-URL"><a href="#3-3-5-URL" class="headerlink" title="3.3.5 URL"></a>3.3.5 URL</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;URL在Web应用模板中占据着十分重要的地位，需要特别注意的是Thymeleaf对于URL的处理是通过语法 **@{…}**来处理的。如果需要Thymeleaf对URL进行渲染，那么务必使用<code>th:href</code>，<code>th:src</code>等属性，也可以用来引入css、js、图片等文件。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 超链接 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;/order/&#123;orderId&#125;/details(orderId=$&#123;o.id&#125;)&#125;&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 引入css --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;@&#123;/css/bootstrap.min.css&#125;&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 设置背景 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:style</span>=<span class="hljs-string">&quot;&#x27;background:url(&#x27; + @&#123;/&lt;path-to-image&gt;&#125; + &#x27;);&#x27;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 根据属性值改变背景 --&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;media-object resource-card-image&quot;</span>  <span class="hljs-attr">th:style</span>=<span class="hljs-string">&quot;&#x27;background:url(&#x27; + @&#123;($&#123;collect.webLogo&#125;==&#x27;&#x27; ? &#x27;img/favicon.png&#x27; : $&#123;collect.webLogo&#125;)&#125; + &#x27;)&#x27;&quot;</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>几点说明：</p>
<ul>
<li>上列中URL最后的(orderId=${o.id})表示将括号内的内容作为URL参数处理，该语法避免使用字符串拼接，大大提高了可读性。</li>
<li>@{…}表达式中可以通过{orderId}访问COntext中的orderId变量。</li>
<li>@{/order}是Context相关的相对路径，在渲染时会自动添加上当前Web应用的Context名字。例如contest名字为app，那么解析的结果就是/app/order。</li>
</ul>
<h4 id="3-3-6-内联JS"><a href="#3-3-6-内联JS" class="headerlink" title="3.3.6 内联JS"></a>3.3.6 内联JS</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;内联文本：**[[…]]<strong>内联文本的表示方式，</strong>[[…]]<strong>之间的内容可以被赋值。为了使其生效，必须在此标签或者任何父标签上有</strong>th:inline<strong>属性。此属性有三种值(<code>text</code>、<code>javascript</code>、<code>none</code>)。</strong>th:inline**也可以在父标签上使用，比如作为body上的标签。表达式在javascript中使用时，先用属性声明一下：th:inline=”javascript”，然后我们开始在js中声明变量：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">&lt;script th:inline=<span class="hljs-string">&quot;javascript&quot;</span>&gt;<br>    <span class="hljs-comment">/*&lt;![CDATA[*/</span><br>        ...<br>        <span class="hljs-keyword">var</span> username = <span class="hljs-comment">/*[[$&#123;session.user.name&#125;]]*/</span> <span class="hljs-string">&#x27;Sebastian&#x27;</span>;<br>        ...<br>    <span class="hljs-comment">/*]]&gt;*/</span><br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>
<p>**/*[[…]]*/**表达式的理解如下;</p>
<ul>
<li>/*…*/中的内容子啊浏览器打开静态网页时会被忽略。</li>
<li>‘Sebastian’ 会在浏览器中显示。(静态时)。</li>
<li>Thymeleaf解析时，会解析/*[[…]]*/的内容，并把获得的值替换掉/*[[…]]*/后面的内容。</li>
</ul>
<p>所以执行的结果如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">&lt;script th:inline=<span class="hljs-string">&quot;javascript&quot;</span>&gt;<br>    <span class="hljs-comment">/*&lt;![CDATA[*/</span><br>        ...<br>        <span class="hljs-keyword">var</span> username = <span class="hljs-string">&#x27;John Apricot&#x27;</span>;<br>        ...<br>    <span class="hljs-comment">/*]]&gt;*/</span><br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>
<p>当然，你也可以不用注释，就像下面这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">&lt;script th:inline=<span class="hljs-string">&quot;javascript&quot;</span>&gt;<br>    <span class="hljs-comment">/*&lt;![CDATA[*/</span><br>        ...<br>        <span class="hljs-keyword">var</span> username = [[$&#123;session.user.name&#125;]];<br>        ...<br>    <span class="hljs-comment">/*]]&gt;*/</span><br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>
<p>这会让它在静态显示时出现错误。</p>
<blockquote>
<p>注意：引擎求值后注入式是智能的，它可以赋值以下类型的数据：<code>String</code>、<code>Numbers</code>、<code>Booleans</code>、<code>Arrays</code>、<code>Collections</code>、<code>Maps</code>、<code>Beans (objects with getter and setter methods)</code>。</p>
</blockquote>
<p>举个栗子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">script th:inline=<span class="hljs-string">&quot;javascript&quot;</span>&gt;<br>    <span class="hljs-comment">/*&lt;![CDATA[*/</span><br>    ...<br>    <span class="hljs-keyword">var</span> user = <span class="hljs-comment">/*[[$&#123;session.user&#125;]]*/</span> <span class="hljs-literal">null</span>;<br>    ...<br>    <span class="hljs-comment">/*]]&gt;*/</span><br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>
<p>${session.user}会获取一个user对象。写入如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">&lt;script th:inline=<span class="hljs-string">&quot;javascript&quot;</span>&gt;<br>    <span class="hljs-comment">/*&lt;![CDATA[*/</span><br>    ...<br>    <span class="hljs-keyword">var</span> user = &#123;<span class="hljs-string">&#x27;age&#x27;</span>:<span class="hljs-literal">null</span>,<span class="hljs-string">&#x27;firstName&#x27;</span>:<span class="hljs-string">&#x27;John&#x27;</span>,<span class="hljs-string">&#x27;lastName&#x27;</span>:<span class="hljs-string">&#x27;Apricot&#x27;</span>,<br>    <span class="hljs-string">&#x27;name&#x27;</span>:<span class="hljs-string">&#x27;John Apricot&#x27;</span>,<span class="hljs-string">&#x27;nationality&#x27;</span>:<span class="hljs-string">&#x27;Antarctica&#x27;</span>&#125;;<br>    ...<br>    <span class="hljs-comment">/*]]&gt;*/</span><br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>

<p>引擎同样允许增加和删除代码块。增加代码块：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-number">23</span>;<br><span class="hljs-comment">/*[+</span><br><span class="hljs-comment">var msg = &#x27;This is a working application&#x27;;</span><br><span class="hljs-comment">+]*/</span><br><span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>...<br></code></pre></td></tr></table></figure>
<p>解析如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-number">23</span>;<br><span class="hljs-keyword">var</span> msg = <span class="hljs-string">&#x27;This is a working application&#x27;</span>;<br><span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>...<br></code></pre></td></tr></table></figure>
<p>删除代码块：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-number">23</span>;<br><span class="hljs-comment">/*[- */</span><br><span class="hljs-keyword">var</span> msg = <span class="hljs-string">&#x27;This is a non-working template&#x27;</span>;<br><span class="hljs-comment">/* -]*/</span><br><span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>...<br></code></pre></td></tr></table></figure>
<p>解析如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-number">23</span>;<br><span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>...<br></code></pre></td></tr></table></figure>
<blockquote>
<p>增加和删除代码块只是有这一块的知识点，所以暂时先写上了，但是具体是干啥的，我也不清楚，反正我是没用到。</p>
</blockquote>
<h4 id="3-3-7-信息表达式"><a href="#3-3-7-信息表达式" class="headerlink" title="3.3.7 信息表达式"></a>3.3.7 信息表达式</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先举个简单的栗子:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">&lt;p th:utext=<span class="hljs-string">&quot;#&#123;home.welcome&#125;&quot;</span>&gt;Welcome to our grocery store!&lt;/p&gt;<br></code></pre></td></tr></table></figure>
<p>其中<code>home.welcome=欢迎光临本店</code>。<br>如果消息文本不完全是静态的会发生什么？有时候我们需要在消息中增加变量，比如输出访问者的名字怎么办？可以这样办：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">&lt;p th:utext=<span class="hljs-string">&quot;#&#123;home.welcome($&#123;session.user.name&#125;)&#125;&quot;</span>&gt;<br>Bienvenido a nuestra tienda de comestibles, 木鱼!<br>&lt;/p&gt;<br></code></pre></td></tr></table></figure>
<p>其中<code>home.welcome=欢迎光临本店, &#123;0&#125;!</code><br>在这里，参数可以是字符型也可是树数值型或者日期型。当然如果我们需要多个参数的话，类推即可，并且我们也可以内嵌表达式替换字符串，比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">&lt;p th:utext=<span class="hljs-string">&quot;#&#123;$&#123;welcomeMsgKey&#125;($&#123;session.user.name&#125;)&#125;&quot;</span>&gt;<br>Welcome to our grocery store, 木鱼!<br>&lt;/p&gt;<br></code></pre></td></tr></table></figure>

<h4 id="3-3-8-选择表达式"><a href="#3-3-8-选择表达式" class="headerlink" title="3.3.8 选择表达式"></a>3.3.8 选择表达式</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;变量不仅能用在#{ }上，还能用在* { }上。两者的区别在于* { }上的的变量首先是选定对象的变量。如果不选定对象，那么是整个上下文环境中的变量和#{ }相同。选择对象用什么呢?<code>th:object</code>标签属性。我们使用它在我们的用户配置文件(userprofile.html)页面:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">&lt;div th:object=<span class="hljs-string">&quot;$&#123;session.user&#125;&quot;</span>&gt;<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Name: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;*&#123;firstName&#125;&quot;</span>&gt;</span>Sebastian<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Surname: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;*&#123;lastName&#125;&quot;</span>&gt;</span>Pepper<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Nationality: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;*&#123;nationality&#125;&quot;</span>&gt;</span>Saturn<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br>&lt;/div&gt;<br></code></pre></td></tr></table></figure>
<p>这个语法等同于以下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">&lt;div&gt;<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Name: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;session.user.firstName&#125;&quot;</span>&gt;</span>Sebastian<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Surname: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;session.user.lastName&#125;&quot;</span>&gt;</span>Pepper<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Nationality: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;session.user.nationality&#125;&quot;</span>&gt;</span>Saturn<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br>&lt;/div&gt;<br></code></pre></td></tr></table></figure>
<p>当然了，这两种用法是可以混合的:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">&lt;div th:object=<span class="hljs-string">&quot;$&#123;session.user&#125;&quot;</span>&gt;<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Name: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;*&#123;firstName&#125;&quot;</span>&gt;</span>Sebastian<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Surname: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;session.user.lastName&#125;&quot;</span>&gt;</span>Pepper<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Nationality: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;*&#123;nationality&#125;&quot;</span>&gt;</span>Saturn<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br>&lt;/div&gt;<br></code></pre></td></tr></table></figure>
<p>如果一个对象已经被选择，即th:object=”${session.user}”。那么我们也可以使用#object对象去引用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">&lt;div th:object=<span class="hljs-string">&quot;$&#123;session.user&#125;&quot;</span>&gt;<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Name: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;#object.firstName&#125;&quot;</span>&gt;</span>Sebastian<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Surname: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;session.user.lastName&#125;&quot;</span>&gt;</span>Pepper<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Nationality: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;*&#123;nationality&#125;&quot;</span>&gt;</span>Saturn<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br>&lt;/div&gt;<br></code></pre></td></tr></table></figure>
<p>就像之前说的，如果没有对象被选中，那么<code>#&#123;&#125;</code>和<code>*&#123;&#125;</code>表达式的意义是相同的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">&lt;div&gt;<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Name: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;*&#123;session.user.name&#125;&quot;</span>&gt;</span>Sebastian<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Surname: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;*&#123;session.user.surname&#125;&quot;</span>&gt;</span>Pepper<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Nationality: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;*&#123;session.user.nationality&#125;&quot;</span>&gt;</span>Saturn<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br>&lt;/div&gt;<br></code></pre></td></tr></table></figure>

<h3 id="3-4-基本对象"><a href="#3-4-基本对象" class="headerlink" title="3.4 基本对象"></a>3.4 基本对象</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在上下文变量上评估OGNL表达式时，某些对象可用于表达式，以提高灵活性。这些对象（根据OGNL标准）将以#符号开头进行引用。</p>
<h4 id="3-4-1-基础对象"><a href="#3-4-1-基础对象" class="headerlink" title="3.4.1 基础对象"></a>3.4.1 基础对象</h4><ul>
<li><strong>#ctx</strong>: 上下文对象。</li>
<li><strong>#vars</strong>: 上下文变量。</li>
<li><strong>#locale</strong>: 上下文语言环境。</li>
<li><strong>#httpSession</strong>: HttpSession对象(仅在Web上下文中)。</li>
<li><strong>#httpServletRequest</strong>: HttpServletRequest对象(仅在Web上下文中)。</li>
</ul>
<p>可以通过以下方式引用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">Established locale country: <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;#locale.country&#125;&quot;</span>&gt;</span>US<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span>.<br></code></pre></td></tr></table></figure>

<h4 id="3-4-2-请求-会话属性等Web上下文名称空间"><a href="#3-4-2-请求-会话属性等Web上下文名称空间" class="headerlink" title="3.4.2 请求/会话属性等Web上下文名称空间"></a>3.4.2 请求/会话属性等Web上下文名称空间</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Web环境中使用Thymeleaf时，我们可以使用一系列快捷方式来访问请求参数，会话属性和应用程序属性。</p>
<blockquote>
<p>请注意，这些不是上下文对象，而是作为变量添加到上下文中的映射，因此我们不使用即可访问它们#。因此，它们以某种方式充当命名空间。</p>
</blockquote>
<ul>
<li><strong>param</strong>: 用于检索请求参数。${param.foo}是String[]带有foorequest参数值的a ，因此${param.foo[0]}通常用于获取第一个值。</li>
<li><strong>session</strong>: 用于获取会话属性。例如<code>$&#123;session.user.name&#125;</code>。</li>
<li><strong>application</strong>: 用于检索应用程序/ servlet上下文属性。</li>
</ul>
<h4 id="3-4-3-Web上下文对象"><a href="#3-4-3-Web上下文对象" class="headerlink" title="3.4.3 Web上下文对象"></a>3.4.3 Web上下文对象</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Web环境中，还可以直接访问以下对象(请注意，这些是对象，而不是映射/命名空间)。</p>
<ul>
<li><strong>#httpServletRequest</strong>: 直接访问<code>javax.servlet.http.HttpServletRequest</code>与当前请求关联的对象。</li>
<li><strong>#httpSession</strong>: 直接访问<code>javax.servlet.http.HttpSession</code>与当前请求关联的对象。</li>
</ul>
<blockquote>
<p>这里只是简单说一下这些对象，因为我也没有用过，想要深入使用的可以在<a href="https://www.thymeleaf.org/doc/tutorials/2.1/usingthymeleaf.html#appendix-a-expression-basic-objects">官网附录A</a>中阅读这些对象的完整参考。 </p>
</blockquote>
<h3 id="3-5-Thymeleaf对象"><a href="#3-5-Thymeleaf对象" class="headerlink" title="3.5 Thymeleaf对象"></a>3.5 Thymeleaf对象</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除了这些基本的对象,Thymeleaf将为我们提供一套实用的对象。来帮助我们我们执行常见的任务。</p>
<ul>
<li><strong>#dates</strong> : 为 java.util.Date对象提供工具方法,比如：格式化,提取年月日等.</li>
<li><strong>#calendars</strong> : 类似于#dates , 但是只针对java.util.Calendar对象.</li>
<li><strong>#numbers</strong> : 为数值型对象提供工具方法。</li>
<li><strong>#strings</strong> :为String 对象提供工具方法。如: contains, startsWith, prepending/appending等。</li>
<li><strong>#objects</strong> : 为object 对象提供常用的工具方法。</li>
<li><strong>#bools</strong> : 为boolean 对象提供常用的工具方法。</li>
<li><strong>#arrays</strong> : 为arrays 对象提供常用的工具方法。</li>
<li><strong>#lists</strong> :为lists对象提供常用的工具方法。</li>
<li><strong>#sets</strong> : 为sets对象提供常用的工具方法。</li>
<li><strong>#maps</strong> : 为maps对象提供常用的工具方法。</li>
<li><strong>#aggregates</strong> :为创造一个arrays 或者 collections聚集函数提供常用的工具方法。</li>
<li><strong>#messages</strong> : 用于获取变量表达式内的外部化消息，其方式与使用<code>#&#123;...&#125;</code>语法获得消息的方式相同。</li>
<li><strong>#ids</strong> : 处理id可能重复的属性的实用方法(例如，由于迭代的结果)。</li>
</ul>
<blockquote>
<p>这里只是简单说一下这些对象，因为我也没有用过，想要深入使用的可以在<a href="https://www.thymeleaf.org/doc/tutorials/2.1/usingthymeleaf.html#appendix-b-expression-utility-objects">官网附录B</a>中阅读这些对象的完整参考。</p>
</blockquote>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在写这篇博客之前关于Thyemleaf模板引擎我也就用过一次，踩过的坑也不少，所以写这篇博客时才各种百度、官网文档等等的去搜集相关知识，整理个也算比较详细了。用的比较多的那些给的都有示例代码，其他的先暂时当作了解，日后开发项目有需要了再来过看。</p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序-登录操作</title>
    <url>/2020/02/03/wechatApp-login/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之前没事写了一个微信小程序玩，刚起步就碰壁，因为要获取用户授权，然后请求用户的个人信息，由于微信官方api的更改,<code>wx.getUserInfo()</code>方法无法在无授权的情况下直接使用，而且只能获取到基本的一些微信用户的信息，不包含我们需要的<code>openId</code>以及<code>unionId</code>。几经折腾，才把这个第一步给迈过去，来记录一下。</p>
<span id="more"></span>

<h1 id="小程序-登录操作"><a href="#小程序-登录操作" class="headerlink" title="小程序-登录操作"></a>小程序-登录操作</h1><h2 id="1-登录流程"><a href="#1-登录流程" class="headerlink" title="1. 登录流程"></a>1. 登录流程</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;想要获取用户的登录信息，首先要先知道小程序的登录流程是什么，下面是官方给出的流程图。</p>
<p><img  src="%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B%E5%9B%BE.png"  ><span class="image-caption">登录流程图</span></p>
<h3 id="1-1-第一步：获取code"><a href="#1-1-第一步：获取code" class="headerlink" title="1.1 第一步：获取code"></a>1.1 第一步：获取code</h3><p>1、小程序调用wx.login() 获取<strong>临时登录凭证code</strong>，并回传到开发者服务器。</p>
<p>2、开发者服务器以code换取<strong>用户唯一标识openid</strong>和<strong>会话密钥session_key</strong>。</p>
<p>3、之后开发者服务器可以根据用户标识来生成自定义登录态，用于后续业务逻辑中前后端交互时识别用户身份。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于unionId，这里需要说明一下，如果应用只限于小程序内则不需要unionId,直接通过openId可以确定用户身份，但是如果需要跨应用，如：网页应用，app应用时则需要使用到unionId作为身份标识。</p>
<p>UnionID获取途径：绑定了开发者帐号的小程序，可以通过下面3种途径获取UnionID。</p>
<p>1、调用接口wx.getUserInfo，从解密数据中获取UnionID。注意本接口需要用户授权，请开发者妥善处理用户拒绝授权后的情况。</p>
<p>2、如果开发者帐号下存在同主体的公众号，并且该用户已经关注了该公众号。开发者可以直接通过wx.login获取到该用户UnionID，无须用户再次授权。</p>
<p>3、如果开发者帐号下存在同主体的公众号或移动应用，并且该用户已经授权登录过该公众号或移动应用。开发者也可以直接通过wx.login获取到该用户UnionID，无须用户再次授权。</p>
<h3 id="1-2-第二步：通过code换取个人信息"><a href="#1-2-第二步：通过code换取个人信息" class="headerlink" title="1.2 第二步：通过code换取个人信息"></a>1.2 第二步：通过code换取个人信息</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当前台获得了用户的授权后，我们就可以获得用户的个人信息以及unionId。</p>
<p>前台接口：**wx.getUserInfo(Object)**。</p>
<p><strong>注意：</strong>此接口现在经果调整之后，使用该接口将不再出现授权弹窗，需要使用<code>&lt;button open-type=&quot;getUserInfo&quot;&gt;&lt;/button&gt;</code>引导用户主动进行授权操作。详情见、查看<a href="https://developers.weixin.qq.com/community/develop/doc/000aee01f98fc0cbd4b6ce43b56c01">官方文档</a>。</p>
<p><strong>Object参数说明：</strong></p>
<table>
<thead>
<tr>
<th align="center">参数名</th>
<th align="center">类型</th>
<th align="center">必填</th>
<th>说明</th>
<th align="center">最低版本</th>
</tr>
</thead>
<tbody><tr>
<td align="center">withCredentials</td>
<td align="center">Boolean</td>
<td align="center">否</td>
<td>是否带上登录信息</td>
<td align="center">1.1.0</td>
</tr>
<tr>
<td align="center">lang</td>
<td align="center">String</td>
<td align="center">否</td>
<td>指定返回用户信息的语言，zh_CN：简体中文，zh_TW：繁体中文，en：英文。默认en</td>
<td align="center">1.3.0</td>
</tr>
<tr>
<td align="center">timeout</td>
<td align="center">Number</td>
<td align="center">否</td>
<td>超时时间，单位ms</td>
<td align="center">1.9.90</td>
</tr>
<tr>
<td align="center">success</td>
<td align="center">Function</td>
<td align="center">否</td>
<td>接口调用成功的回调函数</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">fail</td>
<td align="center">Function</td>
<td align="center">否</td>
<td>接口调用失败的回调函数</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">complete</td>
<td align="center">Function</td>
<td align="center">否</td>
<td>接口调用结束的回调函数(调用成功、失败都会执行)</td>
<td align="center"></td>
</tr>
</tbody></table>
<blockquote>
<p>注：当 withCredentials 为 true 时，要求此前有调用过 wx.login 且登录态尚未过期，此时返回的数据会包含 encryptedData, iv 等敏感信息；当 withCredentials 为 false 时，不要求有登录态，返回的数据不包含 encryptedData, iv 等敏感信息。</p>
</blockquote>
<p><strong>success返回参数说明：</strong></p>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">类型</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">userInfo</td>
<td align="center">Object</td>
<td align="left">用户信息对象，不包括openid等敏感信息</td>
</tr>
<tr>
<td align="center">rawData</td>
<td align="center">String</td>
<td align="left">不包括敏感信息的原始数据字符串，用于计算签名</td>
</tr>
<tr>
<td align="center">signature</td>
<td align="center">String</td>
<td align="left">使用sha1( rawData + sessionkey ) 得到字符串，用于校验用户信息。</td>
</tr>
<tr>
<td align="center">encryptedData</td>
<td align="center">String</td>
<td align="left">包括敏感数据在内的完整用户信息的加密数据，详细见[<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/signature.html#%E5%8A%A0%E5%AF%86%E6%95%B0%E6%8D%AE%E8%A7%A3%E5%AF%86%E7%AE%97%E6%B3%95">用户数据的签名验证和加解密</a></td>
</tr>
<tr>
<td align="center">iv</td>
<td align="center">String</td>
<td align="left">加密算法的初始向量，详见 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/signature.html#%E5%8A%A0%E5%AF%86%E6%95%B0%E6%8D%AE%E8%A7%A3%E5%AF%86%E7%AE%97%E6%B3%95">用户数据的签名验证和加解密</a></td>
</tr>
</tbody></table>
<h2 id="2-代码解析"><a href="#2-代码解析" class="headerlink" title="2. 代码解析"></a>2. 代码解析</h2><h3 id="2-1-微信端代码"><a href="#2-1-微信端代码" class="headerlink" title="2.1 微信端代码"></a>2.1 微信端代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//index.js</span><br><br><span class="hljs-comment">// 自定义的登录方法，判断用户登录，是否授权</span><br><span class="hljs-attr">login</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> that = <span class="hljs-built_in">this</span><br>    wx.login(&#123;<br>        <span class="hljs-attr">success</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">r</span>) </span>&#123;<br>            <span class="hljs-comment">//获取登录凭证</span><br>            <span class="hljs-keyword">var</span> code = r.code; <br>            <span class="hljs-keyword">if</span> (code) &#123;<br>                <span class="hljs-comment">// 获取用户设置信息</span><br>                wx.getSetting(&#123;<br>                    <span class="hljs-attr">success</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">re</span>) </span>&#123;<br>                        <span class="hljs-comment">// 判断用户是否授权</span><br>                        <span class="hljs-keyword">if</span> (re.authSetting[<span class="hljs-string">&#x27;scope.userInfo&#x27;</span>]) &#123;<br>                            <span class="hljs-comment">// 已经授权了，就进行后台用户数据写入</span><br>                            that.register(code)<br>                        &#125; <span class="hljs-keyword">else</span> &#123;<br>                            <span class="hljs-comment">//未授权，跳转到登录页面</span><br>                            wx.redirectTo(&#123;<br>                                <span class="hljs-attr">url</span>:<span class="hljs-string">&#x27;XXX/XXX&#x27;</span>,<br>                            &#125;)<br>                        &#125;<br>                    &#125;<br>                &#125;)<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;获取用户登录状态失败！&quot;</span> + r.errMsg)<br>            &#125;<br>        &#125;,<br>        <span class="hljs-attr">fail</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;登录失败&quot;</span>)<br>        &#125;<br>    &#125;)<br>&#125;,<br><br><span class="hljs-comment">// 获取到用户的登录授权，请求后台，进行用户信息的操作</span><br><span class="hljs-attr">register</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">code</span>) </span>&#123;<br>    <span class="hljs-comment">//2.调用获取用户信息接口</span><br>    wx.getUserInfo(&#123;<br>        <span class="hljs-attr">success</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) </span>&#123;<br>            <span class="hljs-comment">//3.请求自己的服务器，解密用户信息，获取unionld等加密信息</span><br>            wx.request(&#123;<br>                <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;XXX/login.do&#x27;</span>,	<span class="hljs-comment">//自己后台服务器接口地址</span><br>                <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>, 		<span class="hljs-comment">//请求方式</span><br>                <span class="hljs-comment">// 请求头消息</span><br>                <span class="hljs-attr">header</span>: &#123;<br>                    <span class="hljs-string">&#x27;content-type&#x27;</span>: <span class="hljs-string">&#x27;application/x-www-form-urlencoded&#x27;</span><br>                &#125;,<br>                <span class="hljs-comment">// 请求接口时传的参数</span><br>                <span class="hljs-attr">data</span>: &#123;<br>                    <span class="hljs-attr">encryptedData</span>: res.encryptedData,	<span class="hljs-comment">//加密数据</span><br>                    <span class="hljs-attr">iv</span>: res.iv,				<span class="hljs-comment">//加密算法的初使向量</span><br>                    <span class="hljs-attr">code</span>: code		<span class="hljs-comment">//登录凭证</span><br>                &#125;,<br>                <span class="hljs-attr">success</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;<br>                    <span class="hljs-comment">//4.解密成功后，获取自己服务器返回的结果</span><br>                    <span class="hljs-keyword">if</span> (data.data.status == <span class="hljs-number">1</span>) &#123;<br>                        <span class="hljs-comment">// 解密成功之后更换登录状态</span><br>                        app.globalData.checkLogin = <span class="hljs-literal">true</span><br>                        <span class="hljs-comment">// 接收请求数据</span><br>                        <span class="hljs-keyword">var</span> userInfo_ = data.data.userInfo;<br>                        <span class="hljs-comment">// 设置用户信息</span><br>                        app.globalData.userInfo = userInfo_;<br>                        app.globalData.openId = userInfo_.openId<br>                        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;用户信息：&quot;</span>, userInfo_);<br>                        <br>                        <span class="hljs-comment">//由于这里是网络请求，可能会在 Page.onLoad 之后才返回</span><br>                        <span class="hljs-comment">// 所以此处加入 callback 以防止这种情况</span><br>                        <span class="hljs-keyword">if</span> (app.checkLoginReadyCallback) &#123;<br>                            app.checkLoginReadyCallback(data);<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;解密失败&quot;</span>)<br>                    &#125;<br>                &#125;,<br>                <span class="hljs-attr">fail</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>                    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;系统错误&quot;</span>)<br>                &#125;<br>            &#125;)<br>        &#125;,<br>        <span class="hljs-attr">fail</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;获取用户信息失败&quot;</span>)<br>        &#125;<br>    &#125;)<br>&#125;,<br></code></pre></td></tr></table></figure>

<h3 id="2-2-服务器端Java代码"><a href="#2-2-服务器端Java代码" class="headerlink" title="2.2 服务器端Java代码"></a>2.2 服务器端Java代码</h3><p>控制层：WXLoginController .java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> controller;<br><br><span class="hljs-keyword">import</span> mapper.UserMapper;<br><span class="hljs-keyword">import</span> org.json.JSONObject;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Controller;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;<br><span class="hljs-keyword">import</span> util.HttpRequest;		<span class="hljs-comment">//自定义的网络请求的工具类(见下)</span><br><span class="hljs-keyword">import</span> util.RegisterUser;		<span class="hljs-comment">//自定义的注册的工具类</span><br><span class="hljs-keyword">import</span> util.AesCbcUtil;			<span class="hljs-comment">//自定义的AES解密工具类(见下)</span><br><br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>:范秉洋</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>:2019/8/25 17:00</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WXLoginController</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserMapper userMapper;<br><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/login.do&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Map <span class="hljs-title">decodeUserInfo</span><span class="hljs-params">(String encryptedData,String iv,String code)</span></span>&#123;<br>        Map map = <span class="hljs-keyword">new</span> HashMap();<br><br>        <span class="hljs-comment">//登录凭证不能为空</span><br>        <span class="hljs-keyword">if</span>(code == <span class="hljs-keyword">null</span> || code.length() == <span class="hljs-number">0</span>)<br>        &#123;<br>            map.put(<span class="hljs-string">&quot;status&quot;</span>,<span class="hljs-number">0</span>);<br>            map.put(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;code不能为空&quot;</span>);<br>            <span class="hljs-keyword">return</span> map;<br>        &#125;<br><br>        <span class="hljs-comment">//小程序唯一标识(在微信小程序管理后台获取)</span><br>        String wxspAppid = <span class="hljs-string">&quot;XXXXXXXXX&quot;</span>;<br>        <span class="hljs-comment">//小程序的app secret(在微信小程序管理后台获取)</span><br>        String wxspSecret = <span class="hljs-string">&quot;XXXXXXXXX&quot;</span>;<br>        <span class="hljs-comment">//授权(必填)</span><br>        String grant_type = <span class="hljs-string">&quot;authorization_code&quot;</span>;<br><br>        <span class="hljs-comment">//********1.向微信服务器使用登录凭证code获取session_key和openid****************//</span><br>        <span class="hljs-comment">//拼接请求参数</span><br>        String params = <span class="hljs-string">&quot;appid=&quot;</span>+wxspAppid + <span class="hljs-string">&quot;&amp;secret=&quot;</span>+wxspSecret <br>            + <span class="hljs-string">&quot;&amp;js_code=&quot;</span>+code + <span class="hljs-string">&quot;&amp;grant_type=&quot;</span>+grant_type;<br>        <span class="hljs-comment">//请求的URL</span><br>        String url = <span class="hljs-string">&quot;https://api.weixin.qq.com/sns/jscode2session&quot;</span>;<br>        <span class="hljs-comment">//通过请求工具类发送请求</span><br>        String sr = HttpRequest.sendGet(url,params);<br><br>        <span class="hljs-comment">//解析相应内容(转换成json对象)</span><br>        JSONObject json = <span class="hljs-keyword">new</span> JSONObject(sr);<br><br>        <span class="hljs-comment">//获取会话密钥(session_key)</span><br>        String session_key = json.get(<span class="hljs-string">&quot;session_key&quot;</span>).toString();<br><br>        <span class="hljs-comment">//用户的唯一标识(openid)</span><br>        String openid = (String)json.get(<span class="hljs-string">&quot;openid&quot;</span>);<br><br>        <span class="hljs-comment">//*********2.对encryptedData加密数据进行AES解密***************************//</span><br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-comment">// 根据加密数据，加密算法初始向量和session_key(密钥)通过AES解密工具类进行解密</span><br>            String result = AesCbcUtil.decrypt(encryptedData,session_key,iv,<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>			<span class="hljs-comment">// 如果解密的结果不为空或者长度大于0，则解密成功</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">null</span> != result &amp;&amp; result.length() &gt; <span class="hljs-number">0</span>)<br>            &#123;<br>                map.put(<span class="hljs-string">&quot;status&quot;</span>,<span class="hljs-number">1</span>);<br>                map.put(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;解密成功&quot;</span>);<br>				<span class="hljs-comment">// 将解密结果转换成json格式</span><br>                JSONObject userInfoJSON = <span class="hljs-keyword">new</span> JSONObject(result);<br>                Map userInfo = <span class="hljs-keyword">new</span> HashMap();<br>                <span class="hljs-comment">//用户openId</span><br>                userInfo.put(<span class="hljs-string">&quot;openId&quot;</span>,userInfoJSON.get(<span class="hljs-string">&quot;openId&quot;</span>));<br>                <span class="hljs-comment">//用户昵称</span><br>                userInfo.put(<span class="hljs-string">&quot;nickName&quot;</span>,userInfoJSON.get(<span class="hljs-string">&quot;nickName&quot;</span>));<br>                <span class="hljs-comment">//用户性别，0：未知，1：男；2：女。</span><br>                userInfo.put(<span class="hljs-string">&quot;gender&quot;</span>,userInfoJSON.get(<span class="hljs-string">&quot;gender&quot;</span>));<br>                <span class="hljs-comment">//用户所在城市</span><br>                userInfo.put(<span class="hljs-string">&quot;city&quot;</span>,userInfoJSON.get(<span class="hljs-string">&quot;city&quot;</span>));<br>                <span class="hljs-comment">//用户所在省份</span><br>                userInfo.put(<span class="hljs-string">&quot;province&quot;</span>,userInfoJSON.get(<span class="hljs-string">&quot;province&quot;</span>));<br>                <span class="hljs-comment">//用户所在国家</span><br>                userInfo.put(<span class="hljs-string">&quot;country&quot;</span>,userInfoJSON.get(<span class="hljs-string">&quot;country&quot;</span>));<br>                <span class="hljs-comment">//用户头像地址</span><br>                userInfo.put(<span class="hljs-string">&quot;avatarUrl&quot;</span>,userInfoJSON.get(<span class="hljs-string">&quot;avatarUrl&quot;</span>));<br><br><br>                <span class="hljs-comment">//注册验证，如果是首次登录，将信息通过注册工具类写入数据库，如果不是，则进行信息更新</span><br>                <span class="hljs-comment">//这个就不在给出具体代码，根据个人的具体情况进行将用户信息封装好写入数据库</span><br>                RegisterUser.Register(userMapper,userInfoJSON);<br><br>                <span class="hljs-comment">//解密unionId &amp; openId</span><br>                <span class="hljs-comment">//这个信息是只给符合条件的用户下发,如不符合,则没有这个数据,</span><br>                <span class="hljs-comment">//在调用时需要做相应的判断,否则直接取值会报错,</span><br>                <span class="hljs-keyword">if</span>(!userInfoJSON.isNull(<span class="hljs-string">&quot;unionId&quot;</span>))&#123;<br>                    userInfo.put(<span class="hljs-string">&quot;unionID&quot;</span>,userInfoJSON.get(<span class="hljs-string">&quot;unionId&quot;</span>));<br>                &#125;<br>                map.put(<span class="hljs-string">&quot;userInfo&quot;</span>,userInfo);<br><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                map.put(<span class="hljs-string">&quot;status&quot;</span>,<span class="hljs-number">0</span>);<br>                map.put(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;解密失败&quot;</span>);<br>            &#125;<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-comment">//将结果返回给微信端</span><br>        <span class="hljs-keyword">return</span> map;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>网络请求工具类：HttpRequest.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> util;<br><br><span class="hljs-keyword">import</span> java.io.BufferedReader;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.InputStreamReader;<br><span class="hljs-keyword">import</span> java.io.PrintWriter;<br><span class="hljs-keyword">import</span> java.net.URL;<br><span class="hljs-keyword">import</span> java.net.URLConnection;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>:范秉洋</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>:2019/8/25 17:31</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpRequest</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 向指定url发送GTE方法的请求</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> url   发送请求的url</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> param   请求参数，参数形式是name1=value1&amp;name2=value2</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> URL  所代表远程资源的响应结果</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">sendGet</span><span class="hljs-params">(String url,String param)</span></span>&#123;<br>        String result = <span class="hljs-string">&quot;&quot;</span>;<br>        BufferedReader in = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span>&#123;<br>            String urlNameString = url + <span class="hljs-string">&quot;?&quot;</span> + param;<br>            URL realUrl = <span class="hljs-keyword">new</span> URL(urlNameString);<br>            <span class="hljs-comment">//打开和URL之间的链接</span><br>            URLConnection connection = realUrl.openConnection();<br>            <span class="hljs-comment">//设置通用的请求属性</span><br>            connection.setRequestProperty(<span class="hljs-string">&quot;accept&quot;</span>,<span class="hljs-string">&quot;*/*&quot;</span>);<br>            connection.setRequestProperty(<span class="hljs-string">&quot;connection&quot;</span>,<span class="hljs-string">&quot;Keep-Alive&quot;</span>);<br>            connection.setRequestProperty(<span class="hljs-string">&quot;user-agent&quot;</span>,<span class="hljs-string">&quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1;SV1)&quot;</span>);<br><br>            <span class="hljs-comment">//建立实际的链接</span><br>            connection.connect();<br>            <span class="hljs-comment">//获取所用响应头字段</span><br>            Map&lt;String, List&lt;String&gt;&gt; map = connection.getHeaderFields();<br>            <span class="hljs-comment">//遍历所有的响应头字段</span><br>            <span class="hljs-comment">//for(String key:map.keySet())&#123;</span><br>            <span class="hljs-comment">//    System.out.println(key + &quot;---&gt;&quot; + map.get(key));</span><br>            <span class="hljs-comment">//&#125;</span><br>            <span class="hljs-comment">//定义BufferedReader输入流来读取URL的响应</span><br>            in = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(connection.getInputStream()));<br>            String line;<br>            <span class="hljs-keyword">while</span> ((line = in.readLine()) != <span class="hljs-keyword">null</span>)&#123;<br>                result += line;<br>            &#125;<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            System.out.println(<span class="hljs-string">&quot;发送GET请求出现异常！&quot;</span> + e);<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-comment">//使用finally块来关闭输入流</span><br>        <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">try</span>&#123;<br>                <span class="hljs-keyword">if</span>(in != <span class="hljs-keyword">null</span>)&#123;<br>                    in.close();<br>                &#125;<br>            &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 向指定url发送POST方法的请求</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> url   发送请求的url</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> param   请求参数，参数形式是name1=value1&amp;name2=value2</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> URL  所代表远程资源的响应结果</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">sendPost</span><span class="hljs-params">(String url,String param)</span></span>&#123;<br>        PrintWriter out = <span class="hljs-keyword">null</span>;<br>        BufferedReader in = <span class="hljs-keyword">null</span>;<br>        String result = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">try</span>&#123;<br>            URL realURl = <span class="hljs-keyword">new</span> URL(url);<br>            <span class="hljs-comment">//打开和URL之间的链接</span><br>            URLConnection conn = realURl.openConnection();<br>            <span class="hljs-comment">//设置通用的请求属性</span><br>            conn.setRequestProperty(<span class="hljs-string">&quot;accept&quot;</span>,<span class="hljs-string">&quot;*/*&quot;</span>);<br>            conn.setRequestProperty(<span class="hljs-string">&quot;connection&quot;</span>,<span class="hljs-string">&quot;Keep-Alive&quot;</span>);<br>            conn.setRequestProperty(<span class="hljs-string">&quot;user-agent&quot;</span>,<span class="hljs-string">&quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1;SV1)&quot;</span>);<br>            <span class="hljs-comment">//发送POST请求必须设置如下两行</span><br>            conn.setDoOutput(<span class="hljs-keyword">true</span>);<br>            conn.setDoInput(<span class="hljs-keyword">true</span>);<br>            <span class="hljs-comment">//获取URLConnection对象对应的输入流</span><br>            out = <span class="hljs-keyword">new</span> PrintWriter((conn.getOutputStream()));<br>            <span class="hljs-comment">//发送请求参数</span><br>            out.print(param);<br>            <span class="hljs-comment">//flush输出流的缓冲</span><br>            out.flush();<br>            <span class="hljs-comment">//定义BufferedReader输入流来读取URL的响应</span><br>            in = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(conn.getInputStream()));<br>            String line;<br>            <span class="hljs-keyword">while</span>((line = in.readLine()) != <span class="hljs-keyword">null</span>)&#123;<br>                result += line;<br>            &#125;<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            System.out.println(<span class="hljs-string">&quot;发送POST请求出现异常！&quot;</span> + e);<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">try</span>&#123;<br>                <span class="hljs-keyword">if</span>(out != <span class="hljs-keyword">null</span>)&#123;<br>                    out.close();<br>                &#125;<br>                <span class="hljs-keyword">if</span>(in != <span class="hljs-keyword">null</span>)&#123;<br>                    in.close();<br>                &#125;<br>            &#125;<span class="hljs-keyword">catch</span> (IOException ex)&#123;<br>                ex.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>&#125;<br><br><br></code></pre></td></tr></table></figure>

<p>AES解密工具类：AesCbcUtil.java</p>
<blockquote>
<p>注意：重点标识的这个jar包commons.codec.jar，需要根据自己的jdk版本做对应的引入，我的是1.8的jdk，引入的是1.6的版本。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> util;<br><br><span class="hljs-keyword">import</span> org.apache.commons.codec.binary.Base64;<br><br><span class="hljs-keyword">import</span> javax.crypto.BadPaddingException;<br><span class="hljs-keyword">import</span> javax.crypto.Cipher;<br><span class="hljs-keyword">import</span> javax.crypto.IllegalBlockSizeException;<br><span class="hljs-keyword">import</span> javax.crypto.NoSuchPaddingException;<br><span class="hljs-keyword">import</span> javax.crypto.spec.IvParameterSpec;<br><span class="hljs-keyword">import</span> javax.crypto.spec.SecretKeySpec;<br><span class="hljs-keyword">import</span> java.io.UnsupportedEncodingException;<br><span class="hljs-keyword">import</span> java.security.AlgorithmParameters;<br><span class="hljs-keyword">import</span> java.security.InvalidAlgorithmParameterException;<br><span class="hljs-keyword">import</span> java.security.NoSuchAlgorithmException;<br><span class="hljs-keyword">import</span> java.security.Security;<br><span class="hljs-keyword">import</span> java.security.spec.InvalidParameterSpecException;<br><span class="hljs-keyword">import</span> java.security.*;<br><br><span class="hljs-keyword">import</span> org.bouncycastle.jce.provider.BouncyCastleProvider;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>:范秉洋</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>:2019/8/25 17:25</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AesCbcUtil</span> </span>&#123;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-comment">//BouncyCastle是一个开源的加解密解决方案，主页在http://www.bouncycastle.org/</span><br>        Security.addProvider(<span class="hljs-keyword">new</span> BouncyCastleProvider());<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * AES解密</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> data           //密文，被加密的数据</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key            //秘钥</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> iv             //偏移量</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> encodingFormat //解密后的结果需要进行的编码</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">decrypt</span><span class="hljs-params">(String data, String key, String iv, String encodingFormat)</span> <span class="hljs-keyword">throws</span> Exception </span><br><span class="hljs-function"></span><br><span class="hljs-function">        <span class="hljs-comment">//被加密的数据</span></span><br><span class="hljs-function">        <span class="hljs-keyword">byte</span>[] dataByte </span>= Base64.decodeBase64(data);<br>        <span class="hljs-comment">//加密秘钥</span><br>        <span class="hljs-keyword">byte</span>[] keyByte = Base64.decodeBase64(key);<br>        <span class="hljs-comment">//偏移量</span><br>        <span class="hljs-keyword">byte</span>[] ivByte = Base64.decodeBase64(iv);<br><br><br>        <span class="hljs-keyword">try</span> &#123;<br>            Cipher cipher = Cipher.getInstance(<span class="hljs-string">&quot;AES/CBC/PKCS7Padding&quot;</span>);<br><br>            SecretKeySpec spec = <span class="hljs-keyword">new</span> SecretKeySpec(keyByte, <span class="hljs-string">&quot;AES&quot;</span>);<br><br>            AlgorithmParameters parameters = AlgorithmParameters.getInstance(<span class="hljs-string">&quot;AES&quot;</span>);<br>            parameters.init(<span class="hljs-keyword">new</span> IvParameterSpec(ivByte));<br><br>            cipher.init(Cipher.DECRYPT_MODE, spec, parameters);<span class="hljs-comment">// 初始化</span><br><br>            <span class="hljs-keyword">byte</span>[] resultByte = cipher.doFinal(dataByte);<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != resultByte &amp;&amp; resultByte.length &gt; <span class="hljs-number">0</span>) &#123;<br>                String result = <span class="hljs-keyword">new</span> String(resultByte, encodingFormat);<br>                <span class="hljs-keyword">return</span> result;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchAlgorithmException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchPaddingException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (InvalidParameterSpecException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (InvalidKeyException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (InvalidAlgorithmParameterException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (IllegalBlockSizeException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (BadPaddingException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (UnsupportedEncodingException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以上就是关于小程序登录过程的解析，最主要的就是通过用户授权之后获取用户的加密信息，通过加密数据、加密算法初始向量和登录凭证在后台进行解密，从而获得用户的完成信息，之后在进行开发者的逻辑操作对用户的个人信息进行操作和处理。上面提到的还有一点就是<code>wx.getUserInfo(Object)</code>方法不会在自动弹出授权窗口了，需要开发者自定义登录按钮来引导用户进行登录授权。</p>
]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序-项目目录结构</title>
    <url>/2020/02/05/wechatApp-direcoty/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们在开发项目的时候，项目创建好之后都会有一个默认的目录结构，在开发微信小程序的时候，通过官方提供的微信开发者工具创建项目之后，也会生成一个默认的目录结构，和我们开发一般项目的结构稍微有所不同，今天记录和分析一下微信小程序的目录结构。</p>
<span id="more"></span>

<h1 id="小程序-项目结构"><a href="#小程序-项目结构" class="headerlink" title="小程序-项目结构"></a>小程序-项目结构</h1><h2 id="1-创建项目"><a href="#1-创建项目" class="headerlink" title="1. 创建项目"></a>1. 创建项目</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;打开从<a href="https://mp.weixin.qq.com/">微信公众平台</a>下载的微信开发者工具，需要先进行登录，用你在公众平台注册的那个微信账号进行登录，在左侧项目列表中选择小程序，然后如下图所示。</p>
<p><img  src="%E6%96%B0%E5%BB%BA%E9%A1%B9%E7%9B%AE.png"  ><span class="image-caption">新建项目</span></p>
<p>上面一共有这么几个地方需要填写：</p>
<ul>
<li><strong>项目名称：</strong>就是你开发的项目。</li>
<li><strong>目录：</strong>默认是<code>C:\Users\XXX\WeChatProjects\项目名</code>，可以手动选择代码的存放路径；</li>
<li><strong>AppID：</strong>如果是注册用户，需要到公共平台在菜单“开发”—“开发设置”可以看到小程序AppID，这相当于是给开发人员的通行证，复制下来填入即可。如果是未注册的用户也可以使用<em>测试号</em>，不过测试号不可以选择后端服务(反正暂时也用不到)。</li>
<li><strong>开发模式：</strong>小程序(默认)，插件。我们选择小程序。</li>
<li><strong>后端服务：</strong>小程序·云开发(默认)，不使用云服务。我们选择不使用云服务。</li>
<li><strong>语言：</strong>如果后端服务选择不使用云服务的话，会多一个语言选择，分别有<code>JavaScript</code>和<code>TypeScript</code>两者，在这选择<code>Javascript</code>。</li>
</ul>
<p>上面的选项选择完毕之后，点击右下角的<strong>新建</strong>即可创建项目。</p>
<h2 id="2-目录结构"><a href="#2-目录结构" class="headerlink" title="2. 目录结构"></a>2. 目录结构</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;新创建出的项目的目录结构如下，包括两个文件夹和5个文件。文件夹分别是<code>pages</code>文件夹和<code>utils</code>文件夹；文件分别是<code>app.js</code>，<code>app.json</code>，<code>app.wxss</code>，<code>project.config.json</code>，<code>sitemap.json</code>。</p>
<p><img  src="%E6%80%BB%E7%9B%AE%E5%BD%95.png"  ><span class="image-caption">总目录</span></p>
<h2 id="3-文件分析"><a href="#3-文件分析" class="headerlink" title="3. 文件分析"></a>3. 文件分析</h2><h3 id="3-1-app-js"><a href="#3-1-app-js" class="headerlink" title="3.1 app.js"></a>3.1 app.js</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该文件是小程序的逻辑文件，是项目必须要有的一个文件，里面的App是用于启动时做一下内容加载请求使用，是小程序进入首页之前调用的，里面的<strong>globalData</strong>存放的是全局变量，可以在任何一个<code>.js</code>文件里面被调用。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每个小程序都需要在 <code>app.js</code> 中调用 <code>App</code> 方法注册小程序实例，绑定生命周期回调函数、错误监听和页面不存在监听函数等。详细的参数含义和使用请参考 <a href="https://developers.weixin.qq.com/miniprogram/dev/reference/api/App.html">App 参考文档</a> 。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// app.js</span><br>App(&#123;<br>  onLaunch (options) &#123;<br>    <span class="hljs-comment">// Do something initial when launch.</span><br>  &#125;,<br>  onShow (options) &#123;<br>    <span class="hljs-comment">// Do something when show.</span><br>  &#125;,<br>  onHide () &#123;<br>    <span class="hljs-comment">// Do something when hide.</span><br>  &#125;,<br>  onError (msg) &#123;<br>    <span class="hljs-built_in">console</span>.log(msg)<br>  &#125;,<br>  <span class="hljs-attr">globalData</span>: <span class="hljs-string">&#x27;I am global data&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure>

<p>整个小程序只有一个App实例，是全部页面共享的，。开发者可以通过<code>getApp</code>方法获取全局唯一的App实例，获取App上的数据或者电调用开发者注册在App上的函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// xxx.js</span><br><span class="hljs-keyword">const</span> appInstance = getApp()<br><span class="hljs-built_in">console</span>.log(appInstance.globalData) <span class="hljs-comment">// I am global data</span><br></code></pre></td></tr></table></figure>

<h3 id="3-2-app-json"><a href="#3-2-app-json" class="headerlink" title="3.2 app.json"></a>3.2 app.json</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在小程序根目录下的 <code>app.json</code> 文件用来对微信小程序进行全局配置，该文件也是项目必须要有的，它决定页面文件的路径、窗口表现、设置网络超时时间、设置多 tab 等。完整配置项说明请参考<a href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html">小程序全局配置</a>。以下是一个包含了部分常用配置选项的 <code>app.json</code> ：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;pages&quot;</span>: [<br>    <span class="hljs-string">&quot;pages/index/index&quot;</span>,<br>    <span class="hljs-string">&quot;pages/logs/index&quot;</span><br>  ],<br>  <span class="hljs-attr">&quot;window&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;navigationBarTitleText&quot;</span>: <span class="hljs-string">&quot;Demo&quot;</span><br>  &#125;,<br>  <span class="hljs-attr">&quot;tabBar&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;list&quot;</span>: [&#123;<br>      <span class="hljs-attr">&quot;pagePath&quot;</span>: <span class="hljs-string">&quot;pages/index/index&quot;</span>,<br>      <span class="hljs-attr">&quot;text&quot;</span>: <span class="hljs-string">&quot;首页&quot;</span><br>    &#125;, &#123;<br>      <span class="hljs-attr">&quot;pagePath&quot;</span>: <span class="hljs-string">&quot;pages/logs/logs&quot;</span>,<br>      <span class="hljs-attr">&quot;text&quot;</span>: <span class="hljs-string">&quot;日志&quot;</span><br>    &#125;]<br>  &#125;,<br>  <span class="hljs-attr">&quot;networkTimeout&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;request&quot;</span>: <span class="hljs-number">10000</span>,<br>    <span class="hljs-attr">&quot;downloadFile&quot;</span>: <span class="hljs-number">10000</span><br>  &#125;,<br>  <span class="hljs-attr">&quot;debug&quot;</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">&quot;navigateToMiniProgramAppIdList&quot;</span>: [<br>    <span class="hljs-string">&quot;wxe5f52902cf4de896&quot;</span><br>  ]<br>&#125;<br></code></pre></td></tr></table></figure>

<p><span id="app.wxss"></span></p>
<h3 id="3-3-app-wxss"><a href="#3-3-app-wxss" class="headerlink" title="3.3 app.wxss"></a>3.3 app.wxss</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该文件是小程序的公共样式，不是项目所必须有的，定义在 app.wxss 中的样式为全局样式，作用于每一个页面。在 page 的 wxss 文件中定义的样式为局部样式，只作用在对应的页面，并会覆盖 app.wxss 中相同的选择器。WXSS (WeiXin Style Sheets)是一套样式语言，用于描述 WXML 的组件样式。WXSS 用来决定 WXML 的组件应该怎么显示。WXSS 具有 CSS 大部分特性。为了更适合开发微信小程序，WXSS 对 CSS 进行了扩充以及修改。与 CSS 相比，WXSS 扩展的特性有<strong>尺寸单位</strong>和<strong>样式导入</strong>。</p>
<p><strong>尺寸单位：</strong>rpx（responsive pixel）: 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。</p>
<table>
<thead>
<tr>
<th align="left">设备</th>
<th align="left">rpx换算px (屏幕宽度/750)</th>
<th align="left">px换算rpx (750/屏幕宽度)</th>
</tr>
</thead>
<tbody><tr>
<td align="left">iPhone5</td>
<td align="left">1rpx = 0.42px</td>
<td align="left">1px = 2.34rpx</td>
</tr>
<tr>
<td align="left">iPhone6</td>
<td align="left">1rpx = 0.5px</td>
<td align="left">1px = 2rpx</td>
</tr>
<tr>
<td align="left">iPhone6 Plus</td>
<td align="left">1rpx = 0.552px</td>
<td align="left"><strong>1px = 1.81rpx</strong></td>
</tr>
</tbody></table>
<blockquote>
<p><strong>建议：</strong>在开发微信小程序的时候可以用iPhon作为视觉稿的标准，也就是<strong>1px=2rpx</strong>。</p>
<p><strong>注意：</strong>在较小的屏幕上不可避免的会有一些毛刺。</p>
</blockquote>
<p><strong>样式导入：</strong>使用<code>@import</code>语句可以导入外联样式表，<code>@import</code>后跟需要导入的外联样式表的相对路径，用<code>;</code>表示语句结束。示例代码如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/** common.wxss **/</span><br><span class="hljs-selector-class">.small-p</span> &#123;<br>  <span class="hljs-attribute">padding</span>:<span class="hljs-number">5px</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/** app.wxss **/</span><br><span class="hljs-keyword">@import</span> <span class="hljs-string">&quot;common.wxss&quot;</span>;<br><span class="hljs-selector-class">.middle-p</span> &#123;<br>  <span class="hljs-attribute">padding</span>:<span class="hljs-number">15px</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>内联样式：</strong>框架组件上支持使用 style、class 属性来控制组件的样式。</p>
<ul>
<li><strong>style：</strong>静态的样式统一写到 class 中。style 接收动态的样式，在运行时会进行解析，请尽量避免将静态的样式写进 style 中，以免影响渲染速度。</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">&lt;view style=&quot;<span class="hljs-attribute">color</span>:&#123;&#123;color&#125;&#125;;&quot; /&gt;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>class：</strong>用于指定样式规则，其属性值是样式规则中类选择器名(样式类名)的集合，样式类名不需要带上<code>.</code>，样式类名之间用空格分隔。</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">&lt;view class=&quot;normal_view&quot; /&gt;<br></code></pre></td></tr></table></figure>

<p><strong>选择器：</strong>目前支持的选择器有：</p>
<table>
<thead>
<tr>
<th align="left">选择器</th>
<th align="left">样例</th>
<th align="left">样例描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">.class</td>
<td align="left"><code>.intro</code></td>
<td align="left">选择所有拥有 class=”intro” 的组件</td>
</tr>
<tr>
<td align="left">#id</td>
<td align="left"><code>#firstname</code></td>
<td align="left">选择拥有 id=”firstname” 的组件</td>
</tr>
<tr>
<td align="left">element</td>
<td align="left"><code>view</code></td>
<td align="left">选择所有 view 组件</td>
</tr>
<tr>
<td align="left">element, element</td>
<td align="left"><code>view, checkbox</code></td>
<td align="left">选择所有文档的 view 组件和所有的 checkbox 组件</td>
</tr>
<tr>
<td align="left">::after</td>
<td align="left"><code>view::after</code></td>
<td align="left">在 view 组件后边插入内容</td>
</tr>
<tr>
<td align="left">::before</td>
<td align="left"><code>view::before</code></td>
<td align="left">在 view 组件前边插入内容</td>
</tr>
</tbody></table>
<h3 id="3-4-project-config-json"><a href="#3-4-project-config-json" class="headerlink" title="3.4 project.config.json"></a>3.4 project.config.json</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该文件是一个工具配置文件，通常大家在使用一个工具的时候，都会针对各自喜好做一些个性化配置，例如界面颜色、编译配置等等，当你换了另外一台电脑重新安装工具的时候，你还要重新配置。考虑到这点，小程序开发者工具在每个项目的根目录都会生成一个 project.config.json，你在工具上做的任何配置都会写入到这个文件，当你重新安装工具或者换电脑工作时，你只要载入同一个项目的代码包，开发者工具就自动会帮你恢复到当时你开发项目时的个性化配置，其中会包括编辑器的颜色、代码上传时自动压缩等等一系列选项。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">&#123;<br>	<span class="hljs-attr">&quot;description&quot;</span>: <span class="hljs-string">&quot;项目配置文件&quot;</span>,<br>	<span class="hljs-attr">&quot;packOptions&quot;</span>: &#123;<br>		<span class="hljs-attr">&quot;ignore&quot;</span>: []<br>	&#125;,<br>	<span class="hljs-attr">&quot;setting&quot;</span>: &#123;<br>		<span class="hljs-attr">&quot;urlCheck&quot;</span>: <span class="hljs-literal">true</span>,<br>		<span class="hljs-attr">&quot;es6&quot;</span>: <span class="hljs-literal">true</span>,<br>		<span class="hljs-attr">&quot;postcss&quot;</span>: <span class="hljs-literal">true</span>,<br>		<span class="hljs-attr">&quot;minified&quot;</span>: <span class="hljs-literal">true</span>,<br>		<span class="hljs-attr">&quot;newFeature&quot;</span>: <span class="hljs-literal">true</span>,<br>		<span class="hljs-attr">&quot;autoAudits&quot;</span>: <span class="hljs-literal">false</span>,<br>		<span class="hljs-attr">&quot;coverView&quot;</span>: <span class="hljs-literal">true</span>,<br>		<span class="hljs-attr">&quot;showShadowRootInWxmlPanel&quot;</span>: <span class="hljs-literal">true</span>,<br>		<span class="hljs-attr">&quot;scopeDataCheck&quot;</span>: <span class="hljs-literal">false</span><br>	&#125;,<br>	<span class="hljs-attr">&quot;compileType&quot;</span>: <span class="hljs-string">&quot;miniprogram&quot;</span>,<br>	<span class="hljs-attr">&quot;libVersion&quot;</span>: <span class="hljs-string">&quot;2.10.1&quot;</span>,<br>	<span class="hljs-attr">&quot;appid&quot;</span>: <span class="hljs-string">&quot;wxd837a802c37e57a0&quot;</span>,<br>	<span class="hljs-attr">&quot;projectname&quot;</span>: <span class="hljs-string">&quot;test&quot;</span>,<br>	<span class="hljs-attr">&quot;debugOptions&quot;</span>: &#123;<br>		<span class="hljs-attr">&quot;hidedInDevtools&quot;</span>: []<br>	&#125;,<br>	<span class="hljs-attr">&quot;isGameTourist&quot;</span>: <span class="hljs-literal">false</span>,<br>	<span class="hljs-attr">&quot;simulatorType&quot;</span>: <span class="hljs-string">&quot;wechat&quot;</span>,<br>	<span class="hljs-attr">&quot;simulatorPluginLibVersion&quot;</span>: &#123;&#125;,<br>	<span class="hljs-attr">&quot;condition&quot;</span>: &#123;<br>		<span class="hljs-attr">&quot;search&quot;</span>: &#123;<br>			<span class="hljs-attr">&quot;current&quot;</span>: <span class="hljs-number">-1</span>,<br>			<span class="hljs-attr">&quot;list&quot;</span>: []<br>		&#125;,<br>		<span class="hljs-attr">&quot;conversation&quot;</span>: &#123;<br>			<span class="hljs-attr">&quot;current&quot;</span>: <span class="hljs-number">-1</span>,<br>			<span class="hljs-attr">&quot;list&quot;</span>: []<br>		&#125;,<br>		<span class="hljs-attr">&quot;game&quot;</span>: &#123;<br>			<span class="hljs-attr">&quot;currentL&quot;</span>: <span class="hljs-number">-1</span>,<br>			<span class="hljs-attr">&quot;list&quot;</span>: []<br>		&#125;,<br>		<span class="hljs-attr">&quot;miniprogram&quot;</span>: &#123;<br>			<span class="hljs-attr">&quot;current&quot;</span>: <span class="hljs-number">-1</span>,<br>			<span class="hljs-attr">&quot;list&quot;</span>: []<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="3-5-sitemap-json"><a href="#3-5-sitemap-json" class="headerlink" title="3.5 sitemap.json"></a>3.5 sitemap.json</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;小程序根目录下的 <code>sitemap.json</code> 文件用来配置小程序及其页面是否允许被微信索引。默认是所有页面都会被微信索引。在此就不过多解释，完整配置项说明请参考<a href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/sitemap.html">小程序 sitemap 配置</a>。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;rules&quot;</span>:[&#123;<br>    <span class="hljs-attr">&quot;action&quot;</span>: <span class="hljs-string">&quot;disallow&quot;</span>,<br>    <span class="hljs-attr">&quot;page&quot;</span>: <span class="hljs-string">&quot;*&quot;</span><br>  &#125;]<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p><strong>注：</strong><code>sitemap</code> 的索引提示是默认开启的，如需要关闭 <code>sitemap</code> 的索引提示，可在小程序项目配置文件 <code>project.config.json</code> 的 <code>setting</code> 中配置字段 <code>checkSiteMap</code> 为 <code>false</code>。</p>
<p>**注: **<code>sitemap</code> 文件内容最大为 5120 个 UTF8 字符。</p>
</blockquote>
<h2 id="4-文件夹分析"><a href="#4-文件夹分析" class="headerlink" title="4. 文件夹分析"></a>4. 文件夹分析</h2><h3 id="4-1-pages"><a href="#4-1-pages" class="headerlink" title="4.1 pages"></a>4.1 pages</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该文件夹是存放小程序页面的文件夹，下面每一个子文件夹都是一个小程序页面，一个小程序页面由四个文件组成，分别是：</p>
<table>
<thead>
<tr>
<th align="left">文件类型</th>
<th align="left">必需</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="#js">js</a></td>
<td align="left">是</td>
<td align="left">页面逻辑</td>
</tr>
<tr>
<td align="left"><a href="#wxml">wxml</a></td>
<td align="left">是</td>
<td align="left">页面结构</td>
</tr>
<tr>
<td align="left"><a href="#json">json</a></td>
<td align="left">否</td>
<td align="left">页面配置</td>
</tr>
<tr>
<td align="left"><a href="#wxss">wxss</a></td>
<td align="left">否</td>
<td align="left">页面样式表</td>
</tr>
</tbody></table>
<p><span id="js"></span></p>
<h4 id="4-1-1-js"><a href="#4-1-1-js" class="headerlink" title="4.1.1 js"></a>4.1.1 js</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于小程序中的每个页面，都需要在页面对应的js文件中进行注册，指定页面的初始数据、生命周期回调、事件处理函数等。使用**Page()**构造器注册页面。详细的参数含义和使用请参考 <a href="https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html">Page 参考文档</a> 。</p>
<p>代码示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//index.js</span><br>Page(&#123;<br>  <span class="hljs-attr">data</span>: &#123;<br>    <span class="hljs-attr">text</span>: <span class="hljs-string">&quot;This is page data.&quot;</span><br>  &#125;,<br>  <span class="hljs-attr">onLoad</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">options</span>) </span>&#123;<br>    <span class="hljs-comment">// 页面创建时执行</span><br>  &#125;,<br>  <span class="hljs-attr">onShow</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// 页面出现在前台时执行</span><br>  &#125;,<br>  <span class="hljs-attr">onReady</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// 页面首次渲染完毕时执行</span><br>  &#125;,<br>  <span class="hljs-attr">onHide</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// 页面从前台变为后台时执行</span><br>  &#125;,<br>  <span class="hljs-attr">onUnload</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// 页面销毁时执行</span><br>  &#125;,<br>  <span class="hljs-attr">onPullDownRefresh</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// 触发下拉刷新时执行</span><br>  &#125;,<br>  <span class="hljs-attr">onReachBottom</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// 页面触底时执行</span><br>  &#125;,<br>  <span class="hljs-attr">onShareAppMessage</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// 页面被用户分享时执行</span><br>  &#125;,<br>  <span class="hljs-attr">onPageScroll</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// 页面滚动时执行</span><br>  &#125;,<br>  <span class="hljs-attr">onResize</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// 页面尺寸变化时执行</span><br>  &#125;,<br>  <span class="hljs-function"><span class="hljs-title">onTabItemTap</span>(<span class="hljs-params">item</span>)</span> &#123;<br>    <span class="hljs-comment">// tab 点击时执行</span><br>    <span class="hljs-built_in">console</span>.log(item.index)<br>    <span class="hljs-built_in">console</span>.log(item.pagePath)<br>    <span class="hljs-built_in">console</span>.log(item.text)<br>  &#125;,<br>  <span class="hljs-comment">// 事件响应函数</span><br>  <span class="hljs-attr">viewTap</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.setData(&#123;<br>      <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;Set some data for updating view.&#x27;</span><br>    &#125;, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-comment">// this is setData callback</span><br>    &#125;)<br>  &#125;,<br>  <span class="hljs-comment">// 自由数据</span><br>  <span class="hljs-attr">customData</span>: &#123;<br>    <span class="hljs-attr">hi</span>: <span class="hljs-string">&#x27;MINA&#x27;</span><br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>

<p><span id="wxml"></span></p>
<h4 id="4-1-2-wxml"><a href="#4-1-2-wxml" class="headerlink" title="4.1.2 wxml"></a>4.1.2 wxml</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该文件是编写小程序页面的文件，WXML（WeiXin Markup Language）是框架设计的一套标签语言，结合基础组件、事件系统，可以构建出页面的结构。要完整了解 WXML 语法，请参考<a href="https://developers.weixin.qq.com/miniprogram/dev/reference/wxml/">WXML 语法参考</a>。下面是一些wxml使用的简单的例子。</p>
<p><strong>数据绑定：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- wxml --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">view</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// page.js</span><br>Page(&#123;<br>  <span class="hljs-attr">data</span>: &#123;<br>    <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Hello MINA!&#x27;</span><br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>

<p><strong>列表渲染：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--wxml--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">wx:for</span>=<span class="hljs-string">&quot;&#123;&#123;array&#125;&#125;&quot;</span>&gt;</span> &#123;&#123;item&#125;&#125; <span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// page.js</span><br>Page(&#123;<br>  <span class="hljs-attr">data</span>: &#123;<br>    <span class="hljs-attr">array</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>

<p><strong>条件渲染：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--wxml--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">wx:if</span>=<span class="hljs-string">&quot;&#123;&#123;view == &#x27;WEBVIEW&#x27;&#125;&#125;&quot;</span>&gt;</span> WEBVIEW <span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">wx:elif</span>=<span class="hljs-string">&quot;&#123;&#123;view == &#x27;APP&#x27;&#125;&#125;&quot;</span>&gt;</span> APP <span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">wx:else</span>=<span class="hljs-string">&quot;&#123;&#123;view == &#x27;MINA&#x27;&#125;&#125;&quot;</span>&gt;</span> MINA <span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// page.js</span><br>Page(&#123;<br>  <span class="hljs-attr">data</span>: &#123;<br>    <span class="hljs-attr">view</span>: <span class="hljs-string">&#x27;MINA&#x27;</span><br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>

<p><span id="json"></span></p>
<h4 id="4-1-3-json"><a href="#4-1-3-json" class="headerlink" title="4.1.3 json"></a>4.1.3 json</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该文件是当前页面的配置文件，每一个小程序页面也可以使用同名 <code>.json</code> 文件来对本页面的窗口表现进行配置，页面中配置项会覆盖 <code>app.json</code> 的 <code>window</code> 中相同的配置项。完整配置项说明请参考<a href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/page.html">小程序页面配置</a>。</p>
<p>配置示例：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;navigationBarBackgroundColor&quot;</span>: <span class="hljs-string">&quot;#ffffff&quot;</span>,<br>  <span class="hljs-attr">&quot;navigationBarTextStyle&quot;</span>: <span class="hljs-string">&quot;black&quot;</span>,<br>  <span class="hljs-attr">&quot;navigationBarTitleText&quot;</span>: <span class="hljs-string">&quot;微信接口功能演示&quot;</span>,<br>  <span class="hljs-attr">&quot;backgroundColor&quot;</span>: <span class="hljs-string">&quot;#eeeeee&quot;</span>,<br>  <span class="hljs-attr">&quot;backgroundTextStyle&quot;</span>: <span class="hljs-string">&quot;light&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面的配置分别是导航栏背景颜色、导航栏标题颜色、导航栏标题文字内容、窗口背景色、下拉 loading 的样式。</p>
<p><span id="wxss"></span></p>
<h4 id="4-1-4-wxss"><a href="#4-1-4-wxss" class="headerlink" title="4.1.4 wxss"></a>4.1.4 wxss</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该文件是对当前页面元素的样式进行渲染，和<code>app.wxss</code>一样，只不过是作用范围不一样，可以参看<a href="#app.wxss">app.wxss</a>。</p>
<h3 id="4-2-utils"><a href="#4-2-utils" class="headerlink" title="4.2 utils"></a>4.2 utils</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是一个工具包，里面的<code>js</code>文件是一个工具类，</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> formatTime = <span class="hljs-function"><span class="hljs-params">date</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> year = date.getFullYear()<br>  <span class="hljs-keyword">const</span> month = date.getMonth() + <span class="hljs-number">1</span><br>  <span class="hljs-keyword">const</span> day = date.getDate()<br>  <span class="hljs-keyword">const</span> hour = date.getHours()<br>  <span class="hljs-keyword">const</span> minute = date.getMinutes()<br>  <span class="hljs-keyword">const</span> second = date.getSeconds()<br><br>  <span class="hljs-keyword">return</span> [year, month, day].map(formatNumber).join(<span class="hljs-string">&#x27;/&#x27;</span>) + <span class="hljs-string">&#x27; &#x27;</span> + [hour, minute, second].map(formatNumber).join(<span class="hljs-string">&#x27;:&#x27;</span>)<br>&#125;<br><br><span class="hljs-keyword">const</span> formatNumber = <span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> &#123;<br>  n = n.toString()<br>  <span class="hljs-keyword">return</span> n[<span class="hljs-number">1</span>] ? n : <span class="hljs-string">&#x27;0&#x27;</span> + n<br>&#125;<br><span class="hljs-comment">//将方法暴露出去，供别人调用</span><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-attr">formatTime</span>: formatTime<br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后在其他页面的js文件里通过<code>require</code>进行引入该工具类，即可进行方法的调用。示例代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//xxx.js</span><br><span class="hljs-keyword">var</span> util = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;../../utils/util.js&#x27;</span>)<br>Page(&#123;<br>    <span class="hljs-attr">getTime</span>:<span class="hljs-function"><span class="hljs-title">funnction</span>(<span class="hljs-params"></span>)</span>&#123;<br>    	<span class="hljs-keyword">var</span> time = util.formatTime(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>())<br>		<span class="hljs-built_in">console</span>.log(time)          <span class="hljs-comment">//  2020/02/05 18:40 </span><br>	&#125;<br>&#125;)<br></code></pre></td></tr></table></figure>

<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以上就是对小程序开发的目录结构介绍，还是很好了解的，具体里面的一些语法和用法，可以去微信公众平台查看<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/">官方文档</a>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外在说一下怎么快速创建页面文件，一个页面需要有<code>.js</code>，<code>.json</code>，<code>.wxss</code>，<code>wxml</code>四个文件，如果一个一个的创建会很麻烦，说一个简单的方法，首先在<code>pages</code>上<strong>右键—&gt;新建目录</strong>，然后输入目录名称，接着在刚创建的目录上<strong>右键—&gt;新建Page</strong>，这样会直接在该目录下创建出与目录同名的四个相应的文件，是不是很便捷？还有一种更便捷的方法，就是在<code>app.json</code>文件中的<code>pages</code>里，直接按格式添加上要创建的目录，例如<code>&quot;pages/test/test&quot;</code>，保存之后，会直接创建出<code>test</code>文件夹以及下面的四个子文件。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;pages&quot;</span>: [<br>        <span class="hljs-string">&quot;pages/index/index&quot;</span>,<br>        <span class="hljs-string">&quot;pages/logs/logs&quot;</span>,<br>        <span class="hljs-string">&quot;pages/test/test&quot;</span><br>    ],<br>&#125;<br></code></pre></td></tr></table></figure>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就写这么多吧，感觉整理的也还算详细，收工收工~~~</p>
]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派安装系统和基础配置</title>
    <url>/2021/01/04/raspberry/</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前一段时间入手了一个树莓派4B，准备在无聊的时候鼓捣鼓捣，看看能不能做出点啥。刚拿到的树莓派第一反应却是无从入手，经过一番探索，终于把树莓派配置完成了。写个笔记记录一下，方便下次使用。</p>
<span id="more"></span>

<h1 id="1-安装系统"><a href="#1-安装系统" class="headerlink" title="1. 安装系统"></a>1. 安装系统</h1><h2 id="1-1-下载系统镜像"><a href="#1-1-下载系统镜像" class="headerlink" title="1.1 下载系统镜像"></a>1.1 下载系统镜像</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先先去树莓派官网下载你所需要的系统镜像，下载地址<a href="https://www.raspberrypi.org/downloads/">https://www.raspberrypi.org/downloads/</a>。这里选择的是自己手动安装镜像，所以选择下面这个。</p>
<p><img src="%E4%B8%8B%E8%BD%BD%E9%95%9C%E5%83%8F1.jpg"></p>
<p>然后可以看到有多个系统镜像可供选择，如果没啥需要的话可以直接下载官方提供的镜像。第一个和第二个都是有图形界面的，他俩的区别就是第一个预安装的有一些软件，这里用不到。第三个适合使用开源系统熟练的人用。这里选择第二个。将系统镜像下载到本地。</p>
<p><img src="%E4%B8%8B%E8%BD%BD%E9%95%9C%E5%83%8F2.jpg"></p>
<h2 id="1-2-格式化内存卡"><a href="#1-2-格式化内存卡" class="headerlink" title="1.2 格式化内存卡"></a>1.2 格式化内存卡</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;树莓派使用的是内存卡启动，所以首先要提前准备好一张内存卡，至少的4G的，这里用的是64G的。然后去找一个格式化内存卡的软件，这里使用<em>SD Memory Card formatter</em>进行内存卡格式化。下载地址<a href="https://www.sdcard.org/index.html">https://www.sdcard.org/index.html</a>。</p>
<p><img src="%E4%B8%8B%E8%BD%BD%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BD%AF%E4%BB%B6.jpg"></p>
<p>下载安装完成之后，将树莓派的内存卡插在电脑上，打开软件。选择要格式化的树莓派内存卡，不需要其他设置，直接点击<strong>Format</strong>即可，这样内存卡就格式化完成了。</p>
<p><img src="%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%86%85%E5%AD%98%E5%8D%A1.jpg"></p>
<h2 id="1-3-写入镜像"><a href="#1-3-写入镜像" class="headerlink" title="1.3 写入镜像"></a>1.3 写入镜像</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来将下载好的<code>.img</code>镜像写入内存卡，可以使用 <em>Win32 Disk Imager</em> 或 <em>Etcher</em>。<em>Win32 Disk Imager</em> 界面相对简单、有校验选项，<em>Etcher</em>偏向简洁。<em>Etcher</em>下载地址：<a href="https://www.balena.io/etcher">https://www.balena.io/etcher</a>。<em>Win32 Disk Imager</em>下载地址：<a href="https://sourceforge.net/projects/win32diskimager/">https://sourceforge.net/projects/win32diskimager/</a>。这里选择Win32 Disk Imager进行镜像的写入。运行<em>Win32 Disk Imager</em>之后，选择我们下载解压后的**.img镜像<strong>，设备选择</strong>内存卡<strong>（如果只插入了内存卡，程序会默认帮我们选好），点击</strong>写入<strong>，</strong>确定**，之后等待写入完成。</p>
<p><img src="%E5%86%99%E5%85%A5%E9%95%9C%E5%83%8F.jpg"></p>
<blockquote>
<p>注意！！！如果给树莓派配的有显示器的，这个时候可以直接将内存卡插入到树莓派中进行开机了。如果没有显示器的，这个时候先不要着急拔出读卡器，接下来还要进行系统配置，方便访问树莓派。</p>
</blockquote>
<h1 id="2-连接树莓派"><a href="#2-连接树莓派" class="headerlink" title="2. 连接树莓派"></a>2. 连接树莓派</h1><h2 id="2-1-开启SSH"><a href="#2-1-开启SSH" class="headerlink" title="2.1 开启SSH"></a>2.1 开启SSH</h2><h3 id="2-1-1-开机前配置"><a href="#2-1-1-开机前配置" class="headerlink" title="2.1.1 开机前配置"></a>2.1.1 开机前配置</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;没有给树莓派配置显示器的，可以在内存卡中先开启树莓派SSH，在<strong>boot</strong>盘创建一个名为<strong>ssh</strong>的无后缀空文件，无后缀！这样在树莓派启动的时候就打开了ssh，可以进行连接。</p>
<p><img src="ssh%E7%A9%BA%E6%96%87%E4%BB%B6.jpg"></p>
<h3 id="2-1-2-开机后用图形界面配置"><a href="#2-1-2-开机后用图形界面配置" class="headerlink" title="2.1.2 开机后用图形界面配置"></a>2.1.2 开机后用图形界面配置</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果有显示屏并且已经连接到树莓派的，点击树莓派界面左上角的树莓图标，点Preferences的这个图标，再点击下面倒数第二个树莓图标打开树莓派的设置。</p>
<p><img src="%E5%9B%BE%E5%BD%A2%E5%BC%80%E5%90%AFssh1.jpg"></p>
<p>选择Interfaces标签，将SSH那一行Enabled前面的那个圆点上，按右下角的OK保存，重启树莓派后就会自动开启SSH服务。</p>
<p><img src="%E5%9B%BE%E5%BD%A2%E5%BC%80%E5%90%AFssh2.jpg"></p>
<h3 id="2-1-3-开机后用命令行配置"><a href="#2-1-3-开机后用命令行配置" class="headerlink" title="2.1.3 开机后用命令行配置"></a>2.1.3 开机后用命令行配置</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果有显示屏并且已经连接到树莓派的，点击及界面上面菜单栏黑色框打开可以输入命令行的终端。在打开的界面命令行输入：<code>sudo raspi-config</code>，按<code>enter</code>键运行。</p>
<p><img src="%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BC%80%E5%90%AFssh1.jpg"></p>
<p>键盘下移移动到<code>Interfacing Options</code>，按<code>enter</code>键。</p>
<p><img src="%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BC%80%E5%90%AFssh2.jpg"></p>
<p>选择<code>ssh</code>，按回车确认，然后选择<code>yes</code>进行保存，重启树莓派后就会自动开启SSH服务。</p>
<p><img src="%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BC%80%E5%90%AFssh3.jpg"></p>
<h2 id="2-2-SSH登录树莓派"><a href="#2-2-SSH登录树莓派" class="headerlink" title="2.2 SSH登录树莓派"></a>2.2 SSH登录树莓派</h2><h3 id="2-2-1-网线连接"><a href="#2-2-1-网线连接" class="headerlink" title="2.2.1 网线连接"></a>2.2.1 网线连接</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果是通过网线将树莓派与路由器直接相连接的，可以去路由器管理页面查看所连接设备的IP地址，然后使用ssh连接工具进行连接就行。</p>
<ul>
<li>默认账户：<strong>pi</strong></li>
<li>默认密码：<strong>raspberry</strong></li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果是通过网线和笔记本电脑进行连接的，那么先依次打开<em>控制面板</em>–&gt;<em>网络和Internet</em>–&gt;<em>网络连接</em>。找到当前笔记本连接的WIFI网络右键查看<strong>属性</strong>。选择<strong>共享</strong>标签，勾选“允许其他用户通过此计算机的Internet连接来连接” ，选择连接树莓派的<strong>以太网</strong>，然后确定保存配置。</p>
<p><img src="%E5%85%B1%E4%BA%AB%E7%BD%91%E7%BB%9C.jpg"></p>
<p>然后打开电脑<strong>cmd</strong>命令行，输入<code>ipconfig</code>查看当前笔记本IP，然后找到<strong>无线局域网适配器 本地连接* 11</strong>，查看这个下面的<strong>IPv4 地址</strong>。这里的是<code>192.168.137.1</code>，记住这个ip，后面要用。</p>
<p><img src="%E6%9F%A5%E7%9C%8Bip%E8%8C%83%E5%9B%B4.jpg"></p>
<p>输入<code>arp -a</code>回车来查看当前网络连接，下翻找到<code>192.168.137.*</code>开头的接口地址，下面列出来的有一个动态地址就是当前树莓派的IP地址，然后就可以通过该IP进行ssh连接到树莓派。</p>
<blockquote>
<p>如果在192.168.137.*开头的接口地址下没有显示动态地址，或者说动态地址不是当前树莓派的地址，那么你很幸运，需要挨个去测试到底哪个才是树莓派的IP地址。</p>
</blockquote>
<p><img src="%E6%9F%A5%E7%9C%8Bip.jpg"></p>
<h3 id="2-2-2-WIFI连接"><a href="#2-2-2-WIFI连接" class="headerlink" title="2.2.2 WIFI连接"></a>2.2.2 WIFI连接</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果当前手边没有可用的网线，也可以使用WIFI的的形式进行树莓派的网络连接。将内存卡插到电脑上，在<strong>boot</strong>盘的根目录下创建<code>wpa_supplicant.conf</code>文件，下入下列内容进行保存。可以配置多个wifi网络，树莓派会根据设置的<code>priority</code>优先等级进行连接，数字越大等级越高，同等级的则从上至下依次选择。连接成功之后去查看wifi管理页面，找到一个连接设备名为<strong>raspberrypi</strong>的设备，这个对应的IP地址就是树莓派的IP地址。然后就可以通过该IP进行ssh连接到树莓派。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">country=CN<br>ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev<br>update_config=<span class="hljs-number">1</span><br>network=&#123;<br>	ssid=<span class="hljs-attr">&quot;wifi_1&quot;</span>  			<span class="hljs-comment">//第1个wifi的名字</span><br>    	scan_ssid=1			<span class="hljs-comment">//如果你的无线接入点是隐藏的，那么这个就是必须的(选填)</span><br>	psk=<span class="hljs-attr">&quot;wifi_1password&quot;</span>    	<span class="hljs-comment">//第1个wifi的密码</span><br>	key_mgmt=WPA-PSK		<span class="hljs-comment">//认证密钥管理协议，也就是你的加密类型(选填)</span><br>    	priority=5			<span class="hljs-comment">//连接的优先等级，数字越大优先度越高</span><br>&#125;<br> <br>network=&#123;<br>	ssid=<span class="hljs-attr">&quot;wifi_2&quot;</span>   		 <span class="hljs-comment">//第2个wifi的名字</span><br>	psk=<span class="hljs-attr">&quot;wifi_2password&quot;</span>     	<span class="hljs-comment">//第2个wifi的密码</span><br>	key_mgmt=WPA-PSK		<br>    	priority=4<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果开机之后要修改WIFI配置，文件的位置在<code>/etc/wpa_supplicant/wpa_supplicant.conf</code>，这个文件是个只读文件，在修改之前可先执行下面命令，修改一下文件权限即可。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo chmod 666 /etc/wpa_supplicant/wpa_supplicant.conf<br></code></pre></td></tr></table></figure>

<h3 id="2-2-3-配置固定IP"><a href="#2-2-3-配置固定IP" class="headerlink" title="2.2.3 配置固定IP"></a>2.2.3 配置固定IP</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;树莓派无论是通过网线连接还是WIFI连接，每次连接到网络的之后都会被重新分配一次IP，这样每次在连接前都需要重新查看树莓派的IP地址，然后再进行连接。其实可以给树莓派的设置一个固定IP，这样以后树莓派在同一局域网下的IP地址就固定了。首先连接上树莓派之后，通过<code>ifconfig</code>命令查看当前IP地址。</p>
<p><img src="%E6%A0%91%E8%8E%93%E6%B4%BE%E6%9F%A5%E7%9C%8Bip.jpg"></p>
<p>可以看到此时树莓派是通过WLAN接口进行网络连接的。然后通过<code>sudo nano /etc/dhcpcd.conf</code>命令打开文件，在文件的最后添加以下内容。下面分别配置<code>eth0</code>和<code>wlan0</code>接口的静态地址。</p>
<blockquote>
<p>树莓派自带的<code>nano</code>编辑器使用<code>ctrl+o</code>进行保存，使用<code>ctrl+x</code>退出文件。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">eth0</span></span><br><span class="hljs-class"><span class="hljs-title">static</span> <span class="hljs-title">ip_address</span></span>=<span class="hljs-number">192.168</span><span class="hljs-number">.137</span><span class="hljs-number">.157</span>/<span class="hljs-number">24</span><br># <span class="hljs-keyword">static</span> ip6_address=fd51:42f8:caae:d92e::ff/<span class="hljs-number">64</span><br><span class="hljs-keyword">static</span> routers=<span class="hljs-number">192.168</span><span class="hljs-number">.137</span><span class="hljs-number">.1</span><br><span class="hljs-keyword">static</span> domain_name_servers=<span class="hljs-number">192.168</span><span class="hljs-number">.137</span><span class="hljs-number">.1</span> <span class="hljs-number">114.114</span><span class="hljs-number">.114</span><span class="hljs-number">.114</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">wlan0</span></span><br><span class="hljs-class"><span class="hljs-title">static</span> <span class="hljs-title">ip_address</span></span>=<span class="hljs-number">192.168</span><span class="hljs-number">.137</span><span class="hljs-number">.157</span>/<span class="hljs-number">24</span><br># <span class="hljs-keyword">static</span> ip6_address=fd51:42f8:caae:d92e::ff/<span class="hljs-number">64</span><br><span class="hljs-keyword">static</span> routers=<span class="hljs-number">192.168</span><span class="hljs-number">.137</span><span class="hljs-number">.1</span><br><span class="hljs-keyword">static</span> domain_name_servers=<span class="hljs-number">192.168</span><span class="hljs-number">.137</span><span class="hljs-number">.1</span> <span class="hljs-number">114.114</span><span class="hljs-number">.114</span><span class="hljs-number">.114</span><br></code></pre></td></tr></table></figure>

<ul>
<li><strong>static ip_address</strong>：这个就是配置树莓派的静态IP地址的。</li>
<li><strong>static ip6_address</strong>：这个是配置树莓派的IPV6的地址的，不用配置。</li>
<li><strong>static routers</strong>：这个是当前网络的网关地址。</li>
<li><strong>static domain_name_servers</strong>：这个第一个参数是当前网络的网关地址；后面一个配置的是DNS服务器。</li>
</ul>
<blockquote>
<p>这里除了你当前本地的DNS服务器地址以外，还可以配置两外两个。</p>
<p><strong>114.114.114.114</strong>：是国内移动、电信和联通通用的DNS，手机和电脑端都可以使用，干净无广告，解析成功率相对来说更高，国内用户使用的比较多，而且速度相对快、稳定，是国内用户上网常用的DNS。</p>
<p><strong>8.8.8.8</strong>：是GOOGLE公司提供的DNS，该地址是全球通用的，相对来说，更适合国外以及访问国外网站的用户使用。</p>
</blockquote>
<p>上述配置完成之后，<code>reboot</code>重启树莓派，即可通过刚刚配置的静态IP地址来远程树莓派，这样以后只要是在同一网关下，就可以使用这个IP地址来访问树莓派。</p>
<blockquote>
<p><strong>注意！注意！注意！</strong>树莓派一般都连接到一个局域网之中就不会随意更换了，如果你要让树莓派连接另外的网络，需要<strong>连接原来的网络</strong>，先将<strong>固定IP的配置取消</strong>掉，然后<strong>再连接新的网络</strong>，否则可能会出现连不上网的情况。</p>
</blockquote>
<h1 id="3-树莓派的基础配置"><a href="#3-树莓派的基础配置" class="headerlink" title="3. 树莓派的基础配置"></a>3. 树莓派的基础配置</h1><h2 id="3-1-更改软件源"><a href="#3-1-更改软件源" class="headerlink" title="3.1 更改软件源"></a>3.1 更改软件源</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在开始树莓派的各种 DIY 之前，我们还需要做一件很重要的事情更换软件源。&nbsp;软件源是指 debian 系操作系统的应用程序安装包仓库，很多的软件都会这收录到这个仓库里面。而树莓派的 raspberrypi 操作系统也是基于 debian 的，所以树莓派也有自己的软件源，用来收录各种树莓派应用程序。默认情况下，树莓派软件源地址是 <a href="https://link.zhihu.com/?target=http://archive.raspbian.org/">http://archive.raspbian.org/</a>，位于欧洲，在国内访问是非常慢的，经常只有几 k 每秒的下载速率。所以我们在玩转树莓派之前，强烈推荐替换成国内的软件源。树莓派的所有软件源地址可以从这里找到<a href="https://link.zhihu.com/?target=https://www.raspbian.org/RaspbianMirrors">https://www.raspbian.org/RaspbianMi…</a></p>
<p>在这找一个国内的就行，比如清华大学的（下图表格的第一行）。</p>
<p><img src="%E6%9F%A5%E6%89%BE%E8%BD%AF%E4%BB%B6%E6%BA%90.jpg"></p>
<p>然后输入命令<code>sudo nano /etc/apt/sources.list</code>并回车，进入编辑。如下图所示，把原来的内容注释掉（最前面加 # 号）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># deb http://raspbian.raspberrypi.org/raspbian/ buster main contrib non-free rpi</span><br><span class="hljs-comment"># Uncomment line below then &#x27;apt-get update&#x27; to enable &#x27;apt-get source&#x27;</span><br>deb-src http://raspbian.raspberrypi.org/raspbian/ buster main contrib non-free rpi<br></code></pre></td></tr></table></figure>

<p>然后再预选的软件源添加到文件中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">deb http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main non-free contrib<br>deb-src http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main non-free contrib<br></code></pre></td></tr></table></figure>

<p>最后文件内容如下。</p>
<p><img src="sources.list.jpg"></p>
<blockquote>
<p><strong>nano</strong> 是树莓派内置的轻量文本编辑器，使用方法是按 ctrl+o 保存，按 ctrl+x 关闭。</p>
</blockquote>
<p>同样的方法，输入命令<code>sudo nano /etc/apt/sources.list.d/raspi.list</code>并回车，然后也将原来的内容注释掉，然后添加如下内容；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">deb http://mirrors.tuna.tsinghua.edu.cn/raspberrypi/ buster main u<br></code></pre></td></tr></table></figure>

<p>最后文件内容如如下：</p>
<p><img src="raspi.list.jpg"></p>
<p>至此，树莓派软件源就替换好了。然后就可以执行以下命令进行更即可。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo apt-get update			# 更新软件列表<br>sudo apt-get upgrade			# 更新软件<br></code></pre></td></tr></table></figure>

<h2 id="3-2-设置时间"><a href="#3-2-设置时间" class="headerlink" title="3.2 设置时间"></a>3.2 设置时间</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在树莓派上，可以用<code>date</code>命令来查看当前的日期时间，后面的CST表示中国标准时间。</p>
<p><img src="%E6%9F%A5%E7%9C%8B%E6%97%B6%E9%97%B4.jpg"></p>
<p>如果显示的时间和当前时间不一致，那么就要设置一下树莓派的时区了。输入下面命令进行设置。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo dpkg-reconfigure tzdata<br></code></pre></td></tr></table></figure>

<p>通过上下键选择<strong>Asia</strong>然后回车确认。</p>
<p><img src="%E9%80%89%E6%8B%A9Asia.jpg"></p>
<p>通过上下键选择<strong>Shanghai</strong>然后回车确认。</p>
<p><img src="%E9%80%89%E6%8B%A9Shanghai.jpg"></p>
<p>再次查看时间可以看到时间已经准确。</p>
<p><img src="%E5%86%8D%E6%AC%A1%E6%9F%A5%E7%9C%8B%E6%97%B6%E9%97%B4.jpg"></p>
<p>树莓派没有电池，断电后无法保存时间。树莓派默认安装了NTP(Network Time Protocol)服务来获取互联网上ntp服务器提供的时间。如果这个时间不准，可以用这个命令校准一下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo ntpd -s –d<br></code></pre></td></tr></table></figure>

<p>如果还是不准，就用下列命令强制设置。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo date  --s=&quot;2021-01-18 23:21:11&quot;<br></code></pre></td></tr></table></figure>

<h2 id="3-3-设置中文"><a href="#3-3-设置中文" class="headerlink" title="3.3 设置中文"></a>3.3 设置中文</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;树莓派默认的系统语言是英文的，而且系统里没有预装中文字库，因此我们在设置语言之前需要先给树莓派安装上中文的字库。这里提供一个免费开源的中文字库。在终端输入以下命令即可：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo apt-get install ttf-wqy-zenhei<br></code></pre></td></tr></table></figure>

<p>中文字库安装完成之后，还需要安装一个中文输入法。输入如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo apt-get install scim-pinyin<br></code></pre></td></tr></table></figure>

<p>在中文字库以及输入法都安装好之后，我们输入<code>sudo raspi-config</code>命令来打开配置页面。然后通过方向键依次选择<strong>Localisation Options</strong>和<strong>Locale</strong>，通过回车键确认。</p>
<p><img src="%E8%AE%BE%E7%BD%AE%E4%B8%AD%E6%96%871.jpg"></p>
<p><img src="%E8%AE%BE%E7%BD%AE%E4%B8%AD%E6%96%872.jpg"></p>
<p>之后我们会进入到语言选择界面，在众多选项中找到<strong>en_GB.UTF-8 UTF-8</strong>，系统默认是这个，前面有个<code>*</code>，敲空格可以去掉这个星号。之后在这些语言中找到<strong>en_US.UTF-8 UTF-8</strong>，<strong>zh_CN.UTF-8</strong>，<strong>zh_CN.GBK GBK</strong>（用PageUp、PageDown找会比较快）并用空格在它前面的方括号中打上<code>*</code>，表示启用该语言。然后<code>tab</code>键切到<code>&lt;OK&gt;</code>上，回车，然后会显示自动设置，设置完重启树莓派。</p>
<h2 id="3-4-开启VNC"><a href="#3-4-开启VNC" class="headerlink" title="3.4 开启VNC"></a>3.4 开启VNC</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;没有给树莓派配备显示器的，如果想要通过桌面(图像化界面)连接到树莓派，就需要开启<strong>VNC</strong>，然后借助VNC连接工具进行桌面连接。首先是在树莓派上打开VNC配置。还是输入<code>sudo raspi-config</code>命令打开配置面板。然后依次选择<strong>Interfacing Options</strong>回车，选择<strong>VNC</strong>回车，最后选择**&lt;Yes&gt;**回车确认，现在树莓派的VNC服务已经打开了。</p>
<p><img src="%E5%BC%80%E5%90%AFVNC1.jpg"></p>
<p><img src="%E5%BC%80%E5%90%AFVNC2.jpg"></p>
<p><img src="%E5%BC%80%E5%90%AFVNC3.jpg"></p>
<p>通过VNC连接需要借助的工具是<em>VNC Viewer</em>。这里是VNC Viewer的<a href="https://www.realvnc.com/en/connect/download/viewer/windows/">下载地址</a>。安装完成之后，打开VNC Viewer，输入树莓派的IP地址、账号和密码，即可连接到树莓派桌面。</p>
<h2 id="3-5-Windows远程桌面连接"><a href="#3-5-Windows远程桌面连接" class="headerlink" title="3.5 Windows远程桌面连接"></a>3.5 Windows远程桌面连接</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;远程连接树莓派桌面除了使用VNC，还有一种就是通过Windows的远程桌面进行树莓派的桌面连接。连接之前需要在树莓派上安装<strong>xrdp</strong>服务。执行<code>sudo  apt-get install xrdp</code>命令进行安装。安装完成之后即可通过Windows的远程桌面进行连接树莓派桌面。首先通过<code>win + r</code>打开面板，然后输入<code>mstsc</code>点击确定。输入树莓派的IP进行连接。连接上之后需要输入树莓派的账号和密码进行登录。</p>
<p><img src="Windows%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A21.jpg"></p>
<p><img src="Windows%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A22.jpg"></p>
<h1 id="4-查看树莓派状态"><a href="#4-查看树莓派状态" class="headerlink" title="4. 查看树莓派状态"></a>4. 查看树莓派状态</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;自建一个python脚本，方便查看树莓派的各种状态和数据。包括当前CPU的稳如、CPU的内存占用情况、内存占用情况和硬盘占用情况。</p>
<p>首先创建脚本文件，命令如下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo nano getInfo.py<br></code></pre></td></tr></table></figure>

<p>然后输入以下代码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br> <br><span class="hljs-comment"># Return CPU temperature as a character string                                     </span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getCPUtemperature</span>():</span><br>    res = os.popen(<span class="hljs-string">&#x27;vcgencmd measure_temp&#x27;</span>).readline()<br>    <span class="hljs-keyword">return</span>(res.replace(<span class="hljs-string">&quot;temp=&quot;</span>,<span class="hljs-string">&quot;&quot;</span>).replace(<span class="hljs-string">&quot;&#x27;C\n&quot;</span>,<span class="hljs-string">&quot;&quot;</span>))<br> <br><span class="hljs-comment"># Return RAM information (unit=kb) in a list                                      </span><br><span class="hljs-comment"># Index 0: total RAM                                                              </span><br><span class="hljs-comment"># Index 1: used RAM                                                                </span><br><span class="hljs-comment"># Index 2: free RAM                                                                </span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getRAMinfo</span>():</span><br>    p = os.popen(<span class="hljs-string">&#x27;free&#x27;</span>)<br>    i = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-number">1</span>:<br>        i = i + <span class="hljs-number">1</span><br>        line = p.readline()<br>        <span class="hljs-keyword">if</span> i==<span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span>(line.split()[<span class="hljs-number">1</span>:<span class="hljs-number">4</span>])<br> <br><span class="hljs-comment"># Return % of CPU used by user as a character string                               </span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getCPUuse</span>():</span><br>    <span class="hljs-keyword">return</span>(<span class="hljs-built_in">str</span>(os.popen(<span class="hljs-string">&quot;top -n1 | awk &#x27;/Cpu\(s\):/ &#123;print $2&#125;&#x27;&quot;</span>).readline().strip()))<br> <br><span class="hljs-comment"># Return information about disk space as a list (unit included)                    </span><br><span class="hljs-comment"># Index 0: total disk space                                                        </span><br><span class="hljs-comment"># Index 1: used disk space                                                        </span><br><span class="hljs-comment"># Index 2: remaining disk space                                                    </span><br><span class="hljs-comment"># Index 3: percentage of disk used                                                 </span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getDiskSpace</span>():</span><br>    p = os.popen(<span class="hljs-string">&quot;df -h /&quot;</span>)<br>    i = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-number">1</span>:<br>        i = i +<span class="hljs-number">1</span><br>        line = p.readline()<br>        <span class="hljs-keyword">if</span> i==<span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span>(line.split()[<span class="hljs-number">1</span>:<span class="hljs-number">5</span>])<br> <br> <br><span class="hljs-comment"># CPU informatiom</span><br>CPU_temp = getCPUtemperature()<br>CPU_usage = getCPUuse()<br> <br><span class="hljs-comment"># RAM information</span><br><span class="hljs-comment"># Output is in kb, here I convert it in Mb for readability</span><br>RAM_stats = getRAMinfo()<br>RAM_total = <span class="hljs-built_in">round</span>(<span class="hljs-built_in">int</span>(RAM_stats[<span class="hljs-number">0</span>]) / <span class="hljs-number">1000</span>,<span class="hljs-number">1</span>)<br>RAM_used = <span class="hljs-built_in">round</span>(<span class="hljs-built_in">int</span>(RAM_stats[<span class="hljs-number">1</span>]) / <span class="hljs-number">1000</span>,<span class="hljs-number">1</span>)<br>RAM_free = <span class="hljs-built_in">round</span>(<span class="hljs-built_in">int</span>(RAM_stats[<span class="hljs-number">2</span>]) / <span class="hljs-number">1000</span>,<span class="hljs-number">1</span>)<br> <br><span class="hljs-comment"># Disk information</span><br>DISK_stats = getDiskSpace()<br>DISK_total = DISK_stats[<span class="hljs-number">0</span>]<br>DISK_used = DISK_stats[<span class="hljs-number">1</span>]<br>DISK_perc = DISK_stats[<span class="hljs-number">3</span>]<br> <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;CPU Temperature = &#x27;</span>+CPU_temp)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;CPU Use = &#x27;</span>+CPU_usage)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;RAM Total = &#x27;</span>+<span class="hljs-built_in">str</span>(RAM_total)+<span class="hljs-string">&#x27; MB&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;RAM Used = &#x27;</span>+<span class="hljs-built_in">str</span>(RAM_used)+<span class="hljs-string">&#x27; MB&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;RAM Free = &#x27;</span>+<span class="hljs-built_in">str</span>(RAM_free)+<span class="hljs-string">&#x27; MB&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#x27;</span>) <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;DISK Total Space = &#x27;</span>+<span class="hljs-built_in">str</span>(DISK_total)+<span class="hljs-string">&#x27;B&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;DISK Used Space = &#x27;</span>+<span class="hljs-built_in">str</span>(DISK_used)+<span class="hljs-string">&#x27;B&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;DISK Used Percentage = &#x27;</span>+<span class="hljs-built_in">str</span>(DISK_perc))<br></code></pre></td></tr></table></figure>

<p>之后就可以执行这个脚本了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">sudo chmod +x getInfo,py	<span class="hljs-comment"># 赋予可执行权限</span><br>python getInfo.py		<span class="hljs-comment"># 在当前文件夹下执行脚本</span><br></code></pre></td></tr></table></figure>

<p>脚本执行的结果如下。</p>
<p><img src="%E6%9F%A5%E7%9C%8B%E6%A0%91%E8%8E%93%E6%B4%BE%E7%8A%B6%E6%80%81.jpg"></p>
<h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以上就是对树莓派从入手到初步配置的一个简单记录，个自己做个笔记，下次再用的时候就方便了。树莓派能折腾的东西很多，以后有新的踩坑经历了再来接着写。</p>
]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>树莓派</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
</search>
